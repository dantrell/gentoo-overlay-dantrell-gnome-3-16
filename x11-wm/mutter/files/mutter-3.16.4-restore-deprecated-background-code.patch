diff '--exclude=.git' -urN a/doc/reference/meta-docs.sgml.in b/doc/reference/meta-docs.sgml.in
--- a/doc/reference/meta-docs.sgml.in	2015-10-30 16:39:40.955006743 -0400
+++ b/doc/reference/meta-docs.sgml.in	2015-10-31 10:42:33.154533756 -0400
@@ -22,6 +22,7 @@
     <title>Mutter Core Reference</title>
     <xi:include href="xml/main.xml"/>
     <xi:include href="xml/common.xml"/>
+    <xi:include href="xml/gradient.xml"/>
     <xi:include href="xml/prefs.xml"/>
     <xi:include href="xml/util.xml"/>
     <xi:include href="xml/errors.xml"/>
diff '--exclude=.git' -urN a/doc/reference/meta-sections.txt b/doc/reference/meta-sections.txt
--- a/doc/reference/meta-sections.txt	2015-10-30 16:39:40.955006743 -0400
+++ b/doc/reference/meta-sections.txt	2015-10-31 10:42:33.165533693 -0400
@@ -173,6 +173,15 @@
 </SECTION>
 
 <SECTION>
+<FILE>gradient</FILE>
+MetaGradientType
+meta_gradient_create_simple
+meta_gradient_create_multi
+meta_gradient_create_interwoven
+meta_gradient_add_alpha
+</SECTION>
+
+<SECTION>
 <FILE>group</FILE>
 MetaGroup
 meta_window_get_group
diff '--exclude=.git' -urN a/doc/theme-format.txt b/doc/theme-format.txt
--- a/doc/theme-format.txt	1969-12-31 19:00:00.000000000 -0500
+++ b/doc/theme-format.txt	2015-10-31 13:31:30.720084882 -0400
@@ -0,0 +1,396 @@
+Themes are in a simple XML-subset format. There are multiple versions
+of the theme format, and a given theme can support more than one format.
+
+Version 1:     THEMEDIR/metacity-1/metacity-theme-1.xml
+  (original metacity format)
+Version 2:     THEMEDIR/metacity-1/metacity-theme-2.xml
+Version 3:     THEMEDIR/metacity-1/metacity-theme-3.xml
+
+The subdirectory name is "metacity-1" in all versions.
+
+As you might expect, older versions of metacity will not understand
+newer theme formats. However, newer versions will use old themes.
+Metacity will always use the newest theme format it understands that
+the X server supports. Some format versions are only supported if you
+have the right X server features.
+
+Each format *requires* the corresponding filename. If you put version
+2 format features in the metacity-1/metacity-theme-1.xml file, then
+metacity will get angry.
+
+This document has separate sections for each format version. You may
+want to read the document in reverse order, since the base features
+are discussed under version 1.
+
+New Features in Theme Format Version 3.4
+========================================
+
+An additional color type is added to pick up custom colors defined
+in the GTK+ theme's CSS:
+
+  gtk:custom(name,fallback)
+
+where <name> refers to a custom color defined with @define-color in
+the GTK+ theme, and <fallback> provides an alternative color definition
+in case the color referenced by <name> is not found.
+
+New Features in Theme Format Version 3.3
+========================================
+
+Add two additional button background functions - left_single_background and
+right_single_background - for button groups with just a single button.
+
+There are now additional frame states to style left/right tiled windows
+differently ("tiled_left", "tiled_right", "tiled_left_and_shaded",
+"tiled_right_and_shaded").
+
+New Features in Theme Format Version 3.2
+========================================
+
+A new window type 'attached' is added for modal dialogs which are
+attached to their parent window. (When the attach_modal_dialogs preference
+is turned on.) If no style is defined for the 'attached' window type,
+the 'border' window type will be used instead.
+
+New Features in Theme Format Version 3.1
+========================================
+
+Additional predefined variables are added for positioning expressions:
+
+ frame_x_center: the X center of the entire frame, with respect to the
+     piece currently being drawn.
+ frame_y_center: the Y center of the entire frame, with respect to the
+     piece currently being drawn.
+
+The <title/> element now supports an "ellipsize_width" attribute. When
+specified, this gives a width at which to ellipsize the title. If not
+specified, the title will simply be clipped to the title area.
+
+New Features in Theme Format Version 3
+======================================
+
+Format version 3 has exactly one new feature; any element in the file
+can now have a version attribute:
+
+  version="[<|<=|=>|>] MAJOR.MINOR"
+
+(< and > should be to be entity escaped as &lt; and &gt;). If this
+version check is not met, then the element and its children will be
+ignored. This allows having alternate sections of the theme file for
+older and newer version of the Metacity theme format.
+
+When placed on the toplevel <metacity_theme> element, an unsatisfied
+version check will not just cause the contents of the file to be
+ignored, it will also cause the lookup of a theme file to proceed on
+and look for an older format 2 or format 1 file. This allows making a
+metacity-theme-3.xml file that is only used the format version 3.2 or
+newer is supported, and using metacity-theme-1.xml for older window
+managers.
+
+New Features in Theme Format Version 2
+======================================
+
+The optional attributes rounded_top_left, rounded_top_right,
+rounded_bottom_left and rounded_bottom_right on <frame_geometry>
+should now be the radius of the corner in pixels. You may still use
+the values "false" for 0 and "true" for 5, which means v1 values will
+still work just fine.
+
+<frame_geometry> has a new optional attribute, hide_buttons. If this
+is true, no buttons will be displayed on the titlebar.
+
+Anywhere you can use a positive integer, you can use an integer constant.
+
+As well as constant integers and reals, you may define constant colours,
+thus:
+  <constant name="RevoltingPink" value="#FF00FF"/>
+  <constant name="Background" value="gtk:bg[NORMAL]"/>
+
+<frame_style> has two new optional attributes, background and alpha.
+If you specify alpha, you must specify background. background is a
+colour used for the background of the frame. alpha is the transparency
+as a real between 0.0 and 1.0. If the current X server does not support
+alpha channels, the value is ignored.
+
+The filename attribute of <image> may begin with "theme:". If so, the
+rest of the string is the name of a theme icon. The 64x64 version of the
+icon is used, except for fallback mini_icons, which use the 16x16 version.
+This does not affect ordinary resizing. For example:
+  <button function="close" state="normal">
+    <draw_ops>
+      <include name="active_button"/>
+      <image filename="theme:gnome-logout" x="2" y="2"
+          width="width-4" height="height-4"/>
+      <!-- Note: not "theme:gnome-logout.png" or similar. -->
+    </draw_ops>
+  </button>
+
+<menu_icon>s are parsed but ignored.
+
+Fallback icons can be specified using <fallback>. There are two
+optional arguments, icon and mini_icon. The values of these arguments
+are identical to that of the filename attribute of <image>. Fallback
+icons are used when a window does not supply its own icon. If a fallback
+icon is not specified with <fallback>, Metacity will use a built-in
+icon, as in metacity-theme-1.
+
+The <arc> element, as well as the original start_angle and end_angle
+attributes, may be given from and to attributes. The values of these
+attributes are given in degrees clockwise, with 0 being straight up.
+For example:
+  <arc from="0.0" to="90.0" filled="true" color="#FF00FF"
+      x="0" y="5" width="15" height="15"/>
+
+<frame state="shaded"> may now take an optional resize attribute, with
+the same interpretation as the resize attribute on <frame state="normal">.
+If this attribute is omitted for state="shaded", it defaults to "both".
+(If it is omitted for state="normal", it remains an error.)
+
+In addition to the four <button> functions which are required in
+metacity-theme-1, there are six new functions in metacity-theme-2:
+shade, unshade, above, unabove, stick and unstick.
+      
+Overview of Theme Format Version 1
+==================================
+
+<?xml version="1.0"?>
+<metacity_theme>
+<!-- Only one info section is allowed -->
+<info>
+  <name>Foo</name>
+  <author>Foo P. Bar</author>
+  <copyright>whoever, 2002</copyright>
+  <date>Jan 31 2005</date>
+  <description>A sentence about the theme.</description>
+</info>
+
+<!-- define a frame geometry to be referenced later -->
+<!-- frame_geometry has an optional has_title attribute which 
+     determines whether the title text height is included in the 
+     height calculation. if not specified, defaults to true.
+     It also has an optional text_size="medium" attribute
+     (same sizes as with Pango markup, xx-small thru medium thru
+     xx-large) 
+
+     Finally it has optional args rounded_top_left=true, 
+     rounded_top_right=true, rounded_bottom_left=true,
+     rounded_bottom_right=true.
+
+     -->
+<frame_geometry name="normal" has_title="true" title_scale="medium">
+  <distance name="left_width" value="6"/>
+  <distance name="right_width" value="6"/>
+  <distance name="bottom_height" value="7"/>
+  <distance name="left_titlebar_edge" value="6"/>
+  <distance name="right_titlebar_edge" value="6"/>
+  <distance name="button_width" value="17"/>
+  <distance name="button_height" value="17"/>
+  <!-- alternative to button_width button_height distances -->
+  <aspect_ratio name="button" value="1.0"/>
+  <distance name="title_vertical_pad" value="4"/>
+  <border name="title_border" left="3" right="12" top="4" bottom="3"/>
+  <border name="button_border" left="0" right="0" top="1" bottom="1"/>
+</frame_geometry>
+
+<!-- inheritance is allowed; simply overwrites values from parent -->
+<frame_geometry name="borderless" parent="normal">
+  <distance name="left_width" value="0"/>
+  <distance name="right_width" value="0"/>
+  <distance name="bottom_height" value="0"/>
+  <distance name="left_titlebar_edge" value="0"/>
+  <distance name="right_titlebar_edge" value="0"/>
+</frame_geometry>
+
+<!-- define a constant to use in positions/sizes of draw operations;
+     constant names must start with a capital letter.
+  -->
+<constant name="LineOffset" value="3"/>
+
+<!-- define drawing operations to be referenced later; 
+     these draw-op lists can also be placed inline. 
+
+     Positions/lengths are given as expressions.
+     Operators are: +,-,*,/,%,`max`,`min`
+     All operators are infix including `max` and `min`, 
+      i.e. "2 `max` 5"
+     
+     Some variables are predefined, and constants can also 
+     be used. Variables are:
+
+       width - width of target area
+       height - height of target area
+       object_width - natural width of object being drawn
+       object_height - natural height of object being drawn
+       left_width - distance from left of frame to client window
+       right_width - distance from right of frame to client window
+       top_height - distance from top of frame to client window
+       bottom_height - distance from bottom of frame to client window
+       mini_icon_width - width of mini icon for window
+       mini_icon_height - height of mini icon
+       icon_width - width of large icon
+       icon_height - height of large icon
+       title_width - width of title text
+       title_height - height of title text
+
+    All these are always defined, except object_width/object_height 
+    which only exists for <image> right now.
+
+  -->
+
+<draw_ops name="demo_all_ops">
+  <line color="#00FF00" x1="LineOffset" y1="0" x2="0" y2="height"/>
+  <line color="gtk:fg[NORMAL]" 
+        x1="width - 1" y1="0" x2="width - 1" y2="height" 
+        width="3" dash_on_length="2" dash_off_length="3"/>
+  <rectangle color="blend/gtk:fg[NORMAL]/gtk:bg[NORMAL]/0.7"
+             x="0" y="0" width="width - 1" height="height - 1" filled="true"/>
+  <arc color="dark gray" x="0" y="0" width="width - 1" height="height - 1" 
+       filled="false" start_angle="30" extent_angle="180"/>
+  <tint color="orange" alpha="0.5" x="0" y="0" width="width" height="height"/>
+ <!-- may be vertical, horizontal, diagonal -->
+  <gradient type="diagonal" 
+            x="10" y="30" width="width / 3" height="height / 4">
+    <!-- any number of colors allowed here. A color can be 
+         a color name like "blue" (look at gcolorsel), a hex color
+         as in HTML (#FFBB99), or a color from the gtk theme 
+         given as "gtk:base[NORMAL]", "gtk:fg[ACTIVE]", etc.
+       -->
+    <color value="gtk:fg[SELECTED]"/>
+    <!-- color obtained by a 0.5 alpha composite of the second color onto the first -->
+    <color value="blend/gtk:bg[SELECTED]/gtk:fg[SELECTED]/0.5"/>
+  </gradient>
+  <!-- image has an optional colorize="#color" attribute to give the
+       image a certain color -->
+  <image filename="foo.png" alpha="0.7"
+         x="10" y="30" width="width / 3" height="height / 4"/>
+  <gtk_arrow state="normal" shadow="in" arrow="up"
+             filled="true"
+             x="2" y="2" width="width - 4" height="height - 4"/>
+  <gtk_box state="normal" shadow="out"
+           x="2" y="2" width="width - 4" height="height - 4"/>
+  <gtk_vline state="normal" x="2" y1="0" y2="height"/>
+  <!-- window's icon -->
+  <icon alpha="0.7"
+        x="10" y="30" width="width / 3" height="height / 4"/>
+  <!-- window's title -->
+  <title color="gtk:text[NORMAL]" x="20" y="30"/>
+  <!-- include another draw ops list; has optional x/y/width/height attrs -->
+  <include name="some_other_draw_ops"/>
+  <!-- tile another draw ops list; has optional
+       x/y/width/height/tile_xoffset/tile_yoffset -->
+  <tile name="some_other_draw_ops" tile_width="10" tile_height="10"/>
+</draw_ops>
+
+<frame_style name="normal" geometry="normal">
+  <!-- How to draw each piece of the frame.
+       For each piece, a draw_ops can be given inline or referenced 
+       by name. If a piece is omitted, then nothing will be drawn 
+       for that piece.
+
+       For each piece, the "width" and "height" variables in 
+       coordinate expressions refers to the dimensions of the piece, 
+       the origin is at the top left of the piece.
+  
+       So <rectangle x="0" y="0" width="width-1" height="height-1"/>
+       will outline a piece.
+    -->
+
+  <piece position="entire_background" draw_ops="demo_all_ops"/>
+  <piece position="left_titlebar_edge">
+    <draw_ops>
+      <line color="#00FF00" x1="0" y1="0" x2="0" y2="height"/>
+    </draw_ops>
+  </piece>
+
+  <!-- The complete list of frame pieces:
+
+       entire_background: whole frame
+       titlebar: entire area above the app's window 
+       titlebar_middle: area of titlebar_background not considered
+                        part of an edge
+       left_titlebar_edge: left side of titlebar background
+       right_titlebar_edge: right side of titlebar background
+       top_titlebar_edge: top side of titlebar background
+       bottom_titlebar_edge: bottom side of titlebar background 
+       title: the title area (doesn't include buttons)
+       left_edge: left edge of the frame
+       right_edge: right edge of the frame
+       bottom_edge: bottom edge of the frame
+       overlay: same area as entire_background, but drawn after 
+                drawing all sub-pieces instead of before
+
+   -->
+
+  <!-- For buttons, drawing methods have to be provided for 
+       each of three states: 
+          normal, pressed, prelight
+       and the button function or position must be provided:
+          close, maximize, minimize, menu, 
+          left_left_background, left_middle_background,
+          left_right_background, right_left_background, 
+          right_middle_background, right_right_background
+       So a working theme needs 3*4 = 12 button declarations
+       and a theme may have up to 3*10 = 30 button declarations
+       in order to handle button-rearrangement preferences.
+ 
+       (The name "function" for the attribute is from before the 
+        background values existed.)
+    -->
+
+  <button function="close" state="normal" draw_ops="previously_named"/>
+  <button function="menu" state="normal">
+    <draw_ops>
+      <icon alpha="0.7"
+            x="0" y="0" width="object_width" height="object_height"/>
+    </draw_ops>
+  </button>
+
+</frame_style>
+
+<!-- styles can inherit from each other with the parent="" attribute. 
+     In a subclass anything can be re-specified to override 
+     the parent style. -->
+<frame_style name="focused" parent="normal">
+  <piece position="title">
+    <draw_ops>
+      <rectangle color="gtk:bg[SELECTED]"
+                 x="0" y="0" width="width-1" height="height-1"/>
+      <title color="gtk:fg[SELECTED]" x="(width - title_width) / 2"
+                                      y="(height - title_height) / 2"/>
+    </draw_ops>
+  </piece>
+</frame_style>
+
+<!-- Maps styles to states of frame. 
+
+     Focus: yes (focused), no (not focused)
+     Window states: normal, maximized, shaded, maximized_and_shaded
+     Window resizability: none, vertical, horizontal, both
+
+     Everything unspecified just does the same as
+     unfocused/normal/both.
+
+     only state="normal" needs a resize="" attribute.
+ -->
+<frame_style_set name="normal">
+<frame focus="yes" state="normal" resize="both" style="focused"/>
+<frame focus="no" state="normal" resize="both" style="normal"/>
+</frame_style_set>
+
+<!-- Each window type needs a style set 
+     Types: normal, dialog, modal_dialog, menu, utility, border
+  -->
+<window type="normal" style_set="normal"/>
+
+
+<!-- For menu icons, drawing methods are needed for the same 
+     four types as the buttons, and GTK states
+     (insensitive,prelight,normal,etc.)
+  -->
+
+<menu_icon function="close" state="normal" draw_ops="previously_named"/>
+
+
+</metacity_theme>
+
+
diff '--exclude=.git' -urN a/src/Makefile-tests.am b/src/Makefile-tests.am
--- a/src/Makefile-tests.am	2015-10-30 16:39:40.961006717 -0400
+++ b/src/Makefile-tests.am	2015-10-31 13:33:56.668252083 -0400
@@ -41,9 +41,11 @@
 # Some random test programs for bits of the code
 
 testboxes_SOURCES = core/testboxes.c
+testgradient_SOURCES = ui/testgradient.c
 testasyncgetprop_SOURCES = x11/testasyncgetprop.c
 
-noinst_PROGRAMS+=testboxes testasyncgetprop
+noinst_PROGRAMS+=testboxes testgradient testasyncgetprop
 
 testboxes_LDADD = $(MUTTER_LIBS) libmutter.la
+testgradient_LDADD = $(MUTTER_LIBS) libmutter.la
 testasyncgetprop_LDADD = $(MUTTER_LIBS) libmutter.la
diff '--exclude=.git' -urN a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am	2015-10-30 16:39:40.961006717 -0400
+++ b/src/Makefile.am	2015-10-31 13:33:56.678252026 -0400
@@ -115,10 +115,8 @@
 	compositor/compositor.c			\
 	compositor/compositor-private.h		\
 	compositor/meta-background.c		\
-	compositor/meta-background-private.h	\
 	compositor/meta-background-actor.c	\
 	compositor/meta-background-actor-private.h	\
-	compositor/meta-background-image.c	\
 	compositor/meta-background-group.c	\
 	compositor/meta-cullable.c		\
 	compositor/meta-cullable.h		\
@@ -156,7 +154,6 @@
 	meta/compositor.h			\
 	meta/meta-background.h			\
 	meta/meta-background-actor.h		\
-	meta/meta-background-image.h		\
 	meta/meta-background-group.h		\
 	meta/meta-plugin.h			\
 	meta/meta-shadow-factory.h		\
@@ -177,6 +174,8 @@
 	meta/errors.h				\
 	core/frame.c				\
 	core/frame.h				\
+	ui/gradient.c				\
+	meta/gradient.h				\
 	core/meta-gesture-tracker.c		\
 	core/meta-gesture-tracker-private.h	\
 	core/keybindings.c			\
@@ -208,6 +207,9 @@
 	ui/ui.h					\
 	ui/frames.c				\
 	ui/frames.h				\
+	ui/resizepopup.c			\
+	ui/resizepopup.h			\
+	ui/theme-parser.c			\
 	ui/theme.c				\
 	meta/theme.h				\
 	ui/theme-private.h			\
@@ -309,14 +311,14 @@
 	meta/compositor.h			\
 	meta/display.h				\
 	meta/errors.h				\
+	meta/gradient.h				\
 	meta/group.h				\
 	meta/keybindings.h			\
 	meta/main.h				\
 	meta/meta-backend.h			\
-	meta/meta-background.h			\
 	meta/meta-background-actor.h		\
-	meta/meta-background-image.h		\
 	meta/meta-background-group.h		\
+	meta/meta-background.h			\
 	meta/meta-cursor-tracker.h		\
 	meta/meta-idle-monitor.h		\
 	meta/meta-plugin.h			\
diff '--exclude=.git' -urN a/src/compositor/cogl-utils.c b/src/compositor/cogl-utils.c
--- a/src/compositor/cogl-utils.c	2015-06-13 23:59:51.982809000 -0400
+++ b/src/compositor/cogl-utils.c	2015-10-31 11:13:25.288109099 -0400
@@ -64,78 +64,3 @@
 
   return pipeline;
 }
-
-static gboolean is_pot(int x)
-{
-  return x > 0 && (x & (x - 1)) == 0;
-}
-
-/**
- * meta_create_texture:
- * @width: width of the texture to create
- * @height: height of the texture to create
- * @components; components to store in the texture (color or alpha)
- * @flags: flags that affect the allocation behavior
- *
- * Creates a texture of the given size with the specified components
- * for use as a frame buffer object.
- *
- * If non-power-of-two textures are not supported on the system, then
- * the texture will be created as a texture rectangle; in this case,
- * hardware repeating isn't possible, and texture coordinates are also
- * different, but Cogl hides these issues from the application, except from
- * GLSL shaders. Since GLSL is never (or at least almost never)
- * present on such a system, this is not typically an issue.
- *
- * If %META_TEXTURE_ALLOW_SLICING is present in @flags, and the texture
- * is larger than the texture size limits of the system, then the texture
- * will be created as a sliced texture. This also will cause problems
- * with using the texture with GLSL, and is more likely to be an issue
- * since all GL implementations have texture size limits, and they can
- * be as small as 2048x2048 on reasonably current systems.
- */
-CoglTexture *
-meta_create_texture (int                   width,
-                     int                   height,
-                     CoglTextureComponents components,
-                     MetaTextureFlags      flags)
-{
-  ClutterBackend *backend = clutter_get_default_backend ();
-  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
-  CoglTexture *texture;
-
-  gboolean should_use_rectangle = FALSE;
-
-  if (!(is_pot (width) && is_pot (height)) &&
-      !cogl_has_feature (ctx, COGL_FEATURE_ID_TEXTURE_NPOT))
-    {
-      if (cogl_has_feature (ctx, COGL_FEATURE_ID_TEXTURE_RECTANGLE))
-        should_use_rectangle = TRUE;
-      else
-        g_error ("Cannot create texture. Support for GL_ARB_texture_non_power_of_two or "
-                 "ARB_texture_rectangle is required");
-    }
-
-  if (should_use_rectangle)
-    texture = COGL_TEXTURE (cogl_texture_rectangle_new_with_size (ctx, width, height));
-  else
-    texture = COGL_TEXTURE (cogl_texture_2d_new_with_size (ctx, width, height));
-  cogl_texture_set_components (texture, components);
-
-  if ((flags & META_TEXTURE_ALLOW_SLICING) != 0)
-    {
-      /* To find out if we need to slice the texture, we have to go ahead and force storage
-       * to be allocated
-       */
-      CoglError *catch_error = NULL;
-      if (!cogl_texture_allocate (texture, &catch_error))
-        {
-          cogl_error_free (catch_error);
-          cogl_object_unref (texture);
-          texture = COGL_TEXTURE (cogl_texture_2d_sliced_new_with_size (ctx, width, height, COGL_TEXTURE_MAX_WASTE));
-          cogl_texture_set_components (texture, components);
-        }
-    }
-
-  return texture;
-}
diff '--exclude=.git' -urN a/src/compositor/cogl-utils.h b/src/compositor/cogl-utils.h
--- a/src/compositor/cogl-utils.h	2015-06-13 23:59:51.982809000 -0400
+++ b/src/compositor/cogl-utils.h	2015-10-31 11:13:25.288109099 -0400
@@ -25,14 +25,4 @@
 
 CoglPipeline * meta_create_texture_pipeline (CoglTexture *texture);
 
-typedef enum {
-  META_TEXTURE_FLAGS_NONE = 0,
-  META_TEXTURE_ALLOW_SLICING = 1 << 1
-} MetaTextureFlags;
-
-CoglTexture *meta_create_texture (int                   width,
-                                  int                   height,
-                                  CoglTextureComponents components,
-                                  MetaTextureFlags      flags);
-
 #endif /* __META_COGL_UTILS_H__ */
diff '--exclude=.git' -urN a/src/compositor/meta-background-actor.c b/src/compositor/meta-background-actor.c
--- a/src/compositor/meta-background-actor.c	2015-06-13 23:59:51.983809000 -0400
+++ b/src/compositor/meta-background-actor.c	2015-10-31 11:13:25.288109099 -0400
@@ -1,7 +1,7 @@
 /* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
 /*
  * Copyright 2009 Sander Dijkhuis
- * Copyright 2014 Red Hat, Inc.
+ * Copyright 2010 Red Hat, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -26,122 +26,23 @@
  *
  */
 
-/*
- * The overall model drawing model of this widget is that we have one
- * texture, or two interpolated textures, possibly with alpha or
- * margins that let the underlying background show through, blended
- * over a solid color or a gradient. The result of that combination
- * can then be affected by a "vignette" that darkens the background
- * away from a central point (or as a no-GLSL fallback, simply darkens
- * the background) and by overall opacity.
- *
- * As of GNOME 3.14, GNOME is only using a fraction of this when the
- * user sets the background through the control center - what can be
- * set is:
- *
- *  A single image without a border
- *  An animation of images without a border that blend together,
- *   with the blend changing every 4-5 minutes
- *  A solid color with a repeated noise texture blended over it
- *
- * This all is pretty easy to do in a fragment shader, except when:
- *
- *  A) We don't have GLSL - in this case, the operation of
- *     interpolating the two textures and blending the result over the
- *     background can't be expressed with Cogl's fixed-function layer
- *     combining (which is confined to what GL's texture environment
- *     combining can do) So we can only handle the above directly if
- *     there are no margins or alpha.
- *
- *  B) The image textures are sliced. Texture size limits on older
- *     hardware (pre-965 intel hardware, r300, etc.)  is often 2048,
- *     and it would be common to use a texture larger than this for a
- *     background and expect it to be scaled down. Cogl can compensate
- *     for this by breaking the texture up into multiple textures, but
- *     can't multitexture with sliced textures. So we can only handle
- *     the above if there's a single texture.
- *
- * However, even when we *can* represent everything in a single pass,
- * it's not necessarily efficient. If we want to draw a 1024x768
- * background, it's pretty inefficient to bilinearly texture from
- * two 2560x1440 images and mix that. So the drawing model we take
- * here is that MetaBackground generates a single texture (which
- * might be a 1x1 texture for a solid color, or a 1x2 texture for a
- * gradient, or a repeated texture for wallpaper, or a pre-rendered
- * texture the size of the screen), and we draw with that, possibly
- * adding the vignette and opacity.
- */
-
 #include <config.h>
 
+#include <cogl/cogl-texture-pixmap-x11.h>
+
 #include <clutter/clutter.h>
 
+#include <X11/Xatom.h>
+
 #include "cogl-utils.h"
-#include "clutter-utils.h"
+#include "compositor-private.h"
 #include <meta/errors.h>
+#include <meta/meta-background.h>
 #include "meta-background-actor-private.h"
-#include "meta-background-private.h"
 #include "meta-cullable.h"
 
-enum
-{
-  PROP_META_SCREEN = 1,
-  PROP_MONITOR,
-  PROP_BACKGROUND,
-  PROP_VIGNETTE,
-  PROP_VIGNETTE_SHARPNESS,
-  PROP_BRIGHTNESS
-};
-
-typedef enum {
-  CHANGED_BACKGROUND = 1 << 0,
-  CHANGED_EFFECTS = 1 << 2,
-  CHANGED_VIGNETTE_PARAMETERS = 1 << 3,
-  CHANGED_ALL = 0xFFFF
-} ChangedFlags;
-
-#define VERTEX_SHADER_DECLARATIONS                                      \
-"uniform vec2 scale;\n"                                                 \
-"uniform vec2 offset;\n"                                                \
-"varying vec2 position;\n"                                              \
-
-#define VERTEX_SHADER_CODE                                              \
-"position = cogl_tex_coord0_in.xy * scale + offset;\n"                  \
-
-#define FRAGMENT_SHADER_DECLARATIONS                                    \
-"uniform float vignette_sharpness;\n"                                   \
-"varying vec2 position;\n"                                              \
-
-#define FRAGMENT_SHADER_CODE                                                   \
-"float t = 2.0 * length(position);\n"                                          \
-"t = min(t, 1.0);\n"                                                           \
-"float pixel_brightness = 1.0 - t * vignette_sharpness;\n"                       \
-"cogl_color_out.rgb = cogl_color_out.rgb * pixel_brightness;\n"                \
-
-typedef struct _MetaBackgroundLayer MetaBackgroundLayer;
-
-typedef enum {
-  PIPELINE_VIGNETTE = (1 << 0),
-  PIPELINE_BLEND = (1 << 1),
-} PipelineFlags;
-
 struct _MetaBackgroundActorPrivate
 {
-  MetaScreen *screen;
-  int monitor;
-
-  MetaBackground *background;
-
-  gboolean vignette;
-  double brightness;
-  double vignette_sharpness;
-
-  ChangedFlags changed;
-  CoglPipeline *pipeline;
-  PipelineFlags pipeline_flags;
-  cairo_rectangle_int_t texture_area;
-  gboolean force_bilinear;
-
   cairo_region_t *clip_region;
 };
 
@@ -165,45 +66,27 @@
 meta_background_actor_dispose (GObject *object)
 {
   MetaBackgroundActor *self = META_BACKGROUND_ACTOR (object);
-  MetaBackgroundActorPrivate *priv = self->priv;
 
   set_clip_region (self, NULL);
-  meta_background_actor_set_background (self, NULL);
-  if (priv->pipeline)
-    {
-      cogl_object_unref (priv->pipeline);
-      priv->pipeline = NULL;
-    }
 
   G_OBJECT_CLASS (meta_background_actor_parent_class)->dispose (object);
 }
 
 static void
-get_preferred_size (MetaBackgroundActor *self,
-                    gfloat              *width,
-                    gfloat              *height)
-{
-  MetaBackgroundActorPrivate *priv = META_BACKGROUND_ACTOR (self)->priv;
-  MetaRectangle monitor_geometry;
-
-  meta_screen_get_monitor_geometry (priv->screen, priv->monitor, &monitor_geometry);
-
-  if (width != NULL)
-    *width = monitor_geometry.width;
-
-  if (height != NULL)
-    *height = monitor_geometry.height;
-}
-
-static void
 meta_background_actor_get_preferred_width (ClutterActor *actor,
                                            gfloat        for_height,
                                            gfloat       *min_width_p,
                                            gfloat       *natural_width_p)
 {
+  ClutterContent *content;
   gfloat width;
 
-  get_preferred_size (META_BACKGROUND_ACTOR (actor), &width, NULL);
+  content = clutter_actor_get_content (actor);
+
+  if (content)
+    clutter_content_get_preferred_size (content, &width, NULL);
+  else
+    width = 0;
 
   if (min_width_p)
     *min_width_p = width;
@@ -218,9 +101,15 @@
                                             gfloat       *natural_height_p)
 
 {
+  ClutterContent *content;
   gfloat height;
 
-  get_preferred_size (META_BACKGROUND_ACTOR (actor), NULL, &height);
+  content = clutter_actor_get_content (actor);
+
+  if (content)
+    clutter_content_get_preferred_size (content, NULL, &height);
+  else
+    height = 0;
 
   if (min_height_p)
     *min_height_p = height;
@@ -228,430 +117,43 @@
     *natural_height_p = height;
 }
 
-static CoglPipeline *
-make_pipeline (PipelineFlags pipeline_flags)
-{
-  static CoglPipeline *templates[4];
-  CoglPipeline **templatep;
-
-  templatep = &templates[pipeline_flags];
-  if (*templatep == NULL)
-    {
-      /* Cogl automatically caches pipelines with no eviction policy,
-       * so we need to prevent identical pipelines from getting cached
-       * separately, by reusing the same shader snippets.
-       */
-      *templatep = COGL_PIPELINE (meta_create_texture_pipeline (NULL));
-
-      if ((pipeline_flags & PIPELINE_VIGNETTE) != 0)
-        {
-          static CoglSnippet *vertex_snippet;
-          static CoglSnippet *fragment_snippet;
-
-          if (!vertex_snippet)
-            vertex_snippet = cogl_snippet_new (COGL_SNIPPET_HOOK_VERTEX,
-                                               VERTEX_SHADER_DECLARATIONS, VERTEX_SHADER_CODE);
-
-          cogl_pipeline_add_snippet (*templatep, vertex_snippet);
-
-          if (!fragment_snippet)
-            fragment_snippet = cogl_snippet_new (COGL_SNIPPET_HOOK_FRAGMENT,
-                                                 FRAGMENT_SHADER_DECLARATIONS, FRAGMENT_SHADER_CODE);
-
-          cogl_pipeline_add_snippet (*templatep, fragment_snippet);
-        }
-
-      if ((pipeline_flags & PIPELINE_BLEND) == 0)
-        cogl_pipeline_set_blend (*templatep, "RGBA = ADD (SRC_COLOR, 0)", NULL);
-    }
-
-  return cogl_pipeline_copy (*templatep);
-}
-
-static void
-setup_pipeline (MetaBackgroundActor   *self,
-                cairo_rectangle_int_t *actor_pixel_rect)
-{
-  MetaBackgroundActorPrivate *priv = self->priv;
-  PipelineFlags pipeline_flags = 0;
-  guint8 opacity;
-  float color_component;
-  CoglPipelineFilter filter;
-
-  opacity = clutter_actor_get_paint_opacity (CLUTTER_ACTOR (self));
-  if (opacity < 255)
-    pipeline_flags |= PIPELINE_BLEND;
-  if (priv->vignette && clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL))
-    pipeline_flags |= PIPELINE_VIGNETTE;
-
-  if (priv->pipeline &&
-      pipeline_flags != priv->pipeline_flags)
-    {
-      cogl_object_unref (priv->pipeline);
-      priv->pipeline = NULL;
-    }
-
-  if (priv->pipeline == NULL)
-    {
-      priv->pipeline_flags = pipeline_flags;
-      priv->pipeline = make_pipeline (pipeline_flags);
-      priv->changed = CHANGED_ALL;
-    }
-
-  if ((priv->changed & CHANGED_BACKGROUND) != 0)
-    {
-      CoglPipelineWrapMode wrap_mode;
-      CoglTexture *texture = meta_background_get_texture (priv->background,
-                                                          priv->monitor,
-                                                          &priv->texture_area,
-                                                          &wrap_mode);
-      priv->force_bilinear = texture &&
-        (priv->texture_area.width != (int)cogl_texture_get_width (texture) ||
-         priv->texture_area.height != (int)cogl_texture_get_height (texture));
-
-      cogl_pipeline_set_layer_texture (priv->pipeline, 0, texture);
-      cogl_pipeline_set_layer_wrap_mode (priv->pipeline, 0, wrap_mode);
-    }
-
-  if ((priv->changed & CHANGED_VIGNETTE_PARAMETERS) != 0)
-    {
-      cogl_pipeline_set_uniform_1f (priv->pipeline,
-                                    cogl_pipeline_get_uniform_location (priv->pipeline,
-                                                                        "vignette_sharpness"),
-                                    priv->vignette_sharpness);
-    }
-
-  if (priv->vignette)
-    {
-      color_component = priv->brightness * opacity / 255.;
-
-      if (!clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL))
-        {
-          /* Darken everything to match the average brightness that would
-           * be there if we were drawing the vignette, which is
-           * (1 - (pi/12.) * vignette_sharpness) [exercise for the reader :]
-           */
-          color_component *= (1 - 0.74 * priv->vignette_sharpness);
-        }
-    }
-  else
-    color_component = opacity / 255.;
-
-  cogl_pipeline_set_color4f (priv->pipeline,
-                             color_component,
-                             color_component,
-                             color_component,
-                             opacity / 255.);
-
-  if (!priv->force_bilinear &&
-      meta_actor_painting_untransformed (actor_pixel_rect->width, actor_pixel_rect->height, NULL, NULL))
-    filter = COGL_PIPELINE_FILTER_NEAREST;
-  else
-    filter = COGL_PIPELINE_FILTER_LINEAR;
-
-  cogl_pipeline_set_layer_filters (priv->pipeline, 0, filter, filter);
-}
-
-static void
-set_glsl_parameters (MetaBackgroundActor   *self,
-                     cairo_rectangle_int_t *actor_pixel_rect)
-{
-  MetaBackgroundActorPrivate *priv = self->priv;
-  float scale[2];
-  float offset[2];
-
-  /* Compute a scale and offset for transforming texture coordinates to the
-   * coordinate system from [-0.5 to 0.5] across the area of the actor
-   */
-  scale[0] = priv->texture_area.width / (float)actor_pixel_rect->width;
-  scale[1] = priv->texture_area.height / (float)actor_pixel_rect->height;
-  offset[0] = priv->texture_area.x / (float)actor_pixel_rect->width - 0.5;
-  offset[1] = priv->texture_area.y / (float)actor_pixel_rect->height - 0.5;
-
-  cogl_pipeline_set_uniform_float (priv->pipeline,
-                                   cogl_pipeline_get_uniform_location (priv->pipeline,
-                                                                       "scale"),
-                                   2, 1, scale);
-
-  cogl_pipeline_set_uniform_float (priv->pipeline,
-                                   cogl_pipeline_get_uniform_location (priv->pipeline,
-                                                                       "offset"),
-                                   2, 1, offset);
-}
-
-static void
-paint_clipped_rectangle (CoglFramebuffer       *fb,
-                         CoglPipeline          *pipeline,
-                         cairo_rectangle_int_t *rect,
-                         cairo_rectangle_int_t *texture_area)
-{
-  float x1, y1, x2, y2;
-  float tx1, ty1, tx2, ty2;
-
-  x1 = rect->x;
-  y1 = rect->y;
-  x2 = rect->x + rect->width;
-  y2 = rect->y + rect->height;
-
-  tx1 = (x1 - texture_area->x) / texture_area->width;
-  ty1 = (y1 - texture_area->y) / texture_area->height;
-  tx2 = (x2 - texture_area->x) / texture_area->width;
-  ty2 = (y2 - texture_area->y) / texture_area->height;
-
-  cogl_framebuffer_draw_textured_rectangle (fb, pipeline,
-                                            x1, y1, x2, y2,
-                                            tx1, ty1, tx2, ty2);
-}
-
-static gboolean
-meta_background_actor_get_paint_volume (ClutterActor       *actor,
-                                        ClutterPaintVolume *volume)
-{
-  return clutter_paint_volume_set_from_allocation (volume, actor);
-}
-
-static void
-meta_background_actor_paint (ClutterActor *actor)
-{
-  MetaBackgroundActor *self = META_BACKGROUND_ACTOR (actor);
-  MetaBackgroundActorPrivate *priv = self->priv;
-  ClutterActorBox actor_box;
-  cairo_rectangle_int_t actor_pixel_rect;
-  CoglFramebuffer *fb;
-  int i;
-
-  if ((priv->clip_region && cairo_region_is_empty (priv->clip_region)))
-    return;
-
-  clutter_actor_get_content_box (actor, &actor_box);
-  actor_pixel_rect.x = actor_box.x1;
-  actor_pixel_rect.y = actor_box.y1;
-  actor_pixel_rect.width = actor_box.x2 - actor_box.x1;
-  actor_pixel_rect.height = actor_box.y2 - actor_box.y1;
-
-  setup_pipeline (self, &actor_pixel_rect);
-  set_glsl_parameters (self, &actor_pixel_rect);
-
-  /* Limit to how many separate rectangles we'll draw; beyond this just
-   * fall back and draw the whole thing */
-#define MAX_RECTS 64
-
-  fb = cogl_get_draw_framebuffer ();
-
-  /* Now figure out what to actually paint.
-   */
-  if (priv->clip_region != NULL)
-    {
-      int n_rects = cairo_region_num_rectangles (priv->clip_region);
-      if (n_rects <= MAX_RECTS)
-        {
-           for (i = 0; i < n_rects; i++)
-             {
-               cairo_rectangle_int_t rect;
-               cairo_region_get_rectangle (priv->clip_region, i, &rect);
-
-               if (!gdk_rectangle_intersect (&actor_pixel_rect, &rect, &rect))
-                 continue;
-
-               paint_clipped_rectangle (fb, priv->pipeline, &rect, &priv->texture_area);
-             }
-
-           return;
-        }
-    }
-
-  paint_clipped_rectangle (fb, priv->pipeline, &actor_pixel_rect, &priv->texture_area);
-}
-
-static void
-meta_background_actor_set_property (GObject      *object,
-                                    guint         prop_id,
-                                    const GValue *value,
-                                    GParamSpec   *pspec)
-{
-  MetaBackgroundActor *self = META_BACKGROUND_ACTOR (object);
-  MetaBackgroundActorPrivate *priv = self->priv;
-
-  switch (prop_id)
-    {
-    case PROP_META_SCREEN:
-      priv->screen = g_value_get_object (value);
-      break;
-    case PROP_MONITOR:
-      priv->monitor = g_value_get_int (value);
-      break;
-    case PROP_BACKGROUND:
-      meta_background_actor_set_background (self, g_value_get_object (value));
-      break;
-    case PROP_VIGNETTE:
-      meta_background_actor_set_vignette (self,
-                                          g_value_get_boolean (value),
-                                          priv->brightness,
-                                          priv->vignette_sharpness);
-      break;
-    case PROP_VIGNETTE_SHARPNESS:
-      meta_background_actor_set_vignette (self,
-                                          priv->vignette,
-                                          priv->brightness,
-                                          g_value_get_double (value));
-      break;
-    case PROP_BRIGHTNESS:
-      meta_background_actor_set_vignette (self,
-                                          priv->vignette,
-                                          g_value_get_double (value),
-                                          priv->vignette_sharpness);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
-static void
-meta_background_actor_get_property (GObject      *object,
-                                    guint         prop_id,
-                                    GValue       *value,
-                                    GParamSpec   *pspec)
-{
-  MetaBackgroundActorPrivate *priv = META_BACKGROUND_ACTOR (object)->priv;
-
-  switch (prop_id)
-    {
-    case PROP_META_SCREEN:
-      g_value_set_object (value, priv->screen);
-      break;
-    case PROP_MONITOR:
-      g_value_set_int (value, priv->monitor);
-      break;
-    case PROP_BACKGROUND:
-      g_value_set_object (value, priv->background);
-      break;
-    case PROP_VIGNETTE:
-      g_value_set_boolean (value, priv->vignette);
-      break;
-    case PROP_BRIGHTNESS:
-      g_value_set_double (value, priv->brightness);
-      break;
-    case PROP_VIGNETTE_SHARPNESS:
-      g_value_set_double (value, priv->vignette_sharpness);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
 static void
 meta_background_actor_class_init (MetaBackgroundActorClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
   ClutterActorClass *actor_class = CLUTTER_ACTOR_CLASS (klass);
-  GParamSpec *param_spec;
 
   g_type_class_add_private (klass, sizeof (MetaBackgroundActorPrivate));
 
   object_class->dispose = meta_background_actor_dispose;
-  object_class->set_property = meta_background_actor_set_property;
-  object_class->get_property = meta_background_actor_get_property;
 
   actor_class->get_preferred_width = meta_background_actor_get_preferred_width;
   actor_class->get_preferred_height = meta_background_actor_get_preferred_height;
-  actor_class->get_paint_volume = meta_background_actor_get_paint_volume;
-  actor_class->paint = meta_background_actor_paint;
-
-  param_spec = g_param_spec_object ("meta-screen",
-                                    "MetaScreen",
-                                    "MetaScreen",
-                                    META_TYPE_SCREEN,
-                                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_property (object_class,
-                                   PROP_META_SCREEN,
-                                   param_spec);
-
-  param_spec = g_param_spec_int ("monitor",
-                                 "monitor",
-                                 "monitor",
-                                 0, G_MAXINT, 0,
-                                 G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_property (object_class,
-                                   PROP_MONITOR,
-                                   param_spec);
-
-  param_spec = g_param_spec_object ("background",
-                                    "Background",
-                                    "MetaBackground object holding background parameters",
-                                    META_TYPE_BACKGROUND,
-                                    G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_BACKGROUND,
-                                   param_spec);
-
-  param_spec = g_param_spec_boolean ("vignette",
-                                     "Vignette",
-                                     "Whether vignette effect is enabled",
-                                     FALSE,
-                                     G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_VIGNETTE,
-                                   param_spec);
-
-  param_spec = g_param_spec_double ("brightness",
-                                    "Brightness",
-                                    "Brightness of vignette effect",
-                                    0.0, 1.0, 1.0,
-                                    G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_BRIGHTNESS,
-                                   param_spec);
-
-  param_spec = g_param_spec_double ("vignette-sharpness",
-                                    "Vignette Sharpness",
-                                    "Sharpness of vignette effect",
-                                    0.0, G_MAXDOUBLE, 0.0,
-                                    G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_VIGNETTE_SHARPNESS,
-                                   param_spec);
 }
 
 static void
 meta_background_actor_init (MetaBackgroundActor *self)
 {
-  MetaBackgroundActorPrivate *priv;
-
-  priv = self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
-                                                   META_TYPE_BACKGROUND_ACTOR,
-                                                   MetaBackgroundActorPrivate);
-
-  priv->vignette = FALSE;
-  priv->brightness = 1.0;
-  priv->vignette_sharpness = 0.0;
+  self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
+                                            META_TYPE_BACKGROUND_ACTOR,
+                                            MetaBackgroundActorPrivate);
 }
 
 /**
  * meta_background_actor_new:
- * @monitor: Index of the monitor for which to draw the background
  *
  * Creates a new actor to draw the background for the given monitor.
+ * This actor should be associated with a #MetaBackground using
+ * clutter_actor_set_content()
  *
  * Return value: the newly created background actor
  */
 ClutterActor *
-meta_background_actor_new (MetaScreen *screen,
-                           int         monitor)
+meta_background_actor_new (void)
 {
   MetaBackgroundActor *self;
 
-  self = g_object_new (META_TYPE_BACKGROUND_ACTOR,
-                       "meta-screen", screen,
-                       "monitor", monitor,
-                       NULL);
+  self = g_object_new (META_TYPE_BACKGROUND_ACTOR, NULL);
 
   return CLUTTER_ACTOR (self);
 }
@@ -693,90 +195,3 @@
   MetaBackgroundActorPrivate *priv = self->priv;
   return priv->clip_region;
 }
-
-static void
-invalidate_pipeline (MetaBackgroundActor *self,
-                     ChangedFlags         changed)
-{
-  MetaBackgroundActorPrivate *priv = self->priv;
-
-  priv->changed |= changed;
-}
-
-static void
-on_background_changed (MetaBackground      *background,
-                       MetaBackgroundActor *self)
-{
-  invalidate_pipeline (self, CHANGED_BACKGROUND);
-  clutter_actor_queue_redraw (CLUTTER_ACTOR (self));
-}
-
-void
-meta_background_actor_set_background (MetaBackgroundActor *self,
-                                      MetaBackground      *background)
-{
-  MetaBackgroundActorPrivate *priv;
-
-  g_return_if_fail (META_IS_BACKGROUND_ACTOR (self));
-  g_return_if_fail (background == NULL || META_IS_BACKGROUND (background));
-
-  priv = self->priv;
-
-  if (background == priv->background)
-    return;
-
-  if (priv->background)
-    {
-      g_signal_handlers_disconnect_by_func (priv->background,
-                                            (gpointer)on_background_changed,
-                                            self);
-      g_object_unref (priv->background);
-      priv->background = NULL;
-    }
-
-  if (background)
-    {
-      priv->background = g_object_ref (background);
-      g_signal_connect (priv->background, "changed",
-                        G_CALLBACK (on_background_changed), self);
-    }
-
-  invalidate_pipeline (self, CHANGED_BACKGROUND);
-  clutter_actor_queue_redraw (CLUTTER_ACTOR (self));
-}
-
-void
-meta_background_actor_set_vignette (MetaBackgroundActor *self,
-                                    gboolean             enabled,
-                                    double               brightness,
-                                    double               sharpness)
-{
-  MetaBackgroundActorPrivate *priv;
-  gboolean changed = FALSE;
-
-  g_return_if_fail (META_IS_BACKGROUND_ACTOR (self));
-  g_return_if_fail (brightness >= 0. && brightness <= 1.);
-  g_return_if_fail (sharpness >= 0.);
-
-  priv = self->priv;
-
-  enabled = enabled != FALSE;
-
-  if (enabled != priv->vignette)
-    {
-      priv->vignette = enabled;
-      invalidate_pipeline (self, CHANGED_EFFECTS);
-      changed = TRUE;
-    }
-
-  if (brightness != priv->brightness || sharpness != priv->vignette_sharpness)
-    {
-      priv->brightness = brightness;
-      priv->vignette_sharpness = sharpness;
-      invalidate_pipeline (self, CHANGED_VIGNETTE_PARAMETERS);
-      changed = TRUE;
-    }
-
-  if (changed)
-    clutter_actor_queue_redraw (CLUTTER_ACTOR (self));
-}
diff '--exclude=.git' -urN a/src/compositor/meta-background-image.c b/src/compositor/meta-background-image.c
--- a/src/compositor/meta-background-image.c	2015-06-13 23:59:51.983809000 -0400
+++ b/src/compositor/meta-background-image.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,357 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-/*
- * Copyright 2014 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-/**
- * SECTION:meta-background-image
- * @title: MetaBackgroundImage
- * @short_description: objects holding images loaded from files, used for backgrounds
- */
-
-#include <config.h>
-
-#include <gio/gio.h>
-#include <gdk-pixbuf/gdk-pixbuf.h>
-#include <clutter/clutter.h>
-#include <meta/meta-background-image.h>
-#include "cogl-utils.h"
-
-enum
-{
-  LOADED,
-  LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-struct _MetaBackgroundImageCache
-{
-  GObject parent_instance;
-
-  GHashTable *images;
-};
-
-struct _MetaBackgroundImageCacheClass
-{
-  GObjectClass parent_class;
-};
-
-struct _MetaBackgroundImage
-{
-  GObject parent_instance;
-  GFile *file;
-  MetaBackgroundImageCache *cache;
-  gboolean in_cache;
-  gboolean loaded;
-  CoglTexture *texture;
-};
-
-struct _MetaBackgroundImageClass
-{
-  GObjectClass parent_class;
-};
-
-G_DEFINE_TYPE (MetaBackgroundImageCache, meta_background_image_cache, G_TYPE_OBJECT);
-
-static void
-meta_background_image_cache_init (MetaBackgroundImageCache *cache)
-{
-  cache->images = g_hash_table_new (g_file_hash, (GEqualFunc) g_file_equal);
-}
-
-static void
-meta_background_image_cache_finalize (GObject *object)
-{
-  MetaBackgroundImageCache *cache = META_BACKGROUND_IMAGE_CACHE (object);
-  GHashTableIter iter;
-  gpointer key, value;
-
-  g_hash_table_iter_init (&iter, cache->images);
-  while (g_hash_table_iter_next (&iter, &key, &value))
-    {
-      MetaBackgroundImage *image = value;
-      image->in_cache = FALSE;
-    }
-
-  g_hash_table_destroy (cache->images);
-
-  G_OBJECT_CLASS (meta_background_image_cache_parent_class)->finalize (object);
-}
-
-static void
-meta_background_image_cache_class_init (MetaBackgroundImageCacheClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = meta_background_image_cache_finalize;
-}
-
-/**
- * meta_background_image_cache_get_default:
- *
- * Return value: (transfer none): the global singleton background cache
- */
-MetaBackgroundImageCache *
-meta_background_image_cache_get_default (void)
-{
-  static MetaBackgroundImageCache *cache;
-
-  if (cache == NULL)
-    cache = g_object_new (META_TYPE_BACKGROUND_IMAGE_CACHE, NULL);
-
-  return cache;
-}
-
-static void
-load_file (GTask               *task,
-           MetaBackgroundImage *image,
-           gpointer             task_data,
-           GCancellable        *cancellable)
-{
-  GError *error = NULL;
-  GdkPixbuf *pixbuf;
-  GFileInputStream *stream;
-
-  stream = g_file_read (image->file, NULL, &error);
-  if (stream == NULL)
-    {
-      g_task_return_error (task, error);
-      return;
-    }
-
-  pixbuf = gdk_pixbuf_new_from_stream (G_INPUT_STREAM (stream), NULL, &error);
-  g_object_unref (stream);
-
-  if (pixbuf == NULL)
-    {
-      g_task_return_error (task, error);
-      return;
-    }
-
-  g_task_return_pointer (task, pixbuf, (GDestroyNotify) g_object_unref);
-}
-
-static void
-file_loaded (GObject      *source_object,
-             GAsyncResult *result,
-             gpointer      user_data)
-{
-  MetaBackgroundImage *image = META_BACKGROUND_IMAGE (source_object);
-  GError *error = NULL;
-  GTask *task;
-  CoglTexture *texture;
-  GdkPixbuf *pixbuf;
-  int width, height, row_stride;
-  guchar *pixels;
-  gboolean has_alpha;
-
-  task = G_TASK (result);
-  pixbuf = g_task_propagate_pointer (task, &error);
-
-  if (pixbuf == NULL)
-    {
-      char *uri = g_file_get_uri (image->file);
-      g_warning ("Failed to load background '%s': %s",
-                 uri, error->message);
-      g_clear_error (&error);
-      g_free (uri);
-      goto out;
-    }
-
-  width = gdk_pixbuf_get_width (pixbuf);
-  height = gdk_pixbuf_get_height (pixbuf);
-  row_stride = gdk_pixbuf_get_rowstride (pixbuf);
-  pixels = gdk_pixbuf_get_pixels (pixbuf);
-  has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
-
-  texture = meta_create_texture (width, height,
-                                 has_alpha ? COGL_TEXTURE_COMPONENTS_RGBA : COGL_TEXTURE_COMPONENTS_RGB,
-                                 META_TEXTURE_ALLOW_SLICING);
-
-  if (!cogl_texture_set_data (texture,
-                              has_alpha ? COGL_PIXEL_FORMAT_RGBA_8888 : COGL_PIXEL_FORMAT_RGB_888,
-                              row_stride,
-                              pixels, 0,
-                              NULL))
-    {
-      g_warning ("Failed to create texture for background");
-      cogl_object_unref (texture);
-    }
-
-  image->texture = texture;
-
-out:
-  if (pixbuf != NULL)
-    g_object_unref (pixbuf);
-
-  image->loaded = TRUE;
-  g_signal_emit (image, signals[LOADED], 0);
-}
-
-/**
- * meta_background_image_cache_load:
- * @cache: a #MetaBackgroundImageCache
- * @file: #GFile to load
- *
- * Loads an image to use as a background, or returns a reference to an
- * image that is already in the process of loading or loaded. In either
- * case, what is returned is a #MetaBackgroundImage which can be derefenced
- * to get a #CoglTexture. If meta_background_image_is_loaded() returns %TRUE,
- * the background is loaded, otherwise the MetaBackgroundImage::loaded
- * signal will be emitted exactly once. The 'loaded' state means that the
- * loading process finished, whether it succeeded or failed.
- *
- * Return value: (transfer full): a #MetaBackgroundImage to dereference to get the loaded texture
- */
-MetaBackgroundImage *
-meta_background_image_cache_load (MetaBackgroundImageCache *cache,
-                                  GFile                    *file)
-{
-  MetaBackgroundImage *image;
-  GTask *task;
-
-  g_return_val_if_fail (META_IS_BACKGROUND_IMAGE_CACHE (cache), NULL);
-  g_return_val_if_fail (file != NULL, NULL);
-
-  image = g_hash_table_lookup (cache->images, file);
-  if (image != NULL)
-    return g_object_ref (image);
-
-  image = g_object_new (META_TYPE_BACKGROUND_IMAGE, NULL);
-  image->cache = cache;
-  image->in_cache = TRUE;
-  image->file = g_object_ref (file);
-  g_hash_table_insert (cache->images, image->file, image);
-
-  task = g_task_new (image, NULL, file_loaded, NULL);
-
-  g_task_run_in_thread (task, (GTaskThreadFunc) load_file);
-  g_object_unref (task);
-
-  return image;
-}
-
-/**
- * meta_background_image_cache_purge:
- * @cache: a #MetaBackgroundImageCache
- * @file: file to remove from the cache
- *
- * Remove an entry from the cache; this would be used if monitoring
- * showed that the file changed.
- */
-void
-meta_background_image_cache_purge (MetaBackgroundImageCache *cache,
-                                   GFile                    *file)
-{
-  MetaBackgroundImage *image;
-
-  g_return_if_fail (META_IS_BACKGROUND_IMAGE_CACHE (cache));
-  g_return_if_fail (file != NULL);
-
-  image = g_hash_table_lookup (cache->images, file);
-  if (image == NULL)
-    return;
-
-  g_hash_table_remove (cache->images, image->file);
-  image->in_cache = FALSE;
-}
-
-G_DEFINE_TYPE (MetaBackgroundImage, meta_background_image, G_TYPE_OBJECT);
-
-static void
-meta_background_image_init (MetaBackgroundImage *image)
-{
-}
-
-static void
-meta_background_image_finalize (GObject *object)
-{
-  MetaBackgroundImage *image = META_BACKGROUND_IMAGE (object);
-
-  if (image->in_cache)
-    g_hash_table_remove (image->cache->images, image->file);
-
-  if (image->texture)
-    cogl_object_unref (image->texture);
-  if (image->file)
-    g_object_unref (image->file);
-
-  G_OBJECT_CLASS (meta_background_image_parent_class)->finalize (object);
-}
-
-static void
-meta_background_image_class_init (MetaBackgroundImageClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = meta_background_image_finalize;
-
-  signals[LOADED] =
-    g_signal_new ("loaded",
-                  G_TYPE_FROM_CLASS (object_class),
-                  G_SIGNAL_RUN_LAST,
-                  0,
-                  NULL, NULL, NULL,
-                  G_TYPE_NONE, 0);
-}
-
-/**
- * meta_background_image_is_loaded:
- * @image: a #MetaBackgroundImage
- *
- * Return value: %TRUE if loading has already completed, %FALSE otherwise
- */
-gboolean
-meta_background_image_is_loaded (MetaBackgroundImage *image)
-{
-  g_return_val_if_fail (META_IS_BACKGROUND_IMAGE (image), FALSE);
-
-  return image->loaded;
-}
-
-/**
- * meta_background_image_get_success:
- * @image: a #MetaBackgroundImage
- *
- * This function is a convenience function for checking for success,
- * without having to call meta_background_image_get_texture() and
- * handle the return of a Cogl type.
- *
- * Return value: %TRUE if loading completed successfully, otherwise %FALSE
- */
-gboolean
-meta_background_image_get_success (MetaBackgroundImage *image)
-{
-  g_return_val_if_fail (META_IS_BACKGROUND_IMAGE (image), FALSE);
-
-  return image->texture != NULL;
-}
-
-/**
- * meta_background_image_get_texture:
- * @image: a #MetaBackgroundImage
- *
- * Return value: (transfer none): a #CoglTexture if loading succeeded; if
- *  loading failed or has not yet finished, %NULL.
- */
-CoglTexture *
-meta_background_image_get_texture (MetaBackgroundImage *image)
-{
-  g_return_val_if_fail (META_IS_BACKGROUND_IMAGE (image), NULL);
-
-  return image->texture;
-}
diff '--exclude=.git' -urN a/src/compositor/meta-background-private.h b/src/compositor/meta-background-private.h
--- a/src/compositor/meta-background-private.h	2015-06-13 23:59:51.983809000 -0400
+++ b/src/compositor/meta-background-private.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,15 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-
-#ifndef META_BACKGROUND_PRIVATE_H
-#define META_BACKGROUND_PRIVATE_H
-
-#include <config.h>
-
-#include "meta-background-private.h"
-
-CoglTexture *meta_background_get_texture (MetaBackground         *self,
-                                          int                     monitor_index,
-                                          cairo_rectangle_int_t  *texture_area,
-                                          CoglPipelineWrapMode   *wrap_mode);
-
-#endif /* META_BACKGROUND_PRIVATE_H */
diff '--exclude=.git' -urN a/src/compositor/meta-background.c b/src/compositor/meta-background.c
--- a/src/compositor/meta-background.c	2015-10-30 16:39:40.964006704 -0400
+++ b/src/compositor/meta-background.c	2015-10-31 11:13:25.289109093 -0400
@@ -17,306 +17,680 @@
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <meta/meta-background.h>
-#include <meta/meta-background-image.h>
-#include "meta-background-private.h"
-#include "cogl-utils.h"
+/**
+ * SECTION:meta-background
+ * @title: MetaBackground
+ * @short_description: ClutterContent for painting the system background
+ *
+ */
 
-enum
-{
-  CHANGED,
-  LAST_SIGNAL
-};
+#include <config.h>
 
-static guint signals[LAST_SIGNAL] = { 0 };
+#include <clutter/clutter.h>
 
-typedef struct _MetaBackgroundMonitor MetaBackgroundMonitor;
+#include "cogl-utils.h"
+#include "compositor-private.h"
+#include "mutter-enum-types.h"
+#include <meta/errors.h>
+#include <meta/meta-background.h>
+#include "util-private.h"
+#include "meta-background-actor-private.h"
 
-struct _MetaBackgroundMonitor
-{
-  gboolean dirty;
-  CoglTexture *texture;
-  CoglOffscreen *fbo;
-};
+#define FRAGMENT_SHADER_DECLARATIONS                                           \
+"uniform vec2 texture_scale;\n"                                                \
+"uniform vec2 actor_size;\n"                                                   \
+"uniform vec2 offset;\n"                                                       \
+"uniform float brightness;\n"                                                  \
+"uniform float vignette_sharpness;\n"                                          \
+
+#define VIGNETTE_CODE                                                          \
+"vec2 position = cogl_tex_coord_in[0].xy * texture_scale - offset;\n"          \
+"float t = length(2.0 * (position / actor_size));\n"                           \
+"t = clamp(t, 0.0, 1.0);\n"                                                    \
+"float pixel_brightness = mix(1.0, 1.0 - vignette_sharpness, t);\n"            \
+"cogl_color_out.rgb = cogl_color_out.rgb * pixel_brightness * brightness;\n"
+
+/* We allow creating multiple MetaBackgrounds for the same monitor to
+ * allow different rendering options to be set for different copies.
+ * But we want to share the same underlying CoglTextures for efficiency and
+ * to avoid driver bugs that might occur if we created multiple CoglTexturePixmaps
+ * for the same pixmap.
+ *
+ * This object provides a ClutterContent object to assist in sharing between actors.
+ */
 
 struct _MetaBackgroundPrivate
 {
-  MetaScreen *screen;
-  MetaBackgroundMonitor *monitors;
-  int n_monitors;
+  MetaScreen   *screen;
+  CoglTexture  *texture;
+  CoglPipeline *pipeline;
+  int           monitor;
+
+  MetaBackgroundEffects effects;
 
   GDesktopBackgroundStyle   style;
   GDesktopBackgroundShading shading_direction;
   ClutterColor              color;
   ClutterColor              second_color;
 
-  GFile *file1;
-  MetaBackgroundImage *background_image1;
-  GFile *file2;
-  MetaBackgroundImage *background_image2;
+  char  *filename;
 
-  CoglTexture *color_texture;
-  CoglTexture *wallpaper_texture;
-
-  float blend_factor;
-
-  guint wallpaper_allocation_failed : 1;
+  float brightness;
+  float vignette_sharpness;
 };
 
 enum
 {
   PROP_META_SCREEN = 1,
   PROP_MONITOR,
+  PROP_EFFECTS,
+  PROP_BRIGHTNESS,
+  PROP_VIGNETTE_SHARPNESS,
 };
 
-G_DEFINE_TYPE (MetaBackground, meta_background, G_TYPE_OBJECT)
+static void clutter_content_iface_init (ClutterContentIface *iface);
+static void unset_texture (MetaBackground *self);
+
+G_DEFINE_TYPE_WITH_CODE (MetaBackground, meta_background, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (CLUTTER_TYPE_CONTENT,
+                                                clutter_content_iface_init))
+
+static gboolean
+meta_background_get_preferred_size (ClutterContent *content,
+                                    gfloat         *width,
+                                    gfloat         *height)
+{
+  MetaBackgroundPrivate *priv = META_BACKGROUND (content)->priv;
+  MetaRectangle monitor_geometry;
+
+  if (priv->texture == NULL)
+    return FALSE;
+
+  meta_screen_get_monitor_geometry (priv->screen, priv->monitor, &monitor_geometry);
 
-static GSList *all_backgrounds = NULL;
+  if (width != NULL)
+    *width = monitor_geometry.width;
+
+  if (height != NULL)
+    *height = monitor_geometry.height;
+
+  return TRUE;
+}
 
 static void
-free_fbos (MetaBackground *self)
+get_texture_area_and_scale (MetaBackground        *self,
+                            ClutterActorBox       *actor_box,
+                            cairo_rectangle_int_t *texture_area,
+                            float                 *texture_x_scale,
+                            float                 *texture_y_scale)
 {
   MetaBackgroundPrivate *priv = self->priv;
+  MetaRectangle monitor_geometry;
+  cairo_rectangle_int_t actor_pixel_rect;
+  cairo_rectangle_int_t image_area;
+  int screen_width, screen_height;
+  float texture_width, texture_height;
+  float actor_x_scale, actor_y_scale;
+  float monitor_x_scale, monitor_y_scale;
+  float x_offset, y_offset;
 
-  int i;
+  meta_screen_get_monitor_geometry (priv->screen, priv->monitor, &monitor_geometry);
 
-  for (i = 0; i < priv->n_monitors; i++)
+  actor_pixel_rect.x = actor_box->x1;
+  actor_pixel_rect.y = actor_box->y1;
+  actor_pixel_rect.width = actor_box->x2 - actor_box->x1;
+  actor_pixel_rect.height = actor_box->y2 - actor_box->y1;
+
+  texture_width = cogl_texture_get_width (priv->texture);
+  actor_x_scale = (1.0 * actor_pixel_rect.width / monitor_geometry.width);
+
+  texture_height = cogl_texture_get_height (priv->texture);
+  actor_y_scale = (1.0 * actor_pixel_rect.height / monitor_geometry.height);
+
+  switch (priv->style)
     {
-      MetaBackgroundMonitor *monitor = &priv->monitors[i];
-      if (monitor->fbo)
-        {
-          cogl_object_unref (monitor->fbo);
-          monitor->fbo = NULL;
-        }
-      if (monitor->texture)
+      case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
+      default:
+          /* paint region is whole actor, and the texture
+           * is scaled disproportionately to fit the actor
+           */
+          *texture_area = actor_pixel_rect;
+          *texture_x_scale = 1.0 / actor_pixel_rect.width;
+          *texture_y_scale = 1.0 / actor_pixel_rect.height;
+          break;
+      case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
+          /* The wallpaper should be centered in the middle of all monitors.
+           * Therefore, the textured area is the union of all monitors plus
+           * an additional bit to make up for the texture getting centered.  */
+          meta_screen_get_size (priv->screen, &screen_width, &screen_height);
+
+          /* so start by making the unclipped texture area the whole screen */
+          image_area.width = screen_width;
+          image_area.height = screen_height;
+
+          /* If one of the tiles is already centered in the screen, then that tile
+           * will start tile_size/2.0 before the center of the screen. So find out
+           * how far we are from that ideal and adjust by that offset.
+           */
+          x_offset = texture_width - ((int) ((screen_width / 2.0) - (texture_width / 2.0))) % ((int) texture_width);
+          y_offset = texture_height - ((int) ((screen_height / 2.0) - (texture_height / 2.0))) % ((int) texture_height);
+
+          image_area.width += x_offset;
+          image_area.height += y_offset;
+          image_area.x = -x_offset;
+          image_area.y = -y_offset;
+
+          /* now line up with the appropriate monitor */
+          image_area.x -= monitor_geometry.x;
+          image_area.y -= monitor_geometry.y;
+
+          /* and scale to actor */
+          image_area.x *= actor_x_scale;
+          image_area.y *= actor_y_scale;
+          image_area.width *= actor_x_scale;
+          image_area.height *= actor_y_scale;
+
+          *texture_area = image_area;
+          *texture_x_scale = 1.0 / texture_width;
+          *texture_y_scale = 1.0 / texture_height;
+          break;
+      case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
+          /* paint region is the original image size centered in the actor,
+           * and the texture is scaled to the original image size */
+          image_area.width = texture_width;
+          image_area.height = texture_height;
+          image_area.x = actor_pixel_rect.x + actor_pixel_rect.width / 2 - image_area.width / 2;
+          image_area.y = actor_pixel_rect.y + actor_pixel_rect.height / 2 - image_area.height / 2;
+
+          *texture_area = image_area;
+          *texture_x_scale = 1.0 / texture_width;
+          *texture_y_scale = 1.0 / texture_height;
+          break;
+      case G_DESKTOP_BACKGROUND_STYLE_SCALED:
+      case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
+          /* paint region is the actor size in one dimension, and centered and
+           * scaled by proportional amount in the other dimension.
+           *
+           * SCALED forces the centered dimension to fit on screen.
+           * ZOOM forces the centered dimension to grow off screen
+           */
+          monitor_x_scale = monitor_geometry.width / texture_width;
+          monitor_y_scale = monitor_geometry.height / texture_height;
+
+          if ((priv->style == G_DESKTOP_BACKGROUND_STYLE_SCALED &&
+                (monitor_x_scale < monitor_y_scale)) ||
+              (priv->style == G_DESKTOP_BACKGROUND_STYLE_ZOOM &&
+                (monitor_x_scale > monitor_y_scale)))
+            {
+              /* Fill image to exactly fit actor horizontally */
+              image_area.width = actor_pixel_rect.width;
+              image_area.height = texture_height * monitor_x_scale * actor_y_scale;
+
+              /* Position image centered vertically in actor */
+              image_area.x = actor_pixel_rect.x;
+              image_area.y = actor_pixel_rect.y + actor_pixel_rect.height / 2 - image_area.height / 2;
+            }
+          else
+            {
+              /* Scale image to exactly fit actor vertically */
+              image_area.width = texture_width * monitor_y_scale * actor_x_scale;
+              image_area.height = actor_pixel_rect.height;
+
+              /* Position image centered horizontally in actor */
+              image_area.x = actor_pixel_rect.x + actor_pixel_rect.width / 2 - image_area.width / 2;
+              image_area.y = actor_pixel_rect.y;
+            }
+
+          *texture_area = image_area;
+          *texture_x_scale = 1.0 / image_area.width;
+          *texture_y_scale = 1.0 / image_area.height;
+          break;
+
+      case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
         {
-          cogl_object_unref (monitor->texture);
-          monitor->texture = NULL;
+          /* paint region is the union of all monitors, with the origin
+           * of the region set to align with monitor associated with the background.
+           */
+          meta_screen_get_size (priv->screen, &screen_width, &screen_height);
+
+          /* unclipped texture area is whole screen */
+          image_area.width = screen_width * actor_x_scale;
+          image_area.height = screen_height * actor_y_scale;
+
+          /* But make (0,0) line up with the appropriate monitor */
+          image_area.x = -monitor_geometry.x * actor_x_scale;
+          image_area.y = -monitor_geometry.y * actor_y_scale;
+
+          *texture_area = image_area;
+          *texture_x_scale = 1.0 / image_area.width;
+          *texture_y_scale = 1.0 / image_area.height;
+          break;
         }
     }
 }
 
-static void
-free_color_texture (MetaBackground *self)
+static CoglPipelineWrapMode
+get_wrap_mode (MetaBackground *self)
 {
   MetaBackgroundPrivate *priv = self->priv;
-
-  if (priv->color_texture != NULL)
+  switch (priv->style)
     {
-      cogl_object_unref (priv->color_texture);
-      priv->color_texture = NULL;
+      case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
+          return COGL_PIPELINE_WRAP_MODE_REPEAT;
+      case G_DESKTOP_BACKGROUND_STYLE_NONE:
+      case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
+      case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
+      case G_DESKTOP_BACKGROUND_STYLE_SCALED:
+      case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
+      case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
+      default:
+          return COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
     }
 }
 
-static void
-free_wallpaper_texture (MetaBackground *self)
+static gboolean
+texture_has_alpha (CoglTexture *texture)
 {
-  MetaBackgroundPrivate *priv = self->priv;
+  if (!texture)
+    return FALSE;
 
-  if (priv->wallpaper_texture != NULL)
+  switch (cogl_texture_get_components (texture))
     {
-      cogl_object_unref (priv->wallpaper_texture);
-      priv->wallpaper_texture = NULL;
+    case COGL_TEXTURE_COMPONENTS_A:
+    case COGL_TEXTURE_COMPONENTS_RGBA:
+      return TRUE;
+    case COGL_TEXTURE_COMPONENTS_RG:
+    case COGL_TEXTURE_COMPONENTS_RGB:
+    case COGL_TEXTURE_COMPONENTS_DEPTH:
+      return FALSE;
+    default:
+      g_assert_not_reached ();
     }
-
-  priv->wallpaper_allocation_failed = FALSE;
 }
 
-static void
-on_monitors_changed (MetaScreen     *screen,
-                     MetaBackground *self)
+static ClutterPaintNode *
+meta_background_paint_node_new (MetaBackground *self,
+                                ClutterActor   *actor)
 {
   MetaBackgroundPrivate *priv = self->priv;
+  ClutterPaintNode *node;
+  guint8 opacity;
+  guint8 color_component;
+  gboolean needs_blending;
+
+  opacity = clutter_actor_get_paint_opacity (actor);
+  color_component = (guint8) (0.5 + opacity * priv->brightness);
+
+  cogl_pipeline_set_color4ub (priv->pipeline,
+                              color_component,
+                              color_component,
+                              color_component,
+                              opacity);
+
+  node = clutter_pipeline_node_new (priv->pipeline);
+
+  needs_blending = (opacity < 255) || (texture_has_alpha (priv->texture));
+
+  if (needs_blending)
+    cogl_pipeline_set_blend (priv->pipeline, "RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))", NULL);
+  else
+    cogl_pipeline_set_blend (priv->pipeline, "RGBA = ADD (SRC_COLOR, 0)", NULL);
 
-  free_fbos (self);
-  g_free (priv->monitors);
-  priv->monitors = NULL;
-  priv->n_monitors = 0;
+  return node;
+}
 
-  if (priv->screen)
-    {
-      int i;
+static void
+clip_region_to_actor_box (cairo_region_t  *region,
+                          ClutterActorBox *actor_box)
+{
+  cairo_rectangle_int_t clip_rect;
 
-      priv->n_monitors = meta_screen_get_n_monitors (screen);
-      priv->monitors = g_new0 (MetaBackgroundMonitor, priv->n_monitors);
+  clip_rect.x = actor_box->x1;
+  clip_rect.y = actor_box->y1;
+  clip_rect.width = actor_box->x2 - actor_box->x1;
+  clip_rect.height = actor_box->y2 - actor_box->y1;
 
-      for (i = 0; i < priv->n_monitors; i++)
-        priv->monitors[i].dirty = TRUE;
-    }
+  cairo_region_intersect_rectangle (region, &clip_rect);
 }
 
 static void
-set_screen (MetaBackground *self,
-            MetaScreen     *screen)
+set_vignette_parameters (MetaBackground        *self,
+                         ClutterActorBox       *actor_box,
+                         cairo_rectangle_int_t *texture_area,
+                         float                  texture_x_scale,
+                         float                  texture_y_scale)
 {
   MetaBackgroundPrivate *priv = self->priv;
+  float                  texture_scale[2];
+  float                  actor_size[2];
+  float                  offset[2];
+
+  if (!(priv->effects & META_BACKGROUND_EFFECTS_VIGNETTE))
+    return;
+
+  texture_scale[0] = 1.0 / texture_x_scale;
+  texture_scale[1] = 1.0 / texture_y_scale;
+  actor_size[0] = actor_box->x2 - actor_box->x1;
+  actor_size[1] = actor_box->y2 - actor_box->y1;
+  offset[0] = -texture_area->x + (actor_size[0] / 2.0);
+  offset[1] = -texture_area->y + (actor_size[1] / 2.0);
+
+  cogl_pipeline_set_uniform_float (priv->pipeline,
+                                   cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                       "texture_scale"),
+                                   2, 1, texture_scale);
+
+  cogl_pipeline_set_uniform_float (priv->pipeline,
+                                   cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                       "actor_size"),
+                                   2, 1, actor_size);
+
+  cogl_pipeline_set_uniform_float (priv->pipeline,
+                                   cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                       "offset"),
+                                   2, 1, offset);
+}
 
-  if (priv->screen != NULL)
+static void
+meta_background_paint_content (ClutterContent   *content,
+                               ClutterActor     *actor,
+                               ClutterPaintNode *root)
+{
+  MetaBackground *self = META_BACKGROUND (content);
+  MetaBackgroundPrivate *priv = self->priv;
+  ClutterPaintNode *node;
+  ClutterActorBox actor_box;
+  cairo_rectangle_int_t texture_area;
+  cairo_region_t *paintable_region = NULL;
+  int n_texture_subareas;
+  int i;
+  float texture_x_scale, texture_y_scale;
+  float tx1 = 0.0, ty1 = 0.0, tx2 = 1.0, ty2 = 1.0;
+
+  if (priv->texture == NULL)
+    return;
+
+  clutter_actor_get_content_box (actor, &actor_box);
+
+  /* First figure out where on the monitor the texture is supposed to be painted.
+   * If the actor is not the size of the monitor, this function makes sure to scale
+   * everything down to fit in the actor.
+   */
+  get_texture_area_and_scale (self,
+                              &actor_box,
+                              &texture_area,
+                              &texture_x_scale,
+                              &texture_y_scale);
+
+  set_vignette_parameters (self, &actor_box, &texture_area, texture_x_scale, texture_y_scale);
+
+  /* Now figure out what to actually paint. We start by clipping the texture area to
+   * the actor's bounds.
+   */
+  paintable_region = cairo_region_create_rectangle (&texture_area);
+
+  clip_region_to_actor_box (paintable_region, &actor_box);
+
+  /* And then cut out any parts occluded by window actors
+   */
+  if (META_IS_BACKGROUND_ACTOR (actor))
     {
-      g_signal_handlers_disconnect_by_func (priv->screen,
-                                            (gpointer)on_monitors_changed,
-                                            self);
+      cairo_region_t *clip_region;
+      clip_region = meta_background_actor_get_clip_region (META_BACKGROUND_ACTOR (actor));
+
+      if (clip_region != NULL)
+        cairo_region_intersect (paintable_region, clip_region);
     }
 
-  priv->screen = screen;
+  if (cairo_region_is_empty (paintable_region))
+    goto out;
+
+  node = meta_background_paint_node_new (self, actor);
 
-  if (priv->screen != NULL)
+  /* Finally, split the paintable region up into distinct areas
+   * and paint each area one by one
+   */
+  n_texture_subareas = cairo_region_num_rectangles (paintable_region);
+  for (i = 0; i < n_texture_subareas; i++)
     {
-      g_signal_connect (priv->screen, "monitors-changed",
-                        G_CALLBACK (on_monitors_changed), self);
+      cairo_rectangle_int_t texture_subarea;
+      ClutterActorBox texture_rectangle;
+
+      cairo_region_get_rectangle (paintable_region, i, &texture_subarea);
+
+      tx1 = (texture_subarea.x - texture_area.x) * texture_x_scale;
+      ty1 = (texture_subarea.y - texture_area.y) * texture_y_scale;
+      tx2 = (texture_subarea.x + texture_subarea.width - texture_area.x) * texture_x_scale;
+      ty2 = (texture_subarea.y + texture_subarea.height - texture_area.y) * texture_y_scale;
+      texture_rectangle.x1 = texture_subarea.x;
+      texture_rectangle.y1 = texture_subarea.y;
+      texture_rectangle.x2 = texture_subarea.x + texture_subarea.width;
+      texture_rectangle.y2 = texture_subarea.y + texture_subarea.height;
+
+      clutter_paint_node_add_texture_rectangle (node, &texture_rectangle, tx1, ty1, tx2, ty2);
     }
+  clutter_paint_node_add_child (root, node);
+  clutter_paint_node_unref (node);
 
-  on_monitors_changed (priv->screen, self);
+ out:
+  cairo_region_destroy (paintable_region);
 }
 
 static void
-meta_background_set_property (GObject      *object,
-                              guint         prop_id,
-                              const GValue *value,
-                              GParamSpec   *pspec)
+clutter_content_iface_init (ClutterContentIface *iface)
 {
-  switch (prop_id)
-    {
-    case PROP_META_SCREEN:
-      set_screen (META_BACKGROUND (object), g_value_get_object (value));
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
+  iface->get_preferred_size = meta_background_get_preferred_size;
+  iface->paint_content = meta_background_paint_content;
 }
 
 static void
-meta_background_get_property (GObject      *object,
-                              guint         prop_id,
-                              GValue       *value,
-                              GParamSpec   *pspec)
+meta_background_dispose (GObject *object)
 {
-  MetaBackgroundPrivate *priv = META_BACKGROUND (object)->priv;
+  MetaBackground        *self = META_BACKGROUND (object);
+  MetaBackgroundPrivate *priv = self->priv;
 
-  switch (prop_id)
-    {
-    case PROP_META_SCREEN:
-      g_value_set_object (value, priv->screen);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
+  unset_texture (self);
+
+  g_clear_pointer (&priv->pipeline,
+                   (GDestroyNotify)
+                   cogl_object_unref);
+
+  G_OBJECT_CLASS (meta_background_parent_class)->dispose (object);
 }
 
-static gboolean
-need_prerender (MetaBackground *self)
+static void
+meta_background_finalize (GObject *object)
 {
+  MetaBackground        *self = META_BACKGROUND (object);
   MetaBackgroundPrivate *priv = self->priv;
-  CoglTexture *texture1 = priv->background_image1 ? meta_background_image_get_texture (priv->background_image1) : NULL;
-  CoglTexture *texture2 = priv->background_image2 ? meta_background_image_get_texture (priv->background_image2) : NULL;
 
-  if (texture1 == NULL && texture2 == NULL)
-    return FALSE;
+  g_free (priv->filename);
 
-  if (texture2 == NULL && priv->style == G_DESKTOP_BACKGROUND_STYLE_WALLPAPER)
-    return FALSE;
+  G_OBJECT_CLASS (meta_background_parent_class)->finalize (object);
+}
 
-  return TRUE;
+static void
+ensure_pipeline (MetaBackground *self)
+{
+  if (self->priv->pipeline == NULL)
+    self->priv->pipeline = COGL_PIPELINE (meta_create_texture_pipeline (NULL));
 }
 
 static void
-mark_changed (MetaBackground *self)
+set_brightness (MetaBackground *self,
+                gfloat          brightness)
 {
   MetaBackgroundPrivate *priv = self->priv;
-  int i;
 
-  if (!need_prerender (self))
-    free_fbos (self);
+  if (priv->brightness == brightness)
+    return;
+
+  priv->brightness = brightness;
 
-  for (i = 0; i < priv->n_monitors; i++)
-    priv->monitors[i].dirty = TRUE;
+  if (clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL) &&
+      priv->effects & META_BACKGROUND_EFFECTS_VIGNETTE)
+    {
+      ensure_pipeline (self);
+      cogl_pipeline_set_uniform_1f (priv->pipeline,
+                                    cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                        "brightness"),
+                                    priv->brightness);
+    }
+  else
+    {
+      ensure_pipeline (self);
+      CoglColor blend_color;
+      cogl_color_init_from_4f (&blend_color, brightness, brightness, brightness, 1.0);
+      cogl_pipeline_set_layer_combine (priv->pipeline, 1, "RGB=MODULATE(PREVIOUS, CONSTANT) A=REPLACE(PREVIOUS)", NULL);
+      cogl_pipeline_set_layer_combine_constant (priv->pipeline, 1, &blend_color);
+    }
+
+  clutter_content_invalidate (CLUTTER_CONTENT (self));
 
-  g_signal_emit (self, signals[CHANGED], 0);
+  g_object_notify (G_OBJECT (self), "brightness");
 }
 
 static void
-on_background_loaded (MetaBackgroundImage *image,
-                      MetaBackground      *self)
+set_vignette_sharpness (MetaBackground *self,
+                        gfloat          sharpness)
 {
-  mark_changed (self);
-}
+  MetaBackgroundPrivate *priv = self->priv;
 
-static gboolean
-file_equal0 (GFile *file1,
-             GFile *file2)
-{
-  if (file1 == file2)
-    return TRUE;
+  if (priv->vignette_sharpness == sharpness)
+    return;
 
-  if ((file1 == NULL) || (file2 == NULL))
-    return FALSE;
+  priv->vignette_sharpness = sharpness;
+
+  if (!clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL))
+    return;
+
+  if (priv->effects & META_BACKGROUND_EFFECTS_VIGNETTE)
+    {
+      ensure_pipeline (self);
+      cogl_pipeline_set_uniform_1f (priv->pipeline,
+                                    cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                        "vignette_sharpness"),
+                                    priv->vignette_sharpness);
+    }
+
+  clutter_content_invalidate (CLUTTER_CONTENT (self));
 
-  return g_file_equal (file1, file2);
+  g_object_notify (G_OBJECT (self), "vignette-sharpness");
 }
 
 static void
-set_file (MetaBackground       *self,
-          GFile               **filep,
-          MetaBackgroundImage **imagep,
-          GFile                *file)
+add_vignette (MetaBackground *self)
 {
-  if (!file_equal0 (*filep, file))
-    {
-      g_clear_object (filep);
+  MetaBackgroundPrivate *priv = self->priv;
+  static CoglSnippet *snippet = NULL;
 
-      if (*imagep)
-        {
-          g_signal_handlers_disconnect_by_func (*imagep,
-                                                (gpointer)on_background_loaded,
-                                                self);
-          g_object_unref (*imagep);
-          *imagep = NULL;
-        }
+  if (!clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL))
+    return;
 
-      if (file)
-        {
-          MetaBackgroundImageCache *cache = meta_background_image_cache_get_default ();
+  ensure_pipeline (self);
 
-          *filep = g_object_ref (file);
-          *imagep = meta_background_image_cache_load (cache, file);
-          g_signal_connect (*imagep, "loaded",
-                            G_CALLBACK (on_background_loaded), self);
-        }
-    }
+  /* Cogl automatically caches pipelines with no eviction policy,
+   * so we need to prevent identical pipelines from getting cached
+   * separately, by reusing the same fragement shader snippet.
+   */
+  if (snippet == NULL)
+    snippet = cogl_snippet_new (COGL_SNIPPET_HOOK_FRAGMENT, FRAGMENT_SHADER_DECLARATIONS, VIGNETTE_CODE);
+
+  cogl_pipeline_add_snippet (priv->pipeline, snippet);
+
+  cogl_pipeline_set_uniform_1f (priv->pipeline,
+                                cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                    "brightness"),
+                                priv->brightness);
+
+  cogl_pipeline_set_uniform_1f (priv->pipeline,
+                                cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                    "vignette_sharpness"),
+                                priv->vignette_sharpness);
 }
 
 static void
-meta_background_dispose (GObject *object)
+set_effects (MetaBackground        *self,
+             MetaBackgroundEffects  effects)
 {
-  MetaBackground        *self = META_BACKGROUND (object);
   MetaBackgroundPrivate *priv = self->priv;
 
-  free_color_texture (self);
-  free_wallpaper_texture (self);
+  priv->effects = effects;
 
-  set_file (self, &priv->file1, &priv->background_image1, NULL);
-  set_file (self, &priv->file2, &priv->background_image2, NULL);
+  if ((priv->effects & META_BACKGROUND_EFFECTS_VIGNETTE))
+    add_vignette (self);
 
-  set_screen (self, NULL);
+  clutter_content_invalidate (CLUTTER_CONTENT (self));
+}
 
-  G_OBJECT_CLASS (meta_background_parent_class)->dispose (object);
+static void
+meta_background_set_property (GObject      *object,
+                              guint         prop_id,
+                              const GValue *value,
+                              GParamSpec   *pspec)
+{
+  MetaBackground        *self = META_BACKGROUND (object);
+  MetaBackgroundPrivate *priv = self->priv;
+
+  switch (prop_id)
+    {
+    case PROP_META_SCREEN:
+      priv->screen = g_value_get_object (value);
+      break;
+    case PROP_MONITOR:
+      priv->monitor = g_value_get_int (value);
+      break;
+    case PROP_EFFECTS:
+      set_effects (self, g_value_get_flags (value));
+      break;
+    case PROP_BRIGHTNESS:
+      set_brightness (self, g_value_get_float (value));
+      break;
+    case PROP_VIGNETTE_SHARPNESS:
+      set_vignette_sharpness (self, g_value_get_float (value));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
 }
 
 static void
-meta_background_finalize (GObject *object)
+meta_background_get_property (GObject      *object,
+                              guint         prop_id,
+                              GValue       *value,
+                              GParamSpec   *pspec)
 {
-  all_backgrounds = g_slist_remove (all_backgrounds, object);
+  MetaBackgroundPrivate *priv = META_BACKGROUND (object)->priv;
 
-  G_OBJECT_CLASS (meta_background_parent_class)->finalize (object);
+  switch (prop_id)
+    {
+    case PROP_META_SCREEN:
+      g_value_set_object (value, priv->screen);
+      break;
+    case PROP_MONITOR:
+      g_value_set_int (value, priv->monitor);
+      break;
+    case PROP_EFFECTS:
+      g_value_set_flags (value, priv->effects);
+      break;
+    case PROP_BRIGHTNESS:
+      g_value_set_float (value, priv->brightness);
+      break;
+    case PROP_VIGNETTE_SHARPNESS:
+      g_value_set_float (value, priv->vignette_sharpness);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
 }
 
 static void
 meta_background_class_init (MetaBackgroundClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  GParamSpec *param_spec;
+  GParamSpec   *param_spec;
 
   g_type_class_add_private (klass, sizeof (MetaBackgroundPrivate));
 
@@ -325,24 +699,49 @@
   object_class->set_property = meta_background_set_property;
   object_class->get_property = meta_background_get_property;
 
-  signals[CHANGED] =
-    g_signal_new ("changed",
-                  G_TYPE_FROM_CLASS (object_class),
-                  G_SIGNAL_RUN_LAST,
-                  0,
-                  NULL, NULL, NULL,
-                  G_TYPE_NONE, 0);
-
   param_spec = g_param_spec_object ("meta-screen",
                                     "MetaScreen",
                                     "MetaScreen",
                                     META_TYPE_SCREEN,
-                                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
+                                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
 
   g_object_class_install_property (object_class,
                                    PROP_META_SCREEN,
                                    param_spec);
 
+  param_spec = g_param_spec_int ("monitor",
+                                 "monitor",
+                                 "monitor",
+                                 0, G_MAXINT, 0,
+                                 G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
+
+  g_object_class_install_property (object_class,
+                                   PROP_MONITOR,
+                                   param_spec);
+
+  param_spec = g_param_spec_float ("brightness",
+                                   "brightness",
+                                   "Values less than 1.0 dim background",
+                                   0.0, 1.0,
+                                   1.0,
+                                   G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
+  g_object_class_install_property (object_class, PROP_BRIGHTNESS, param_spec);
+
+  param_spec = g_param_spec_float ("vignette-sharpness",
+                                   "vignette-sharpness",
+                                   "How obvious the vignette fringe is",
+                                   0.0, 1.0,
+                                   0.7,
+                                   G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
+  g_object_class_install_property (object_class, PROP_VIGNETTE_SHARPNESS, param_spec);
+
+  param_spec = g_param_spec_flags ("effects",
+                                   "Effects",
+                                   "Set to enable vignette",
+				   meta_background_effects_get_type (),
+                                   META_BACKGROUND_EFFECTS_NONE,
+                                   G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
+  g_object_class_install_property (object_class, PROP_EFFECTS, param_spec);
 }
 
 static void
@@ -351,579 +750,495 @@
   self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
                                             META_TYPE_BACKGROUND,
                                             MetaBackgroundPrivate);
-  all_backgrounds = g_slist_prepend (all_backgrounds, self);
 }
 
 static void
-set_texture_area_from_monitor_area (cairo_rectangle_int_t *monitor_area,
-                                    cairo_rectangle_int_t *texture_area)
+unset_texture (MetaBackground *self)
 {
-  texture_area->x = 0;
-  texture_area->y = 0;
-  texture_area->width = monitor_area->width;
-  texture_area->height = monitor_area->height;
+  MetaBackgroundPrivate *priv = self->priv;
+  if (priv->pipeline != NULL)
+    cogl_pipeline_set_layer_texture (priv->pipeline, 0, NULL);
+
+  g_clear_pointer (&priv->texture,
+                   (GDestroyNotify)
+                   cogl_object_unref);
 }
 
 static void
-get_texture_area (MetaBackground          *self,
-                  cairo_rectangle_int_t   *monitor_rect,
-                  CoglTexture             *texture,
-                  cairo_rectangle_int_t   *texture_area)
+set_texture (MetaBackground *self,
+             CoglTexture    *texture)
 {
   MetaBackgroundPrivate *priv = self->priv;
-  cairo_rectangle_int_t image_area;
-  int screen_width, screen_height;
-  float texture_width, texture_height;
-  float monitor_x_scale, monitor_y_scale;
-
-  texture_width = cogl_texture_get_width (texture);
-  texture_height = cogl_texture_get_height (texture);
-
-  switch (priv->style)
-    {
-    case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
-    default:
-      /* paint region is whole actor, and the texture
-       * is scaled disproportionately to fit the actor
-       */
-      set_texture_area_from_monitor_area (monitor_rect, texture_area);
-      break;
-    case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
-      meta_screen_get_size (priv->screen, &screen_width, &screen_height);
-
-      /* Start off by centering a tile in the middle of the
-       * total screen area.
-       */
-      image_area.x = (screen_width - texture_width) / 2.0;
-      image_area.y = (screen_height - texture_height) / 2.0;
-      image_area.width = texture_width;
-      image_area.height = texture_height;
-
-      /* Translate into the coordinate system of the particular monitor */
-      image_area.x -= monitor_rect->x;
-      image_area.y -= monitor_rect->y;
-
-      *texture_area = image_area;
-      break;
-    case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
-      /* paint region is the original image size centered in the actor,
-       * and the texture is scaled to the original image size */
-      image_area.width = texture_width;
-      image_area.height = texture_height;
-      image_area.x = monitor_rect->width / 2 - image_area.width / 2;
-      image_area.y = monitor_rect->height / 2 - image_area.height / 2;
-
-      *texture_area = image_area;
-      break;
-    case G_DESKTOP_BACKGROUND_STYLE_SCALED:
-    case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
-      /* paint region is the actor size in one dimension, and centered and
-       * scaled by proportional amount in the other dimension.
-       *
-       * SCALED forces the centered dimension to fit on screen.
-       * ZOOM forces the centered dimension to grow off screen
-       */
-      monitor_x_scale = monitor_rect->width / texture_width;
-      monitor_y_scale = monitor_rect->height / texture_height;
-
-      if ((priv->style == G_DESKTOP_BACKGROUND_STYLE_SCALED &&
-           (monitor_x_scale < monitor_y_scale)) ||
-          (priv->style == G_DESKTOP_BACKGROUND_STYLE_ZOOM &&
-           (monitor_x_scale > monitor_y_scale)))
-        {
-          /* Fill image to exactly fit actor horizontally */
-          image_area.width = monitor_rect->width;
-          image_area.height = texture_height * monitor_x_scale;
-
-          /* Position image centered vertically in actor */
-          image_area.x = 0;
-          image_area.y = monitor_rect->height / 2 - image_area.height / 2;
-        }
-      else
-        {
-          /* Scale image to exactly fit actor vertically */
-          image_area.width = texture_width * monitor_y_scale;
-          image_area.height = monitor_rect->height;
-
-          /* Position image centered horizontally in actor */
-          image_area.x = monitor_rect->width / 2 - image_area.width / 2;
-          image_area.y = 0;
-        }
-
-      *texture_area = image_area;
-      break;
-
-    case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
-      {
-        /* paint region is the union of all monitors, with the origin
-         * of the region set to align with monitor associated with the background.
-         */
-        meta_screen_get_size (priv->screen, &screen_width, &screen_height);
 
-        /* unclipped texture area is whole screen */
-        image_area.width = screen_width;
-        image_area.height = screen_height;
-
-        /* But make (0,0) line up with the appropriate monitor */
-        image_area.x = -monitor_rect->x;
-        image_area.y = -monitor_rect->y;
-
-        *texture_area = image_area;
-        break;
-      }
-    }
+  priv->texture = texture;
+  cogl_pipeline_set_layer_texture (priv->pipeline, 0, priv->texture);
 }
 
 static void
-draw_texture (MetaBackground        *self,
-              CoglFramebuffer       *framebuffer,
-              CoglPipeline          *pipeline,
-              CoglTexture           *texture,
-              cairo_rectangle_int_t *monitor_area)
+set_style (MetaBackground          *self,
+           GDesktopBackgroundStyle  style)
 {
   MetaBackgroundPrivate *priv = self->priv;
-  cairo_rectangle_int_t texture_area;
+  CoglPipelineWrapMode   wrap_mode;
 
-  get_texture_area (self, monitor_area, texture, &texture_area);
+  priv->style = style;
 
-  switch (priv->style)
-    {
-    case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
-    case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
-    case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
-    case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
-      /* Draw the entire monitor */
-      cogl_framebuffer_draw_textured_rectangle (framebuffer,
-                                                pipeline,
-                                                0,
-                                                0,
-                                                monitor_area->width,
-                                                monitor_area->height,
-                                                - texture_area.x / (float)texture_area.width,
-                                                - texture_area.y / (float)texture_area.height,
-                                                (monitor_area->width - texture_area.x) / (float)texture_area.width,
-                                                (monitor_area->height - texture_area.y) / (float)texture_area.height);
-      /* Draw just the texture */
-      break;
-    case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
-    case G_DESKTOP_BACKGROUND_STYLE_SCALED:
-      cogl_framebuffer_draw_textured_rectangle (framebuffer,
-                                                pipeline,
-                                                texture_area.x, texture_area.y,
-                                                texture_area.x + texture_area.width,
-                                                texture_area.y + texture_area.height,
-                                                0, 0, 1.0, 1.0);
-    case G_DESKTOP_BACKGROUND_STYLE_NONE:
-      break;
-    default:
-      g_return_if_reached();
-    }
+  wrap_mode = get_wrap_mode (self);
+  cogl_pipeline_set_layer_wrap_mode (priv->pipeline, 0, wrap_mode);
 }
 
 static void
-ensure_color_texture (MetaBackground *self)
+set_filename (MetaBackground *self,
+              const char     *filename)
 {
   MetaBackgroundPrivate *priv = self->priv;
 
-  if (priv->color_texture == NULL)
-    {
-      ClutterBackend *backend = clutter_get_default_backend ();
-      CoglContext *ctx = clutter_backend_get_cogl_context (backend);
-      uint8_t pixels[6];
-      int width, height;
-
-      if (priv->shading_direction == G_DESKTOP_BACKGROUND_SHADING_SOLID)
-        {
-          width = 1;
-          height = 1;
-
-          pixels[0] = priv->color.red;
-          pixels[1] = priv->color.green;
-          pixels[2] = priv->color.blue;
-        }
-      else
-        {
-          switch (priv->shading_direction)
-            {
-            case G_DESKTOP_BACKGROUND_SHADING_VERTICAL:
-              width = 1;
-              height = 2;
-              break;
-            case G_DESKTOP_BACKGROUND_SHADING_HORIZONTAL:
-              width = 2;
-              height = 1;
-              break;
-            default:
-              g_return_if_reached ();
-            }
-
-          pixels[0] = priv->color.red;
-          pixels[1] = priv->color.green;
-          pixels[2] = priv->color.blue;
-          pixels[3] = priv->second_color.red;
-          pixels[4] = priv->second_color.green;
-          pixels[5] = priv->second_color.blue;
-        }
-
-      priv->color_texture = COGL_TEXTURE (cogl_texture_2d_new_from_data (ctx, width, height,
-                                                                         COGL_PIXEL_FORMAT_RGB_888,
-                                                                         width * 3,
-                                                                         pixels,
-                                                                         NULL));
-    }
+  g_free (priv->filename);
+  priv->filename = g_strdup (filename);
 }
 
-typedef enum {
-  PIPELINE_REPLACE,
-  PIPELINE_ADD,
-  PIPELINE_OVER_REVERSE,
-} PipelineType;
-
-static CoglPipeline *
-create_pipeline (PipelineType type)
+/**
+ * meta_background_load_gradient:
+ * @self: the #MetaBackground
+ * @shading_direction: the orientation of the gradient
+ * @color: the start color of the gradient
+ * @second_color: the end color of the gradient
+ *
+ * Clears any previously set background, and sets the background gradient.
+ * The gradient starts with @color and
+ * progresses toward @second_color in the direction of @shading_direction.
+ */
+void
+meta_background_load_gradient (MetaBackground             *self,
+                               GDesktopBackgroundShading   shading_direction,
+                               ClutterColor               *color,
+                               ClutterColor               *second_color)
 {
-  const char * const blend_strings[3] = {
-    [PIPELINE_REPLACE] = "RGBA = ADD (SRC_COLOR, 0)",
-    [PIPELINE_ADD] = "RGBA = ADD (SRC_COLOR, DST_COLOR)",
-    [PIPELINE_OVER_REVERSE] = "RGBA = ADD (SRC_COLOR * (1 - DST_COLOR[A]), DST_COLOR)",
-  };
-  static CoglPipeline *templates[3];
+  ClutterBackend *backend = clutter_get_default_backend ();
+  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
+  MetaBackgroundPrivate *priv = self->priv;
+  CoglTexture *texture;
+  guint width, height;
+  uint8_t pixels[8];
 
-  if (templates[type] == NULL)
-    {
-      templates[type] = meta_create_texture_pipeline (NULL);
-      cogl_pipeline_set_blend (templates[type], blend_strings[type], NULL);
-    }
+  ensure_pipeline (self);
 
-  return cogl_pipeline_copy (templates[type]);
-}
+  unset_texture (self);
+  set_style (self, G_DESKTOP_BACKGROUND_STYLE_NONE);
 
-static gboolean
-texture_has_alpha (CoglTexture *texture)
-{
-  if (!texture)
-    return FALSE;
+  priv->shading_direction = shading_direction;
 
-  switch (cogl_texture_get_components (texture))
+  switch (priv->shading_direction)
     {
-    case COGL_TEXTURE_COMPONENTS_A:
-    case COGL_TEXTURE_COMPONENTS_RGBA:
-      return TRUE;
-    case COGL_TEXTURE_COMPONENTS_RG:
-    case COGL_TEXTURE_COMPONENTS_RGB:
-    case COGL_TEXTURE_COMPONENTS_DEPTH:
-      return FALSE;
-    default:
-      g_assert_not_reached ();
+      case G_DESKTOP_BACKGROUND_SHADING_VERTICAL:
+          width = 1;
+          height = 2;
+          break;
+      case G_DESKTOP_BACKGROUND_SHADING_HORIZONTAL:
+          width = 2;
+          height = 1;
+          break;
+      default:
+          g_return_if_reached ();
     }
-}
 
-static gboolean
-ensure_wallpaper_texture (MetaBackground *self,
-                          CoglTexture    *texture)
+  pixels[0] = color->red;
+  pixels[1] = color->green;
+  pixels[2] = color->blue;
+  pixels[3] = 0xFF;
+  pixels[4] = second_color->red;
+  pixels[5] = second_color->green;
+  pixels[6] = second_color->blue;
+  pixels[7] = 0xFF;
+
+  texture = COGL_TEXTURE (cogl_texture_2d_new_from_data (ctx, width, height,
+                                                         COGL_PIXEL_FORMAT_RGB_888,
+                                                         4,
+                                                         pixels,
+                                                         NULL));
+  set_texture (self, COGL_TEXTURE (texture));
+}
+
+/**
+ * meta_background_load_color:
+ * @self: the #MetaBackground
+ * @color: a #ClutterColor to solid fill background with
+ *
+ * Clears any previously set background, and sets the
+ * background to a solid color
+ *
+ * If @color is %NULL the stage color will be used.
+ */
+void
+meta_background_load_color (MetaBackground *self,
+                            ClutterColor   *color)
 {
+  ClutterBackend *backend = clutter_get_default_backend ();
+  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
   MetaBackgroundPrivate *priv = self->priv;
+  CoglTexture  *texture;
+  ClutterActor *stage = meta_get_stage_for_screen (priv->screen);
+  ClutterColor  stage_color;
+  uint8_t pixels[4];
 
-  if (priv->wallpaper_texture == NULL && !priv->wallpaper_allocation_failed)
-    {
-      int width = cogl_texture_get_width (texture);
-      int height = cogl_texture_get_height (texture);
-      CoglFramebuffer *fbo;
-      CoglError *catch_error = NULL;
-      CoglPipeline *pipeline;
-
-      priv->wallpaper_texture = meta_create_texture (width, height,
-                                                     COGL_TEXTURE_COMPONENTS_RGBA,
-                                                     META_TEXTURE_FLAGS_NONE);
-      fbo = cogl_offscreen_new_with_texture (priv->wallpaper_texture);
+  ensure_pipeline (self);
 
-      if (!cogl_framebuffer_allocate (fbo, &catch_error))
-        {
-          /* This probably means that the size of the wallpapered texture is larger
-           * than the maximum texture size; we treat it as permanent until the
-           * background is changed again.
-           */
-          cogl_error_free (catch_error);
+  unset_texture (self);
+  set_style (self, G_DESKTOP_BACKGROUND_STYLE_NONE);
 
-          cogl_object_unref (priv->wallpaper_texture);
-          priv->wallpaper_texture = NULL;
-          cogl_object_unref (fbo);
+  if (color == NULL)
+    {
+      clutter_actor_get_background_color (stage, &stage_color);
+      color = &stage_color;
+    }
 
-          priv->wallpaper_allocation_failed = TRUE;
-          return FALSE;
-        }
+  pixels[0] = color->red;
+  pixels[1] = color->green;
+  pixels[2] = color->blue;
+  pixels[3] = 0xFF;
 
-      cogl_framebuffer_orthographic (fbo, 0, 0,
-                                     width, height, -1., 1.);
+  texture = COGL_TEXTURE (cogl_texture_2d_new_from_data (ctx, 1, 1,
+                                                         COGL_PIXEL_FORMAT_RGB_888,
+                                                         4,
+                                                         pixels,
+                                                         NULL));
+  set_texture (self, COGL_TEXTURE (texture));
+}
 
-      pipeline = create_pipeline (PIPELINE_REPLACE);
-      cogl_pipeline_set_layer_texture (pipeline, 0, texture);
-      cogl_framebuffer_draw_textured_rectangle (fbo, pipeline, 0, 0, width, height,
-                                                0., 0., 1., 1.);
-      cogl_object_unref (pipeline);
+typedef struct
+{
+  GDesktopBackgroundStyle style;
+  char *filename;
+} LoadFileTaskData;
 
-      if (texture_has_alpha (texture))
-        {
-          ensure_color_texture (self);
+static LoadFileTaskData *
+load_file_task_data_new (const char              *filename,
+                         GDesktopBackgroundStyle  style)
+{
+  LoadFileTaskData *task_data;
 
-          pipeline = create_pipeline (PIPELINE_OVER_REVERSE);
-          cogl_pipeline_set_layer_texture (pipeline, 0, priv->color_texture);
-          cogl_framebuffer_draw_rectangle (fbo, pipeline, 0, 0, width, height);
-          cogl_object_unref (pipeline);
-        }
+  task_data = g_slice_new (LoadFileTaskData);
+  task_data->style = style;
+  task_data->filename = g_strdup (filename);
 
-      cogl_object_unref (fbo);
-    }
+  return task_data;
+}
 
-  return priv->wallpaper_texture != NULL;
+static void
+load_file_task_data_free (LoadFileTaskData *task_data)
+{
+  g_free (task_data->filename);
+  g_slice_free (LoadFileTaskData, task_data);
 }
 
-static CoglPipelineWrapMode
-get_wrap_mode (GDesktopBackgroundStyle style)
+static void
+load_file (GTask            *task,
+           MetaBackground   *self,
+           LoadFileTaskData *task_data,
+           GCancellable     *cancellable)
 {
-  switch (style)
+  GError *error = NULL;
+  GdkPixbuf *pixbuf;
+
+  pixbuf = gdk_pixbuf_new_from_file (task_data->filename,
+                                     &error);
+
+  if (pixbuf == NULL)
     {
-      case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
-          return COGL_PIPELINE_WRAP_MODE_REPEAT;
-      case G_DESKTOP_BACKGROUND_STYLE_NONE:
-      case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
-      case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
-      case G_DESKTOP_BACKGROUND_STYLE_SCALED:
-      case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
-      case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
-      default:
-          return COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
+      g_task_return_error (task, error);
+      return;
     }
+
+  g_task_return_pointer (task, pixbuf, (GDestroyNotify) g_object_unref);
 }
 
-CoglTexture *
-meta_background_get_texture (MetaBackground         *self,
-                             int                     monitor_index,
-                             cairo_rectangle_int_t  *texture_area,
-                             CoglPipelineWrapMode   *wrap_mode)
-{
-  MetaBackgroundPrivate *priv;
-  MetaBackgroundMonitor *monitor;
-  MetaRectangle geometry;
-  cairo_rectangle_int_t monitor_area;
-  CoglTexture *texture1, *texture2;
+/**
+ * meta_background_load_file_async:
+ * @self: the #MetaBackground
+ * @filename: the image file to load
+ * @style: a #GDesktopBackgroundStyle to specify how background is laid out
+ * @cancellable: a #GCancellable
+ * @callback: call back to call when file is loaded or failed to load
+ * @user_data: user data for callback
+ *
+ * Loads the specified image and uses it as the background source.
+ */
+void
+meta_background_load_file_async (MetaBackground          *self,
+                                 const char              *filename,
+                                 GDesktopBackgroundStyle  style,
+                                 GCancellable            *cancellable,
+                                 GAsyncReadyCallback      callback,
+                                 gpointer                 user_data)
+{
+    LoadFileTaskData *task_data;
+    GTask *task;
+
+    task = g_task_new (self, cancellable, callback, user_data);
+
+    task_data = load_file_task_data_new (filename, style);
+    g_task_set_task_data (task, task_data, (GDestroyNotify) load_file_task_data_free);
+
+    g_task_run_in_thread (task, (GTaskThreadFunc) load_file);
+    g_object_unref (task);
+}
+
+/**
+ * meta_background_load_file_finish:
+ * @self: the #MetaBackground
+ * @result: the result from the #GAsyncReadyCallback passed
+ *          to meta_background_load_file_async()
+ * @error: a #GError
+ *
+ * The finish function for meta_background_load_file_async().
+ *
+ * Returns: whether or not the image was loaded
+ */
+gboolean
+meta_background_load_file_finish (MetaBackground  *self,
+                                  GAsyncResult    *result,
+                                  GError         **error)
+{
+  ClutterBackend *backend = clutter_get_default_backend ();
+  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
+  GTask *task;
+  LoadFileTaskData *task_data;
+  CoglTexture *texture;
+  GdkPixbuf *pixbuf;
+  int width, height, row_stride;
+  guchar *pixels;
+  gboolean has_alpha;
+  gboolean loaded = FALSE;
+  CoglPixelFormat pixel_format;
 
-  g_return_val_if_fail (META_IS_BACKGROUND (self), NULL);
-  priv = self->priv;
-  g_return_val_if_fail (monitor_index >= 0 && monitor_index < priv->n_monitors, NULL);
+  g_return_val_if_fail (g_task_is_valid (result, self), FALSE);
 
-  monitor = &priv->monitors[monitor_index];
+  task = G_TASK (result);
 
-  meta_screen_get_monitor_geometry (priv->screen, monitor_index, &geometry);
-  monitor_area.x = geometry.x;
-  monitor_area.y = geometry.y;
-  monitor_area.width = geometry.width;
-  monitor_area.height = geometry.height;
+  pixbuf = g_task_propagate_pointer (task, error);
 
-  texture1 = priv->background_image1 ? meta_background_image_get_texture (priv->background_image1) : NULL;
-  texture2 = priv->background_image2 ? meta_background_image_get_texture (priv->background_image2) : NULL;
+  if (pixbuf == NULL)
+    goto out;
 
-  if (texture1 == NULL && texture2 == NULL)
-    {
-      ensure_color_texture (self);
-      if (texture_area)
-        set_texture_area_from_monitor_area (&monitor_area, texture_area);
-      if (wrap_mode)
-        *wrap_mode = COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
-      return priv->color_texture;
-    }
+  task_data = g_task_get_task_data (task);
 
-  if (texture2 == NULL && priv->style == G_DESKTOP_BACKGROUND_STYLE_WALLPAPER &&
-      priv->shading_direction == G_DESKTOP_BACKGROUND_SHADING_SOLID &&
-      ensure_wallpaper_texture (self, texture1))
-    {
-      if (texture_area)
-        get_texture_area (self, &monitor_area, priv->wallpaper_texture,
-                          texture_area);
-      if (wrap_mode)
-        *wrap_mode = COGL_PIPELINE_WRAP_MODE_REPEAT;
-      return priv->wallpaper_texture;
-    }
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  row_stride = gdk_pixbuf_get_rowstride (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
 
-  if (monitor->dirty)
-    {
-      CoglError *catch_error = NULL;
+  pixel_format = has_alpha ? COGL_PIXEL_FORMAT_RGBA_8888 : COGL_PIXEL_FORMAT_RGB_888;
 
-      if (monitor->texture == NULL)
-        {
-          monitor->texture = meta_create_texture (monitor_area.width, monitor_area.height,
-                                                  COGL_TEXTURE_COMPONENTS_RGBA,
-                                                  META_TEXTURE_FLAGS_NONE);
-          monitor->fbo = cogl_offscreen_new_with_texture (monitor->texture);
-        }
-
-      if (!cogl_framebuffer_allocate (monitor->fbo, &catch_error))
-        {
-          /* Texture or framebuffer allocation failed; it's unclear why this happened;
-           * we'll try again the next time this is called. (MetaBackgroundActor
-           * caches the result, so user might be left without a background.)
-           */
-          cogl_object_unref (monitor->texture);
-          monitor->texture = NULL;
-          cogl_object_unref (monitor->fbo);
-          monitor->fbo = NULL;
+  texture = COGL_TEXTURE (cogl_texture_2d_new_from_data (ctx, width, height,
+                                                         pixel_format,
+                                                         row_stride,
+                                                         pixels,
+                                                         NULL));
 
-          cogl_error_free (catch_error);
-          return NULL;
-        }
+  if (texture == NULL)
+    {
+      g_set_error_literal (error,
+                           COGL_BITMAP_ERROR,
+                           COGL_BITMAP_ERROR_FAILED,
+                           _("background texture could not be created from file"));
+      goto out;
+    }
 
-      cogl_framebuffer_orthographic (monitor->fbo, 0, 0,
-                                     monitor_area.width, monitor_area.height, -1., 1.);
+  ensure_pipeline (self);
+  unset_texture (self);
+  set_style (self, task_data->style);
+  set_filename (self, task_data->filename);
+  set_texture (self, texture);
+
+  clutter_content_invalidate (CLUTTER_CONTENT (self));
+  loaded = TRUE;
+
+out:
+  if (pixbuf != NULL)
+    g_object_unref (pixbuf);
+  return loaded;
+}
+
+/**
+ * meta_background_copy:
+ * @self: a #MetaBackground to copy
+ * @monitor: a monitor
+ * @effects: effects to use on copy of @self
+ *
+ * Creates a new #MetaBackground to draw the background for the given monitor.
+ * Background will be loaded from @self and will share state
+ * with @self, but may have different effects applied to it.
+ *
+ * Return value: (transfer full): the newly created background content
+ */
+MetaBackground *
+meta_background_copy (MetaBackground        *self,
+                      int                    monitor,
+                      MetaBackgroundEffects  effects)
+{
+  MetaBackground *background;
+
+  background = META_BACKGROUND (g_object_new (META_TYPE_BACKGROUND,
+                                              "meta-screen", self->priv->screen,
+                                              "monitor", monitor,
+                                              NULL));
+
+  background->priv->brightness = self->priv->brightness;
+
+  background->priv->shading_direction = self->priv->shading_direction;
+  background->priv->color = self->priv->color;
+  background->priv->second_color = self->priv->second_color;
+  background->priv->filename = g_strdup (self->priv->filename);
+
+  /* we can reuse the pipeline if it has no effects applied, or
+   * if it has the same effects applied
+   */
+  if (effects == self->priv->effects ||
+      self->priv->effects == META_BACKGROUND_EFFECTS_NONE)
+    {
+      ensure_pipeline (self);
+      background->priv->pipeline = cogl_pipeline_copy (self->priv->pipeline);
+      background->priv->texture = cogl_object_ref (self->priv->texture);
+      background->priv->style = self->priv->style;
 
-      if (texture2 != NULL && priv->blend_factor != 0.0)
+      if (effects != self->priv->effects)
         {
-          CoglPipeline *pipeline = create_pipeline (PIPELINE_REPLACE);
-          cogl_pipeline_set_color4f (pipeline,
-                                      priv->blend_factor, priv->blend_factor, priv->blend_factor, priv->blend_factor);
-          cogl_pipeline_set_layer_texture (pipeline, 0, texture2);
-          cogl_pipeline_set_layer_wrap_mode (pipeline, 0, get_wrap_mode (priv->style));
-
-          draw_texture (self,
-                        monitor->fbo, pipeline,
-                        texture2, &monitor_area);
+          set_effects (background, effects);
 
-          cogl_object_unref (pipeline);
+          if (effects & META_BACKGROUND_EFFECTS_VIGNETTE)
+            {
+              set_brightness (background, self->priv->brightness);
+              set_vignette_sharpness (background, self->priv->vignette_sharpness);
+            }
         }
       else
         {
-          cogl_framebuffer_clear4f (monitor->fbo,
-                                    COGL_BUFFER_BIT_COLOR,
-                                    0.0, 0.0, 0.0, 0.0);
+          background->priv->effects = self->priv->effects;
         }
 
-      if (texture1 != NULL &&
-          !(texture2 != NULL && priv->blend_factor == 1.0 && !texture_has_alpha (texture2)))
-        {
-          CoglPipeline *pipeline = create_pipeline (PIPELINE_ADD);
-          cogl_pipeline_set_color4f (pipeline,
-                                     (1 - priv->blend_factor),
-                                     (1 - priv->blend_factor),
-                                     (1 - priv->blend_factor),
-                                     (1 - priv->blend_factor));;
-          cogl_pipeline_set_layer_texture (pipeline, 0, texture1);
-          cogl_pipeline_set_layer_wrap_mode (pipeline, 0, get_wrap_mode (priv->style));
-
-          draw_texture (self,
-                        monitor->fbo, pipeline,
-                        texture1, &monitor_area);
-
-          cogl_object_unref (pipeline);
-        }
+    }
+  else
+    {
+      ensure_pipeline (background);
+      if (self->priv->texture != NULL)
+        set_texture (background, cogl_object_ref (self->priv->texture));
+      set_style (background, self->priv->style);
+      set_effects (background, effects);
 
-      if (!((texture2 != NULL && priv->blend_factor == 1.0 && !texture_has_alpha (texture2)) ||
-            (texture1 != NULL && !texture_has_alpha (texture1))))
+      if (effects & META_BACKGROUND_EFFECTS_VIGNETTE)
         {
-          CoglPipeline *pipeline = create_pipeline (PIPELINE_OVER_REVERSE);
-
-          ensure_color_texture (self);
-          cogl_pipeline_set_layer_texture (pipeline, 0, priv->color_texture);
-          cogl_framebuffer_draw_rectangle (monitor->fbo,
-                                           pipeline,
-                                           0, 0,
-                                           monitor_area.width, monitor_area.height);
-          cogl_object_unref (pipeline);
+          set_brightness (background, self->priv->brightness);
+          set_vignette_sharpness (background, self->priv->vignette_sharpness);
         }
-
-      monitor->dirty = FALSE;
     }
 
-  if (texture_area)
-    set_texture_area_from_monitor_area (&monitor_area, texture_area);
+  clutter_content_invalidate (CLUTTER_CONTENT (background));
 
-  if (wrap_mode)
-    *wrap_mode = COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
-  return monitor->texture;
+  return background;
 }
-
+/**
+ * meta_background_new:
+ * @screen: the #MetaScreen
+ * @monitor: a monitor in @screen
+ * @effects: which effect flags to enable
+ *
+ * Creates a new #MetaBackground to draw the background for the given monitor.
+ * The returned object should be set on a #MetaBackgroundActor with
+ * clutter_actor_set_content().
+ *
+ * The background may be given a vignette by setting @effects
+ *
+ * Return value: the newly created background content
+ */
 MetaBackground *
-meta_background_new  (MetaScreen *screen)
+meta_background_new (MetaScreen            *screen,
+                     int                    monitor,
+                     MetaBackgroundEffects  effects)
+{
+  MetaBackground *background;
+
+  background = META_BACKGROUND (g_object_new (META_TYPE_BACKGROUND,
+                                              "meta-screen", screen,
+                                              "monitor", monitor,
+                                              "effects", effects,
+                                              NULL));
+  return background;
+}
+
+/**
+ * meta_background_get_style:
+ * @self: a #MetaBackground
+ *
+ * Returns the current background style.
+ *
+ * Return value: a #GDesktopBackgroundStyle
+ */
+GDesktopBackgroundStyle
+meta_background_get_style (MetaBackground *self)
 {
-  return g_object_new (META_TYPE_BACKGROUND,
-                       "meta-screen", screen,
-                       NULL);
+    return self->priv->style;
 }
 
-void
-meta_background_set_color (MetaBackground *self,
-                           ClutterColor   *color)
+/**
+ * meta_background_get_shading:
+ * @self: a #MetaBackground
+ *
+ * Returns whether @self is a solid color,
+ * vertical gradient, horizontal gradient,
+ * or none of the above.
+ *
+ * Return value: a #GDesktopBackgroundShading
+ */
+GDesktopBackgroundShading
+meta_background_get_shading (MetaBackground *self)
 {
-  ClutterColor dummy = { 0 };
-
-  g_return_if_fail (META_IS_BACKGROUND (self));
-  g_return_if_fail (color != NULL);
-
-  meta_background_set_gradient (self,
-                                G_DESKTOP_BACKGROUND_SHADING_SOLID,
-                                color, &dummy);
-}
-
-void
-meta_background_set_gradient (MetaBackground            *self,
-                              GDesktopBackgroundShading  shading_direction,
-                              ClutterColor              *color,
-                              ClutterColor              *second_color)
-{
-  MetaBackgroundPrivate *priv;
-
-  g_return_if_fail (META_IS_BACKGROUND (self));
-  g_return_if_fail (color != NULL);
-  g_return_if_fail (second_color != NULL);
-
-  priv = self->priv;
-
-  priv->shading_direction = shading_direction;
-  priv->color = *color;
-  priv->second_color = *second_color;
-
-  free_color_texture (self);
-  free_wallpaper_texture (self);
-  mark_changed (self);
+    return self->priv->shading_direction;
 }
 
-void
-meta_background_set_file (MetaBackground            *self,
-                          GFile                     *file,
-                          GDesktopBackgroundStyle    style)
+/**
+ * meta_background_get_color:
+ * @self: a #MetaBackground
+ *
+ * Returns the first color of @self. If self
+ * is a gradient, the second color can be returned
+ * with meta_background_get_second_color().
+ *
+ * Return value: (transfer none): a #ClutterColor
+ */
+const ClutterColor *
+meta_background_get_color (MetaBackground *self)
 {
-  g_return_if_fail (META_IS_BACKGROUND (self));
-
-  meta_background_set_blend (self, file, NULL, 0.0, style);
+    return &self->priv->color;
 }
 
-void
-meta_background_set_blend (MetaBackground          *self,
-                           GFile                   *file1,
-                           GFile                   *file2,
-                           double                   blend_factor,
-                           GDesktopBackgroundStyle  style)
+/**
+ * meta_background_get_second_color:
+ * @self: a #MetaBackground
+ *
+ * Returns the second color of @self. If @self
+ * is not a gradient this function is undefined.
+ *
+ * Return value: (transfer none): a #ClutterColor
+ */
+const ClutterColor *
+meta_background_get_second_color (MetaBackground *self)
 {
-  MetaBackgroundPrivate *priv;
-
-  g_return_if_fail (META_IS_BACKGROUND (self));
-  g_return_if_fail (blend_factor >= 0.0 && blend_factor <= 1.0);
-
-  priv = self->priv;
-
-  set_file (self, &priv->file1, &priv->background_image1, file1);
-  set_file (self, &priv->file2, &priv->background_image2, file2);
-
-  priv->blend_factor = blend_factor;
-  priv->style = style;
-
-  free_wallpaper_texture (self);
-  mark_changed (self);
+    return &self->priv->second_color;
 }
 
-void
-meta_background_refresh_all (void)
+/**
+ * meta_background_get_filename:
+ * @self: a #MetaBackground
+ *
+ * Returns the filename of the currently loaded file.
+ * IF @self is not loaded from a file this function is
+ * undefined.
+ *
+ * Return value: (transfer none): the filename
+ */
+const char *
+meta_background_get_filename (MetaBackground *self)
 {
-  GSList *l;
-
-  for (l = all_backgrounds; l; l = l->next)
-    mark_changed (l->data);
+    return self->priv->filename;
 }
diff '--exclude=.git' -urN a/src/compositor/meta-surface-actor-wayland.c b/src/compositor/meta-surface-actor-wayland.c
--- a/src/compositor/meta-surface-actor-wayland.c	2015-10-30 16:39:40.964006704 -0400
+++ b/src/compositor/meta-surface-actor-wayland.c	2015-10-31 10:07:14.331539901 -0400
@@ -175,23 +175,6 @@
     }
 }
 
-void
-meta_surface_actor_wayland_sync_state_recursive (MetaSurfaceActorWayland *self)
-{
-  MetaWaylandSurface *surface = meta_surface_actor_wayland_get_surface (self);
-  GList *iter;
-
-  meta_surface_actor_wayland_sync_state (self);
-
-  for (iter = surface->subsurfaces; iter != NULL; iter = iter->next)
-    {
-      MetaWaylandSurface *subsurf = iter->data;
-
-      meta_surface_actor_wayland_sync_state_recursive (
-        META_SURFACE_ACTOR_WAYLAND (subsurf->surface_actor));
-    }
-}
-
 static MetaWindow *
 meta_surface_actor_wayland_get_window (MetaSurfaceActor *actor)
 {
diff '--exclude=.git' -urN a/src/compositor/meta-surface-actor-wayland.h b/src/compositor/meta-surface-actor-wayland.h
--- a/src/compositor/meta-surface-actor-wayland.h	2015-10-30 16:39:40.964006704 -0400
+++ b/src/compositor/meta-surface-actor-wayland.h	2015-10-31 10:07:14.331539901 -0400
@@ -65,8 +65,6 @@
 
 void meta_surface_actor_wayland_sync_state (MetaSurfaceActorWayland *self);
 
-void meta_surface_actor_wayland_sync_state_recursive (MetaSurfaceActorWayland *self);
-
 G_END_DECLS
 
 #endif /* __META_SURFACE_ACTOR_WAYLAND_H__ */
diff '--exclude=.git' -urN a/src/compositor/plugins/default.c b/src/compositor/plugins/default.c
--- a/src/compositor/plugins/default.c	2015-10-30 16:39:40.965006700 -0400
+++ b/src/compositor/plugins/default.c	2015-10-31 11:13:25.295109059 -0400
@@ -303,16 +303,15 @@
   for (i = 0; i < n; i++)
     {
       MetaRectangle rect;
-      ClutterActor *background_actor;
-      MetaBackground *background;
+      ClutterActor *background;
       ClutterColor color;
 
       meta_screen_get_monitor_geometry (screen, i, &rect);
 
-      background_actor = meta_background_actor_new (screen, i);
+      background = meta_background_actor_new ();
 
-      clutter_actor_set_position (background_actor, rect.x, rect.y);
-      clutter_actor_set_size (background_actor, rect.width, rect.height);
+      clutter_actor_set_position (background, rect.x, rect.y);
+      clutter_actor_set_size (background, rect.width, rect.height);
 
       /* Don't use rand() here, mesa calls srand() internally when
          parsing the driconf XML, but it's nice if the colors are
@@ -323,13 +322,9 @@
                           g_rand_int_range (rand, 0, 255),
                           g_rand_int_range (rand, 0, 255),
                           255);
+      clutter_actor_set_background_color (background, &color);
 
-      background = meta_background_new (screen);
-      meta_background_set_color (background, &color);
-      meta_background_actor_set_background (META_BACKGROUND_ACTOR (background_actor), background);
-      g_object_unref (background);
-
-      clutter_actor_add_child (self->priv->background_group, background_actor);
+      clutter_actor_add_child (self->priv->background_group, background);
     }
 
   g_rand_free (rand);
diff '--exclude=.git' -urN a/src/core/core.c b/src/core/core.c
--- a/src/core/core.c	2015-10-30 16:39:40.965006700 -0400
+++ b/src/core/core.c	2015-10-31 10:11:44.909006930 -0400
@@ -63,6 +63,84 @@
 }
 
 void
+meta_core_get (Display *xdisplay,
+    Window xwindow,
+    ...)
+{
+  va_list args;
+  MetaCoreGetType request;
+
+  MetaDisplay *display = meta_display_for_x_display (xdisplay);
+  MetaWindow *window = meta_display_lookup_x_window (display, xwindow);
+  MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
+  MetaWindowX11Private *priv = window_x11->priv;
+
+  va_start (args, xwindow);
+
+  request = va_arg (args, MetaCoreGetType);
+
+  /* Now, we special-case the first request slightly. Mostly, requests
+   * for information on windows which have no frame are errors.
+   * But sometimes we may want to know *whether* a window has a frame.
+   * In this case, pass the key META_CORE_WINDOW_HAS_FRAME
+   * as the *first* request, with a pointer to a boolean; if the window
+   * has no frame, this will be set to False and meta_core_get will
+   * exit immediately (so the values of any other requests will be
+   * undefined). Otherwise it will be set to True and meta_core_get will
+   * continue happily on its way.
+   */
+
+  if (request != META_CORE_WINDOW_HAS_FRAME &&
+      (window == NULL || window->frame == NULL))
+    {
+      meta_bug ("No such frame window 0x%lx!\n", xwindow);
+      goto out;
+    }
+
+  while (request != META_CORE_GET_END)
+    {
+      gpointer answer = va_arg (args, gpointer);
+
+      switch (request)
+        {
+        case META_CORE_WINDOW_HAS_FRAME:
+          *((gboolean*)answer) = window != NULL && window->frame != NULL;
+          if (!*((gboolean*)answer)) goto out; /* see above */
+          break;
+        case META_CORE_GET_CLIENT_WIDTH:
+          *((gint*)answer) = priv->client_rect.width;
+          break;
+        case META_CORE_GET_CLIENT_HEIGHT:
+          *((gint*)answer) = priv->client_rect.height;
+          break;
+        case META_CORE_GET_FRAME_FLAGS:
+          *((MetaFrameFlags*)answer) = meta_frame_get_flags (window->frame);
+          break;
+        case META_CORE_GET_FRAME_TYPE:
+          *((MetaFrameType*)answer) = meta_window_get_frame_type (window);
+          break;
+        case META_CORE_GET_MINI_ICON:
+          *((GdkPixbuf**)answer) = window->mini_icon;
+          break;
+        case META_CORE_GET_FRAME_RECT:
+          meta_window_get_frame_rect (window, ((MetaRectangle*)answer));
+          break;
+        case META_CORE_GET_THEME_VARIANT:
+          *((char**)answer) = window->gtk_theme_variant;
+          break;
+
+        default:
+          meta_warning("Unknown window information request: %d\n", request);
+        }
+
+      request = va_arg (args, MetaCoreGetType);
+    }
+
+ out:
+  va_end (args);
+}
+
+void
 meta_core_queue_frame_resize (Display *xdisplay,
                               Window   frame_xwindow)
 {
@@ -128,6 +206,37 @@
 }
 
 void
+meta_core_user_focus (Display *xdisplay,
+                      Window   frame_xwindow,
+                      guint32  timestamp)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  meta_window_focus (window, timestamp);
+}
+
+void
+meta_core_minimize (Display *xdisplay,
+                    Window   frame_xwindow)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  meta_window_minimize (window);
+}
+
+void
+meta_core_maximize (Display *xdisplay,
+                    Window   frame_xwindow)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  if (meta_prefs_get_raise_on_click ())
+    meta_window_raise (window);
+
+  meta_window_maximize (window, META_MAXIMIZE_BOTH);
+}
+
+void
 meta_core_toggle_maximize_vertically (Display *xdisplay,
 				      Window   frame_xwindow)
 {
@@ -173,6 +282,84 @@
 }
 
 void
+meta_core_unmaximize (Display *xdisplay,
+                      Window   frame_xwindow)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  if (meta_prefs_get_raise_on_click ())
+    meta_window_raise (window);
+
+  meta_window_unmaximize (window, META_MAXIMIZE_BOTH);
+}
+
+void
+meta_core_delete (Display *xdisplay,
+                  Window   frame_xwindow,
+                  guint32  timestamp)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  meta_window_delete (window, timestamp);
+}
+
+void
+meta_core_unshade (Display *xdisplay,
+                   Window   frame_xwindow,
+                   guint32  timestamp)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  meta_window_unshade (window, timestamp);
+}
+
+void
+meta_core_shade (Display *xdisplay,
+                 Window   frame_xwindow,
+                 guint32  timestamp)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  meta_window_shade (window, timestamp);
+}
+
+void
+meta_core_unstick (Display *xdisplay,
+                   Window   frame_xwindow)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  meta_window_unstick (window);
+}
+
+void
+meta_core_make_above (Display *xdisplay,
+                      Window   frame_xwindow)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  meta_window_make_above (window);
+}
+
+void
+meta_core_unmake_above (Display *xdisplay,
+                        Window   frame_xwindow)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  meta_window_unmake_above (window);
+}
+
+void
+meta_core_stick (Display *xdisplay,
+                 Window   frame_xwindow)
+{
+  MetaWindow *window = get_window (xdisplay, frame_xwindow);
+
+  meta_window_stick (window);
+}
+
+void
 meta_core_change_workspace (Display *xdisplay,
                             Window   frame_xwindow,
                             int      new_workspace)
diff '--exclude=.git' -urN a/src/core/core.h b/src/core/core.h
--- a/src/core/core.h	2015-10-30 16:39:40.965006700 -0400
+++ b/src/core/core.h	2015-10-31 09:14:14.503466238 -0400
@@ -28,6 +28,58 @@
 #include <meta/common.h>
 #include <meta/boxes.h>
 
+typedef enum
+{
+  META_CORE_GET_END = 0,
+  META_CORE_WINDOW_HAS_FRAME,
+  META_CORE_GET_CLIENT_WIDTH,
+  META_CORE_GET_CLIENT_HEIGHT,
+  META_CORE_GET_FRAME_FLAGS,
+  META_CORE_GET_FRAME_TYPE,
+  META_CORE_GET_MINI_ICON,
+  META_CORE_GET_FRAME_RECT,
+  META_CORE_GET_THEME_VARIANT,
+} MetaCoreGetType;
+
+/* General information function about the given window. Pass in a sequence of
+ * pairs of MetaCoreGetTypes and pointers to variables; the variables will be
+ * filled with the requested values. End the list with META_CORE_GET_END.
+ * For example:
+ *
+ *   meta_core_get (my_display, my_window,
+ *                  META_CORE_GET_FRAME_RECT, &rect,
+ *                  META_CORE_GET_END);
+ *
+ * If the window doesn't have a frame, this will raise a meta_bug. To suppress
+ * this behaviour, ask META_CORE_WINDOW_HAS_FRAME as the *first* question in
+ * the list. If the window has no frame, the answer to this question will be
+ * False, and anything else you asked will be undefined. Otherwise, the answer
+ * will be True. The answer will necessarily be True if you ask the question
+ * in any other position. The positions of all other questions don't matter.
+ *
+ * The reason for this function is that some parts of the program don't know
+ * about MetaWindows. But they *can* see core.h. So we used to have a whole
+ * load of functions which took a display and an X window, looked up the
+ * relevant MetaWindow, and returned information about it. The trouble with
+ * that is that looking up the MetaWindow is a nontrivial operation, and
+ * consolidating the calls in this way makes (for example) frame exposes
+ * 33% faster, according to valgrind.
+ *
+ * This function would perhaps be slightly better if the questions were
+ * represented by pointers, perhaps gchar*s, because then we could take
+ * advantage of gcc's automatic sentinel checking. On the other hand, this
+ * immediately suggests string comparison, and that's slow.
+ *
+ * Another possible improvement is that core.h still has a bunch of
+ * functions which can't be described by the formula "give a display and
+ * an X window, get a single value" (meta_core_user_move, for example), but
+ * which could theoretically be handled by this function if we relaxed the
+ * requirement that all questions should have exactly one argument.
+ */
+void meta_core_get (Display *xdisplay,
+                    Window window,
+                    ...);
+
 void meta_core_queue_frame_resize (Display *xdisplay,
                                    Window frame_xwindow);
 
@@ -35,12 +87,39 @@
                                        Window   frame_xwindow,
                                        guint32  timestamp);
 
+void meta_core_user_focus   (Display *xdisplay,
+                             Window   frame_xwindow,
+                             guint32  timestamp);
+
+void meta_core_minimize         (Display *xdisplay,
+                                 Window   frame_xwindow);
 void meta_core_toggle_maximize  (Display *xdisplay,
                                  Window   frame_xwindow);
 void meta_core_toggle_maximize_horizontally  (Display *xdisplay,
                                               Window   frame_xwindow);
 void meta_core_toggle_maximize_vertically    (Display *xdisplay,
                                               Window   frame_xwindow);
+void meta_core_unmaximize       (Display *xdisplay,
+                                 Window   frame_xwindow);
+void meta_core_maximize         (Display *xdisplay,
+                                 Window   frame_xwindow);
+void meta_core_delete           (Display *xdisplay,
+                                 Window   frame_xwindow,
+                                 guint32  timestamp);
+void meta_core_unshade          (Display *xdisplay,
+                                 Window   frame_xwindow,
+                                 guint32  timestamp);
+void meta_core_shade            (Display *xdisplay,
+                                 Window   frame_xwindow,
+                                 guint32  timestamp);
+void meta_core_unstick          (Display *xdisplay,
+                                 Window   frame_xwindow);
+void meta_core_stick            (Display *xdisplay,
+                                 Window   frame_xwindow);
+void meta_core_unmake_above     (Display *xdisplay,
+                                 Window   frame_xwindow);
+void meta_core_make_above       (Display *xdisplay,
+                                 Window   frame_xwindow);
 void meta_core_change_workspace (Display *xdisplay,
                                  Window   frame_xwindow,
                                  int      new_workspace);
diff '--exclude=.git' -urN a/src/core/display-private.h b/src/core/display-private.h
--- a/src/core/display-private.h	2015-10-30 16:39:40.965006700 -0400
+++ b/src/core/display-private.h	2015-10-31 09:08:02.011561264 -0400
@@ -85,10 +85,6 @@
    * Events go to windows normally. */
   META_EVENT_ROUTE_NORMAL,
 
-  /* In a window operation like moving or resizing. All events
-   * goes to MetaWindow, but not to the actual client window. */
-  META_EVENT_ROUTE_WINDOW_OP,
-
   /* In a compositor grab operation. All events go to the
    * compositor plugin. */
   META_EVENT_ROUTE_COMPOSITOR_GRAB,
@@ -97,8 +93,9 @@
    * the Wayland application. */
   META_EVENT_ROUTE_WAYLAND_POPUP,
 
-  /* The user is clicking on a window button. */
-  META_EVENT_ROUTE_FRAME_BUTTON,
+  /* In a window operation like moving or resizing. All events
+   * goes to MetaWindow, but not to the actual client window. */
+  META_EVENT_ROUTE_WINDOW_OP,
 } MetaEventRoute;
 
 typedef gboolean (*MetaAlarmFilter) (MetaDisplay           *display,
@@ -480,12 +477,6 @@
                                             const char  *message);
 gboolean meta_display_request_restart      (MetaDisplay *display);
 
-gboolean meta_display_show_resize_popup (MetaDisplay *display,
-                                         gboolean show,
-                                         MetaRectangle *rect,
-                                         int display_w,
-                                         int display_h);
-
 void meta_restart_init (void);
 void meta_restart_finish (void);
 
diff '--exclude=.git' -urN a/src/core/display.c b/src/core/display.c
--- a/src/core/display.c	2015-10-30 16:39:40.967006692 -0400
+++ b/src/core/display.c	2015-10-31 09:08:02.010561269 -0400
@@ -124,7 +124,6 @@
   GRAB_OP_END,
   SHOW_RESTART_MESSAGE,
   RESTART,
-  SHOW_RESIZE_POPUP,
   LAST_SIGNAL
 };
 
@@ -332,16 +331,6 @@
                   NULL, NULL,
                   G_TYPE_BOOLEAN, 0);
 
-  display_signals[SHOW_RESIZE_POPUP] =
-    g_signal_new ("show-resize-popup",
-                  G_TYPE_FROM_CLASS (klass),
-                  G_SIGNAL_RUN_LAST,
-                  0,
-                  g_signal_accumulator_true_handled,
-                  NULL, NULL,
-                  G_TYPE_BOOLEAN, 4,
-                  G_TYPE_BOOLEAN, META_TYPE_RECTANGLE, G_TYPE_INT, G_TYPE_INT);
-
   g_object_class_install_property (object_class,
                                    PROP_FOCUS_WINDOW,
                                    g_param_spec_object ("focus-window",
@@ -1806,9 +1795,6 @@
     case META_GRAB_OP_WAYLAND_POPUP:
       return META_EVENT_ROUTE_WAYLAND_POPUP;
 
-    case META_GRAB_OP_FRAME_BUTTON:
-      return META_EVENT_ROUTE_FRAME_BUTTON;
-
     default:
       g_assert_not_reached ();
     }
@@ -3048,22 +3034,6 @@
 
   return result;
 }
-
-gboolean
-meta_display_show_resize_popup (MetaDisplay *display,
-                                gboolean show,
-                                MetaRectangle *rect,
-                                int display_w,
-                                int display_h)
-{
-  gboolean result = FALSE;
-
-  g_signal_emit (display,
-                 display_signals[SHOW_RESIZE_POPUP], 0,
-                 show, rect, display_w, display_h, &result);
-
-  return result;
-}
 
 /**
  * meta_display_is_pointer_emulating_sequence:
diff '--exclude=.git' -urN a/src/core/events.c b/src/core/events.c
--- a/src/core/events.c	2015-10-30 16:39:40.967006692 -0400
+++ b/src/core/events.c	2015-10-31 09:08:02.007561286 -0400
@@ -66,10 +66,9 @@
         else
           return NULL;
       }
+    case META_EVENT_ROUTE_WAYLAND_POPUP:
     case META_EVENT_ROUTE_WINDOW_OP:
     case META_EVENT_ROUTE_COMPOSITOR_GRAB:
-    case META_EVENT_ROUTE_WAYLAND_POPUP:
-    case META_EVENT_ROUTE_FRAME_BUTTON:
       return display->grab_window;
     default:
       g_assert_not_reached ();
@@ -281,8 +280,7 @@
        * event, and if it doesn't, replay the event to release our
        * own sync grab. */
 
-      if (display->event_route == META_EVENT_ROUTE_WINDOW_OP ||
-          display->event_route == META_EVENT_ROUTE_FRAME_BUTTON)
+      if (display->event_route == META_EVENT_ROUTE_WINDOW_OP)
         {
           bypass_clutter = TRUE;
           bypass_wayland = TRUE;
diff '--exclude=.git' -urN a/src/core/frame.c b/src/core/frame.c
--- a/src/core/frame.c	2015-06-13 23:59:51.988809000 -0400
+++ b/src/core/frame.c	2015-10-31 09:55:44.590451314 -0400
@@ -37,6 +37,7 @@
 {
   MetaFrame *frame;
   XSetWindowAttributes attrs;
+  Visual *visual;
   gulong create_serial;
 
   if (window->frame)
@@ -57,22 +58,42 @@
   frame->is_flashing = FALSE;
   frame->borders_cached = FALSE;
 
+  meta_verbose ("Framing window %s: visual %s default, depth %d default depth %d\n",
+                window->desc,
+                XVisualIDFromVisual (window->xvisual) ==
+                XVisualIDFromVisual (window->screen->default_xvisual) ?
+                "is" : "is not",
+                window->depth, window->screen->default_depth);
   meta_verbose ("Frame geometry %d,%d  %dx%d\n",
                 frame->rect.x, frame->rect.y,
                 frame->rect.width, frame->rect.height);
 
-  frame->ui_frame = meta_ui_create_frame (window->screen->ui,
-                                          window->display->xdisplay,
-                                          frame->window,
-                                          window->xvisual,
-                                          frame->rect.x,
-                                          frame->rect.y,
-                                          frame->rect.width,
-                                          frame->rect.height,
-                                          frame->window->screen->number,
-                                          &create_serial);
-  frame->xwindow = frame->ui_frame->xwindow;
+  /* Default depth/visual handles clients with weird visuals; they can
+   * always be children of the root depth/visual obviously, but
+   * e.g. DRI games can't be children of a parent that has the same
+   * visual as the client. NULL means default visual.
+   *
+   * We look for an ARGB visual if we can find one, otherwise use
+   * the default of NULL.
+   */
 
+  /* Special case for depth 32 windows (assumed to be ARGB),
+   * we use the window's visual. Otherwise we just use the system visual.
+   */
+  if (window->depth == 32)
+    visual = window->xvisual;
+  else
+    visual = NULL;
+
+  frame->xwindow = meta_ui_create_frame_window (window->screen->ui,
+                                                window->display->xdisplay,
+                                                visual,
+                                                frame->rect.x,
+                                                frame->rect.y,
+						frame->rect.width,
+						frame->rect.height,
+						frame->window->screen->number,
+                                                &create_serial);
   meta_stack_tracker_record_add (window->screen->stack_tracker,
                                  frame->xwindow,
                                  create_serial);
@@ -82,6 +103,19 @@
   XChangeWindowAttributes (window->display->xdisplay,
 			   frame->xwindow, CWEventMask, &attrs);
 
+  {
+    unsigned char mask_bits[XIMaskLen (XI_LASTEVENT)] = { 0 };
+    XIEventMask mask = { XIAllMasterDevices, sizeof (mask_bits), mask_bits };
+
+    XISetMask (mask.mask, XI_ButtonPress);
+    XISetMask (mask.mask, XI_ButtonRelease);
+    XISetMask (mask.mask, XI_Motion);
+    XISetMask (mask.mask, XI_Enter);
+    XISetMask (mask.mask, XI_Leave);
+
+    XISelectEvents (window->display->xdisplay, frame->xwindow, &mask, 1);
+  }
+
   meta_display_register_x_window (window->display, &frame->xwindow, window);
 
   meta_error_trap_push (window->display);
@@ -121,26 +155,10 @@
     MetaBackend *backend = meta_get_backend ();
     if (META_IS_BACKEND_X11 (backend))
       {
-        Display *xdisplay = meta_backend_x11_get_xdisplay (META_BACKEND_X11 (backend));
-
-        /* Since the backend selects for events on another connection,
-         * make sure to sync the GTK+ connection to ensure that the
-         * frame window has been created on the server at this point. */
+        /* Since the backend takes keygrabs on another connection, make sure
+         * to sync the GTK+ connection to ensure that the frame window has
+         * been created on the server at this point. */
         XSync (window->display->xdisplay, False);
-
-        unsigned char mask_bits[XIMaskLen (XI_LASTEVENT)] = { 0 };
-        XIEventMask mask = { XIAllMasterDevices, sizeof (mask_bits), mask_bits };
-
-        XISelectEvents (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                        frame->xwindow, &mask, 1);
-
-        XISetMask (mask.mask, XI_ButtonPress);
-        XISetMask (mask.mask, XI_ButtonRelease);
-        XISetMask (mask.mask, XI_Motion);
-        XISetMask (mask.mask, XI_Enter);
-        XISetMask (mask.mask, XI_Leave);
-
-        XISelectEvents (xdisplay, frame->xwindow, &mask, 1);
       }
   }
 
@@ -193,7 +211,7 @@
                    window->frame->rect.y + borders.invisible.top);
   meta_error_trap_pop (window->display);
 
-  meta_ui_frame_unmanage (frame->ui_frame);
+  meta_ui_destroy_frame_window (window->screen->ui, frame->xwindow);
 
   meta_display_unregister_x_window (window->display,
                                     frame->xwindow);
@@ -313,7 +331,9 @@
     {
       if (!frame->borders_cached)
         {
-          meta_ui_frame_get_borders (frame->ui_frame, &frame->cached_borders);
+          meta_ui_get_frame_borders (frame->window->screen->ui,
+                                     frame->xwindow,
+                                     &frame->cached_borders);
           frame->borders_cached = TRUE;
         }
 
@@ -338,32 +358,49 @@
               frame->rect.x + frame->rect.width,
               frame->rect.y + frame->rect.height);
 
-  meta_ui_frame_move_resize (frame->ui_frame,
+  meta_ui_move_resize_frame (frame->window->screen->ui,
+			     frame->xwindow,
 			     frame->rect.x,
 			     frame->rect.y,
 			     frame->rect.width,
 			     frame->rect.height);
 
+  if (need_resize)
+    {
+      /* If we're interactively resizing the frame, repaint
+       * it immediately so we don't start to lag.
+       */
+      if (frame->window->display->grab_window ==
+          frame->window)
+        meta_ui_repaint_frame (frame->window->screen->ui,
+                               frame->xwindow);
+    }
+
   return need_resize;
 }
 
 cairo_region_t *
 meta_frame_get_frame_bounds (MetaFrame *frame)
 {
-  return meta_ui_frame_get_bounds (frame->ui_frame);
+  return meta_ui_get_frame_bounds (frame->window->screen->ui,
+                                   frame->xwindow,
+                                   frame->rect.width,
+                                   frame->rect.height);
 }
 
 void
 meta_frame_get_mask (MetaFrame                    *frame,
                      cairo_t                      *cr)
 {
-  meta_ui_frame_get_mask (frame->ui_frame, cr);
+  meta_ui_get_frame_mask (frame->window->screen->ui, frame->xwindow,
+                          frame->rect.width, frame->rect.height, cr);
 }
 
 void
 meta_frame_queue_draw (MetaFrame *frame)
 {
-  meta_ui_frame_queue_draw (frame->ui_frame);
+  meta_ui_queue_frame_draw (frame->window->screen->ui,
+                            frame->xwindow);
 }
 
 void
@@ -394,12 +431,12 @@
 void
 meta_frame_update_style (MetaFrame *frame)
 {
-  meta_ui_frame_update_style (frame->ui_frame);
+  meta_ui_update_frame_style (frame->window->screen->ui, frame->xwindow);
 }
 
 void
 meta_frame_update_title (MetaFrame *frame)
 {
   if (frame->window->title)
-    meta_ui_frame_set_title (frame->ui_frame, frame->window->title);
+    meta_ui_set_frame_title (frame->window->screen->ui, frame->xwindow, frame->window->title);
 }
diff '--exclude=.git' -urN a/src/core/frame.h b/src/core/frame.h
--- a/src/core/frame.h	2015-06-13 23:59:51.988809000 -0400
+++ b/src/core/frame.h	2015-10-31 09:55:44.590451314 -0400
@@ -24,8 +24,6 @@
 
 #include "window-private.h"
 
-#include "ui/frames.h"
-
 struct _MetaFrame
 {
   /* window we frame */
@@ -52,8 +50,6 @@
   guint need_reapply_frame_shape : 1;
   guint is_flashing : 1; /* used by the visual bell flash */
   guint borders_cached : 1;
-
-  MetaUIFrame *ui_frame;
 };
 
 void     meta_window_ensure_frame           (MetaWindow *window);
diff '--exclude=.git' -urN a/src/core/prefs.c b/src/core/prefs.c
--- a/src/core/prefs.c	2015-10-30 16:39:40.968006687 -0400
+++ b/src/core/prefs.c	2015-10-31 10:42:33.164533699 -0400
@@ -82,6 +82,7 @@
 static gboolean raise_on_click = TRUE;
 static gboolean center_new_windows = FALSE;
 static gboolean attach_modal_dialogs = FALSE;
+static char* current_theme = NULL;
 static int num_workspaces = 4;
 static GDesktopTitlebarAction action_double_click_titlebar = G_DESKTOP_TITLEBAR_ACTION_TOGGLE_MAXIMIZE;
 static GDesktopTitlebarAction action_middle_click_titlebar = G_DESKTOP_TITLEBAR_ACTION_LOWER;
@@ -143,6 +144,7 @@
 static void maybe_give_disable_workarounds_warning (void);
 
 static gboolean titlebar_handler (GVariant*, gpointer*, gpointer);
+static gboolean theme_name_handler (GVariant*, gpointer*, gpointer);
 static gboolean mouse_button_mods_handler (GVariant*, gpointer*, gpointer);
 static gboolean button_layout_handler (GVariant*, gpointer*, gpointer);
 static gboolean overlay_key_handler (GVariant*, gpointer*, gpointer);
@@ -400,6 +402,14 @@
       NULL,
     },
     {
+      { "theme",
+        SCHEMA_GENERAL,
+        META_PREF_THEME,
+      },
+      theme_name_handler,
+      NULL,
+    },
+    {
       { KEY_TITLEBAR_FONT,
         SCHEMA_GENERAL,
         META_PREF_TITLEBAR_FONT,
@@ -1300,6 +1310,12 @@
 }
 
 const char*
+meta_prefs_get_theme (void)
+{
+  return current_theme;
+}
+
+const char*
 meta_prefs_get_cursor_theme (void)
 {
   return cursor_theme;
@@ -1356,6 +1372,29 @@
 }
 
 static gboolean
+theme_name_handler (GVariant *value,
+                    gpointer *result,
+                    gpointer  data)
+{
+  const gchar *string_value;
+
+  *result = NULL; /* ignored */
+  string_value = g_variant_get_string (value, NULL);
+
+  if (!string_value || !*string_value)
+    return FALSE;
+
+  if (g_strcmp0 (current_theme, string_value) != 0)
+    {
+      g_free (current_theme);
+      current_theme = g_strdup (string_value);
+      queue_changed (META_PREF_THEME);
+    }
+
+  return TRUE;
+}
+
+static gboolean
 mouse_button_mods_handler (GVariant *value,
                            gpointer *result,
                            gpointer  data)
@@ -1778,6 +1817,9 @@
     case META_PREF_RAISE_ON_CLICK:
       return "RAISE_ON_CLICK";
 
+    case META_PREF_THEME:
+      return "THEME";
+
     case META_PREF_TITLEBAR_FONT:
       return "TITLEBAR_FONT";
 
diff '--exclude=.git' -urN a/src/core/window-private.h b/src/core/window-private.h
--- a/src/core/window-private.h	2015-10-30 16:39:40.970006679 -0400
+++ b/src/core/window-private.h	2015-10-31 10:11:44.931006805 -0400
@@ -106,8 +106,8 @@
   char *desc; /* used in debug spew */
   char *title;
 
-  cairo_surface_t *icon;
-  cairo_surface_t *mini_icon;
+  GdkPixbuf *icon;
+  GdkPixbuf *mini_icon;
 
   MetaWindowType type;
 
@@ -475,11 +475,9 @@
   void (*get_default_skip_hints) (MetaWindow *window,
                                   gboolean   *skip_taskbar_out,
                                   gboolean   *skip_pager_out);
-  gboolean (*update_icon)        (MetaWindow       *window,
-                                  cairo_surface_t **icon,
-                                  cairo_surface_t **mini_icon);
-  void (*main_monitor_changed)   (MetaWindow *window,
-                                  const MetaMonitorInfo *old);
+  gboolean (*update_icon)        (MetaWindow  *window,
+                                  GdkPixbuf  **icon,
+                                  GdkPixbuf  **mini_icon);
 };
 
 /* These differ from window->has_foo_func in that they consider
diff '--exclude=.git' -urN a/src/core/window.c b/src/core/window.c
--- a/src/core/window.c	2015-10-30 16:39:40.970006679 -0400
+++ b/src/core/window.c	2015-10-31 10:11:44.930006811 -0400
@@ -245,9 +245,9 @@
 }
 
 static gboolean
-meta_window_real_update_icon (MetaWindow       *window,
-                              cairo_surface_t **icon,
-                              cairo_surface_t **mini_icon)
+meta_window_real_update_icon (MetaWindow  *window,
+                              GdkPixbuf  **icon,
+                              GdkPixbuf  **mini_icon)
 {
   *icon = NULL;
   *mini_icon = NULL;
@@ -260,10 +260,10 @@
   MetaWindow *window = META_WINDOW (object);
 
   if (window->icon)
-    cairo_surface_destroy (window->icon);
+    g_object_unref (G_OBJECT (window->icon));
 
   if (window->mini_icon)
-    cairo_surface_destroy (window->mini_icon);
+    g_object_unref (G_OBJECT (window->mini_icon));
 
   if (window->frame_bounds)
     cairo_region_destroy (window->frame_bounds);
@@ -762,20 +762,6 @@
     window->desc = g_strdup_printf ("0x%lx", window->xwindow);
 }
 
-static void
-meta_window_main_monitor_changed (MetaWindow *window,
-                                  const MetaMonitorInfo *old)
-{
-  META_WINDOW_GET_CLASS (window)->main_monitor_changed (window, old);
-
-  if (old)
-    g_signal_emit_by_name (window->screen, "window-left-monitor",
-                           old->number, window);
-  if (window->monitor)
-    g_signal_emit_by_name (window->screen, "window-entered-monitor",
-                           window->monitor->number, window);
-}
-
 MetaWindow *
 _meta_window_shared_new (MetaDisplay         *display,
                          MetaScreen          *screen,
@@ -1142,7 +1128,7 @@
       meta_window_update_struts (window);
     }
 
-  meta_window_main_monitor_changed (window, NULL);
+  g_signal_emit_by_name (window->screen, "window-entered-monitor", window->monitor->number, window);
 
   /* Must add window to stack before doing move/resize, since the
    * window might have fullscreen size (i.e. should have been
@@ -1383,10 +1369,9 @@
 
   if (window->monitor)
     {
-      const MetaMonitorInfo *old = window->monitor;
-
+      g_signal_emit_by_name (window->screen, "window-left-monitor",
+                             window->monitor->number, window);
       window->monitor = NULL;
-      meta_window_main_monitor_changed (window, old);
     }
 
   if (!window->override_redirect)
@@ -3583,7 +3568,9 @@
           window->screen->active_workspace != window->workspace)
         meta_window_change_workspace (window, window->screen->active_workspace);
 
-      meta_window_main_monitor_changed (window, old);
+      if (old)
+        g_signal_emit_by_name (window->screen, "window-left-monitor", old->number, window);
+      g_signal_emit_by_name (window->screen, "window-entered-monitor", window->monitor->number, window);
 
       /* If we're changing monitors, we need to update the has_maximize_func flag,
        * as the working area has changed. */
@@ -4881,11 +4868,10 @@
     meta_frame_queue_draw (window->frame);
 }
 
-static cairo_surface_t *
+static GdkPixbuf *
 load_default_window_icon (int size)
 {
   GtkIconTheme *theme = gtk_icon_theme_get_default ();
-  GdkPixbuf *pixbuf;
   const char *icon_name;
 
   if (gtk_icon_theme_has_icon (theme, META_DEFAULT_ICON_NAME))
@@ -4893,14 +4879,13 @@
   else
     icon_name = "image-missing";
 
-  pixbuf = gtk_icon_theme_load_icon (theme, icon_name, size, 0, NULL);
-  return gdk_cairo_surface_create_from_pixbuf (pixbuf, 1, NULL);
+  return gtk_icon_theme_load_icon (theme, icon_name, size, 0, NULL);
 }
 
-static cairo_surface_t *
+static GdkPixbuf *
 get_default_window_icon (void)
 {
-  static cairo_surface_t *default_icon = NULL;
+  static GdkPixbuf *default_icon = NULL;
 
   if (default_icon == NULL)
     {
@@ -4908,13 +4893,13 @@
       g_assert (default_icon);
     }
 
-  return cairo_surface_reference (default_icon);
+  return g_object_ref (default_icon);
 }
 
-static cairo_surface_t *
+static GdkPixbuf *
 get_default_mini_icon (void)
 {
-  static cairo_surface_t *default_icon = NULL;
+  static GdkPixbuf *default_icon = NULL;
 
   if (default_icon == NULL)
     {
@@ -4922,7 +4907,7 @@
       g_assert (default_icon);
     }
 
-  return cairo_surface_reference (default_icon);
+  return g_object_ref (default_icon);
 }
 
 static void
@@ -4930,8 +4915,8 @@
                              gboolean    force)
 {
   gboolean changed;
-  cairo_surface_t *icon = NULL;
-  cairo_surface_t *mini_icon;
+  GdkPixbuf *icon = NULL;
+  GdkPixbuf *mini_icon;
 
   g_return_if_fail (!window->override_redirect);
 
@@ -4940,14 +4925,14 @@
   if (changed || force)
     {
       if (window->icon)
-        cairo_surface_destroy (window->icon);
+        g_object_unref (window->icon);
       if (icon)
         window->icon = icon;
       else
         window->icon = get_default_window_icon ();
 
       if (window->mini_icon)
-        cairo_surface_destroy (window->mini_icon);
+        g_object_unref (window->mini_icon);
       if (mini_icon)
         window->mini_icon = mini_icon;
       else
@@ -7767,9 +7752,6 @@
   gboolean unmodified;
   gboolean is_window_grab;
 
-  if (window->frame && meta_ui_frame_handle_event (window->frame->ui_frame, event))
-    return;
-
   if (event->type != CLUTTER_BUTTON_PRESS)
     return;
 
diff '--exclude=.git' -urN a/src/meta/common.h b/src/meta/common.h
--- a/src/meta/common.h	2015-10-30 16:39:40.971006675 -0400
+++ b/src/meta/common.h	2015-10-31 09:08:01.996561348 -0400
@@ -152,17 +152,14 @@
 {
   META_GRAB_OP_NONE,
 
-  /* Window grab ops. */
-  META_GRAB_OP_WINDOW_BASE,
-
   /* Special grab op when the compositor asked for a grab */
   META_GRAB_OP_COMPOSITOR,
 
-  /* For when a Wayland client takes a popup grab. */
+  /* For when a Wayland client takes a popup grab */
   META_GRAB_OP_WAYLAND_POPUP,
 
-  /* For when the user clicks on a frame button. */
-  META_GRAB_OP_FRAME_BUTTON,
+  /* Window grab ops. */
+  META_GRAB_OP_WINDOW_BASE,
 
   META_GRAB_OP_MOVING                     = META_GRAB_OP_WINDOW_BASE,
   META_GRAB_OP_RESIZING_NW                = META_GRAB_OP_WINDOW_BASE | _WGO_N | _WGO_W,
diff '--exclude=.git' -urN a/src/meta/gradient.h b/src/meta/gradient.h
--- a/src/meta/gradient.h	1969-12-31 19:00:00.000000000 -0500
+++ b/src/meta/gradient.h	2015-10-31 13:33:56.668252083 -0400
@@ -0,0 +1,71 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* Mutter gradient rendering */
+
+/*
+ * Copyright (C) 2001 Havoc Pennington, 99% copied from wrlib in
+ * WindowMaker, Copyright (C) 1997-2000 Dan Pascu and Alfredo Kojima
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef META_GRADIENT_H
+#define META_GRADIENT_H
+
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include <gdk/gdk.h>
+
+/**
+ * MetaGradientType:
+ * @META_GRADIENT_VERTICAL: Vertical gradient
+ * @META_GRADIENT_HORIZONTAL: Horizontal gradient
+ * @META_GRADIENT_DIAGONAL: Diagonal gradient
+ * @META_GRADIENT_LAST: Marks the end of the #MetaGradientType enumeration
+ *
+ */
+typedef enum
+{
+  META_GRADIENT_VERTICAL,
+  META_GRADIENT_HORIZONTAL,
+  META_GRADIENT_DIAGONAL,
+  META_GRADIENT_LAST
+} MetaGradientType;
+
+GdkPixbuf* meta_gradient_create_simple     (int               width,
+                                            int               height,
+                                            const GdkRGBA    *from,
+                                            const GdkRGBA    *to,
+                                            MetaGradientType  style);
+GdkPixbuf* meta_gradient_create_multi      (int               width,
+                                            int               height,
+                                            const GdkRGBA    *colors,
+                                            int               n_colors,
+                                            MetaGradientType  style);
+GdkPixbuf* meta_gradient_create_interwoven (int               width,
+                                            int               height,
+                                            const GdkRGBA     colors1[2],
+                                            int               thickness1,
+                                            const GdkRGBA     colors2[2],
+                                            int               thickness2);
+
+
+/* Generate an alpha gradient and multiply it with the existing alpha
+ * channel of the given pixbuf
+ */
+void meta_gradient_add_alpha (GdkPixbuf       *pixbuf,
+                              const guchar    *alphas,
+                              int              n_alphas,
+                              MetaGradientType type);
+
+
+#endif
diff '--exclude=.git' -urN a/src/meta/meta-background-actor.h b/src/meta/meta-background-actor.h
--- a/src/meta/meta-background-actor.h	2015-06-13 23:59:51.993809000 -0400
+++ b/src/meta/meta-background-actor.h	2015-10-31 11:13:25.289109093 -0400
@@ -22,8 +22,10 @@
 #define META_BACKGROUND_ACTOR_H
 
 #include <clutter/clutter.h>
+#include <cogl/cogl.h>
+
+#include <meta/gradient.h>
 #include <meta/screen.h>
-#include <meta/meta-background.h>
 
 #include <gsettings-desktop-schemas/gdesktop-enums.h>
 
@@ -61,15 +63,6 @@
 
 GType meta_background_actor_get_type (void);
 
-ClutterActor *meta_background_actor_new    (MetaScreen *screen,
-                                            int         monitor);
-
-void meta_background_actor_set_background  (MetaBackgroundActor *self,
-                                            MetaBackground      *background);
-
-void meta_background_actor_set_vignette (MetaBackgroundActor *self,
-                                         gboolean             enabled,
-                                         double               brightness,
-                                         double               sharpness);
+ClutterActor *meta_background_actor_new (void);
 
 #endif /* META_BACKGROUND_ACTOR_H */
diff '--exclude=.git' -urN a/src/meta/meta-background-image.h b/src/meta/meta-background-image.h
--- a/src/meta/meta-background-image.h	2015-06-13 23:59:51.994809000 -0400
+++ b/src/meta/meta-background-image.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,76 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-/*
- * MetaBackgroundImageCache:
- *
- * Simple cache for background textures loaded from files
- *
- * Copyright 2014 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __META_BACKGROUND_IMAGE_H__
-#define __META_BACKGROUND_IMAGE_H__
-
-#include <glib-object.h>
-#include <cogl/cogl.h>
-
-#define META_TYPE_BACKGROUND_IMAGE            (meta_background_image_get_type ())
-#define META_BACKGROUND_IMAGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), META_TYPE_BACKGROUND_IMAGE, MetaBackgroundImage))
-#define META_BACKGROUND_IMAGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  META_TYPE_BACKGROUND_IMAGE, MetaBackgroundImageClass))
-#define META_IS_BACKGROUND_IMAGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), META_TYPE_BACKGROUND_IMAGE))
-#define META_IS_BACKGROUND_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  META_TYPE_BACKGROUND_IMAGE))
-#define META_BACKGROUND_IMAGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  META_TYPE_BACKGROUND_IMAGE, MetaBackgroundImageClass))
-
-/**
- * MetaBackgroundImage:
- *
- * #MetaBackgroundImage is an object that represents a loaded or loading background image.
- */
-typedef struct _MetaBackgroundImage      MetaBackgroundImage;
-typedef struct _MetaBackgroundImageClass MetaBackgroundImageClass;
-
-GType meta_background_image_get_type (void);
-
-gboolean     meta_background_image_is_loaded   (MetaBackgroundImage *image);
-gboolean     meta_background_image_get_success (MetaBackgroundImage *image);
-CoglTexture *meta_background_image_get_texture (MetaBackgroundImage *image);
-
-#define META_TYPE_BACKGROUND_IMAGE_CACHE            (meta_background_image_cache_get_type ())
-#define META_BACKGROUND_IMAGE_CACHE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), META_TYPE_BACKGROUND_IMAGE_CACHE, MetaBackgroundImageCache))
-#define META_BACKGROUND_IMAGE_CACHE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  META_TYPE_BACKGROUND_IMAGE_CACHE, MetaBackgroundImageCacheClass))
-#define META_IS_BACKGROUND_IMAGE_CACHE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), META_TYPE_BACKGROUND_IMAGE_CACHE))
-#define META_IS_BACKGROUND_IMAGE_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  META_TYPE_BACKGROUND_IMAGE_CACHE))
-#define META_BACKGROUND_IMAGE_CACHE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  META_TYPE_BACKGROUND_IMAGE_CACHE, MetaBackgroundImageCacheClass))
-
-/**
- * MetaBackgroundImageCache:
- *
- * #MetaBackgroundImageCache caches loading of textures for backgrounds; there's actually
- * nothing background specific about it, other than it is tuned to work well for
- * large images as typically are used for backgrounds.
- */
-typedef struct _MetaBackgroundImageCache      MetaBackgroundImageCache;
-typedef struct _MetaBackgroundImageCacheClass MetaBackgroundImageCacheClass;
-
-MetaBackgroundImageCache *meta_background_image_cache_get_default (void);
-
-GType meta_background_image_cache_get_type (void);
-
-MetaBackgroundImage *meta_background_image_cache_load  (MetaBackgroundImageCache *cache,
-                                                        GFile                    *file);
-void                 meta_background_image_cache_purge (MetaBackgroundImageCache *cache,
-                                                        GFile                    *file);
-
-#endif /* __META_BACKGROUND_IMAGE_H__ */
diff '--exclude=.git' -urN a/src/meta/meta-background.h b/src/meta/meta-background.h
--- a/src/meta/meta-background.h	2015-06-13 23:59:51.994809000 -0400
+++ b/src/meta/meta-background.h	2015-10-31 11:13:25.289109093 -0400
@@ -1,8 +1,8 @@
 /* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
 /*
- * meta-background-actor.h:  for painting the root window background
+ * meta-background.h: CoglTexture for paintnig the system background
  *
- * Copyright 2010 Red Hat, Inc.
+ * Copyright 2013 Red Hat, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -21,16 +21,20 @@
 #ifndef META_BACKGROUND_H
 #define META_BACKGROUND_H
 
+#include <cogl/cogl.h>
 #include <clutter/clutter.h>
-#include <gsettings-desktop-schemas/gdesktop-enums.h>
+
+#include <meta/gradient.h>
 #include <meta/screen.h>
 
+#include <gsettings-desktop-schemas/gdesktop-enums.h>
+
 /**
  * MetaBackground:
  *
- * This class handles tracking and painting the root window background.
- * By integrating with #MetaWindowGroup we can avoid painting parts of
- * the background that are obscured by other windows.
+ * This class handles loading a background from file, screenshot, or
+ * color scheme. The resulting object can be associated with one or
+ * more #MetaBackgroundActor objects to handle loading the background.
  */
 
 #define META_TYPE_BACKGROUND            (meta_background_get_type ())
@@ -44,6 +48,20 @@
 typedef struct _MetaBackgroundClass   MetaBackgroundClass;
 typedef struct _MetaBackgroundPrivate MetaBackgroundPrivate;
 
+/**
+ * MetaBackgroundEffects:
+ * @META_BACKGROUND_EFFECTS_NONE: No effect
+ * @META_BACKGROUND_EFFECTS_VIGNETTE: Vignette
+ *
+ * Which effects to enable on the background
+ */
+
+typedef enum
+{
+  META_BACKGROUND_EFFECTS_NONE       = 0,
+  META_BACKGROUND_EFFECTS_VIGNETTE   = 1 << 1,
+} MetaBackgroundEffects;
+
 struct _MetaBackgroundClass
 {
   /*< private >*/
@@ -52,30 +70,41 @@
 
 struct _MetaBackground
 {
+  /*< private >*/
   GObject parent;
 
   MetaBackgroundPrivate *priv;
 };
 
-void meta_background_refresh_all (void);
-
 GType meta_background_get_type (void);
 
-MetaBackground *meta_background_new  (MetaScreen *screen);
-
-void meta_background_set_color    (MetaBackground            *self,
-                                   ClutterColor              *color);
-void meta_background_set_gradient (MetaBackground            *self,
-                                   GDesktopBackgroundShading  shading_direction,
-                                   ClutterColor              *color,
-                                   ClutterColor              *second_color);
-void meta_background_set_file     (MetaBackground            *self,
-                                   GFile                     *file,
-                                   GDesktopBackgroundStyle    style);
-void meta_background_set_blend    (MetaBackground            *self,
-                                   GFile                     *file1,
-                                   GFile                     *file2,
-                                   double                     blend_factor,
-                                   GDesktopBackgroundStyle    style);
+MetaBackground *meta_background_new (MetaScreen           *screen,
+                                     int                   monitor,
+				     MetaBackgroundEffects effects);
+MetaBackground *meta_background_copy (MetaBackground        *self,
+                                      int                    monitor,
+				      MetaBackgroundEffects  effects);
+
+void meta_background_load_gradient (MetaBackground            *self,
+                                    GDesktopBackgroundShading  shading_direction,
+                                    ClutterColor              *color,
+                                    ClutterColor              *second_color);
+void meta_background_load_color (MetaBackground *self,
+                                 ClutterColor   *color);
+void meta_background_load_file_async (MetaBackground          *self,
+                                      const char              *filename,
+                                      GDesktopBackgroundStyle  style,
+                                      GCancellable            *cancellable,
+                                      GAsyncReadyCallback      callback,
+                                      gpointer                 user_data);
+gboolean meta_background_load_file_finish (MetaBackground       *self,
+                                           GAsyncResult         *result,
+                                           GError              **error);
+
+const char *meta_background_get_filename (MetaBackground *self);
+GDesktopBackgroundStyle meta_background_get_style (MetaBackground *self);
+GDesktopBackgroundShading meta_background_get_shading (MetaBackground *self);
+const ClutterColor *meta_background_get_color (MetaBackground *self);
+const ClutterColor *meta_background_get_second_color (MetaBackground *self);
 
 #endif /* META_BACKGROUND_H */
diff '--exclude=.git' -urN a/src/meta/prefs.h b/src/meta/prefs.h
--- a/src/meta/prefs.h	2015-06-13 23:59:51.994809000 -0400
+++ b/src/meta/prefs.h	2015-10-31 10:42:33.154533756 -0400
@@ -43,6 +43,7 @@
  * @META_PREF_AUTO_RAISE: auto-raise
  * @META_PREF_AUTO_RAISE_DELAY: auto-raise delay
  * @META_PREF_FOCUS_CHANGE_ON_POINTER_REST: focus change on pointer rest
+ * @META_PREF_THEME: theme
  * @META_PREF_TITLEBAR_FONT: title-bar font
  * @META_PREF_NUM_WORKSPACES: number of workspaces
  * @META_PREF_DYNAMIC_WORKSPACES: dynamic workspaces
@@ -80,6 +81,7 @@
   META_PREF_AUTO_RAISE,
   META_PREF_AUTO_RAISE_DELAY,
   META_PREF_FOCUS_CHANGE_ON_POINTER_REST,
+  META_PREF_THEME,
   META_PREF_TITLEBAR_FONT,
   META_PREF_NUM_WORKSPACES,
   META_PREF_DYNAMIC_WORKSPACES,
@@ -126,6 +128,7 @@
 GDesktopFocusNewWindows     meta_prefs_get_focus_new_windows  (void);
 gboolean                    meta_prefs_get_attach_modal_dialogs (void);
 gboolean                    meta_prefs_get_raise_on_click     (void);
+const char*                 meta_prefs_get_theme              (void);
 /* returns NULL if GTK default should be used */
 const PangoFontDescription* meta_prefs_get_titlebar_font      (void);
 int                         meta_prefs_get_num_workspaces     (void);
diff '--exclude=.git' -urN a/src/meta/theme.h b/src/meta/theme.h
--- a/src/meta/theme.h	2015-06-13 23:59:51.994809000 -0400
+++ b/src/meta/theme.h	2015-10-31 10:42:33.154533756 -0400
@@ -34,4 +34,10 @@
 
 MetaTheme* meta_theme_new      (void);
 void       meta_theme_free     (MetaTheme *theme);
+gboolean   meta_theme_validate (MetaTheme *theme,
+                                GError   **error);
+
+MetaTheme* meta_theme_load (const char *theme_name,
+                            GError    **err);
+
 #endif
diff '--exclude=.git' -urN a/src/ui/frames.c b/src/ui/frames.c
--- a/src/ui/frames.c	2015-10-30 16:39:40.975006658 -0400
+++ b/src/ui/frames.c	2015-10-31 10:11:55.872944839 -0400
@@ -32,11 +32,6 @@
 #include <meta/prefs.h>
 #include "ui.h"
 
-#include "core/window-private.h"
-#include "core/frame.h"
-#include "x11/window-x11.h"
-#include "x11/window-x11-private.h"
-
 #include <cairo-xlib.h>
 
 #define DEFAULT_INNER_BUTTON_BORDER 3
@@ -45,19 +40,40 @@
 static void meta_frames_finalize      (GObject         *object);
 static void meta_frames_style_updated (GtkWidget       *widget);
 
+static void meta_frames_update_prelit_control (MetaFrames      *frames,
+                                               MetaUIFrame     *frame,
+                                               MetaFrameControl control);
+static gboolean meta_frames_button_press_event    (GtkWidget           *widget,
+                                                   GdkEventButton      *event);
+static gboolean meta_frames_button_release_event  (GtkWidget           *widget,
+                                                   GdkEventButton      *event);
+static gboolean meta_frames_motion_notify_event   (GtkWidget           *widget,
+                                                   GdkEventMotion      *event);
+static gboolean meta_frames_destroy_event         (GtkWidget           *widget,
+                                                   GdkEventAny         *event);
 static gboolean meta_frames_draw                  (GtkWidget           *widget,
                                                    cairo_t             *cr);
+static gboolean meta_frames_enter_notify_event    (GtkWidget           *widget,
+                                                   GdkEventCrossing    *event);
+static gboolean meta_frames_leave_notify_event    (GtkWidget           *widget,
+                                                   GdkEventCrossing    *event);
+
+static void meta_frames_attach_style (MetaFrames  *frames,
+                                      MetaUIFrame *frame);
+
+static void meta_frames_paint        (MetaFrames   *frames,
+                                      MetaUIFrame  *frame,
+                                      cairo_t      *cr);
+
+static void meta_frames_calc_geometry (MetaFrames        *frames,
+                                       MetaUIFrame         *frame,
+                                       MetaFrameGeometry *fgeom);
 
-static void meta_ui_frame_attach_style (MetaUIFrame *frame);
-
-static void meta_ui_frame_paint        (MetaUIFrame  *frame,
-                                        cairo_t      *cr);
-
-static void meta_ui_frame_calc_geometry (MetaUIFrame       *frame,
-                                         MetaFrameGeometry *fgeom);
+static void meta_frames_ensure_layout (MetaFrames      *frames,
+                                       MetaUIFrame     *frame);
 
-static void meta_ui_frame_update_prelit_control (MetaUIFrame     *frame,
-                                                 MetaFrameControl control);
+static MetaUIFrame* meta_frames_lookup_window (MetaFrames *frames,
+                                               Window      xwindow);
 
 static void meta_frames_font_changed          (MetaFrames *frames);
 static void meta_frames_button_layout_changed (MetaFrames *frames);
@@ -65,9 +81,12 @@
 
 static GdkRectangle*    control_rect (MetaFrameControl   control,
                                       MetaFrameGeometry *fgeom);
-static MetaFrameControl get_control  (MetaUIFrame       *frame,
+static MetaFrameControl get_control  (MetaFrames        *frames,
+                                      MetaUIFrame       *frame,
                                       int                x,
                                       int                y);
+static void invalidate_whole_window (MetaFrames *frames,
+                                     MetaUIFrame *frame);
 
 G_DEFINE_TYPE (MetaFrames, meta_frames, GTK_TYPE_WINDOW);
 
@@ -106,6 +125,12 @@
   widget_class->style_updated = meta_frames_style_updated;
 
   widget_class->draw = meta_frames_draw;
+  widget_class->destroy_event = meta_frames_destroy_event;
+  widget_class->button_press_event = meta_frames_button_press_event;
+  widget_class->button_release_event = meta_frames_button_release_event;
+  widget_class->motion_notify_event = meta_frames_motion_notify_event;
+  widget_class->enter_notify_event = meta_frames_enter_notify_event;
+  widget_class->leave_notify_event = meta_frames_leave_notify_event;
 }
 
 static gint
@@ -145,12 +170,6 @@
     }
 }
 
-static void
-invalidate_whole_window (MetaUIFrame *frame)
-{
-  gdk_window_invalidate_rect (frame->window, NULL, FALSE);
-}
-
 static MetaStyleInfo *
 meta_frames_get_theme_variant (MetaFrames  *frames,
                                const gchar *variant)
@@ -229,8 +248,11 @@
   /* Unmanage all frames */
   for (tmp = winlist; tmp != NULL; tmp = tmp->next)
     {
-      MetaUIFrame *frame = tmp->data;
-      meta_ui_frame_unmanage (frame);
+      MetaUIFrame *frame;
+
+      frame = tmp->data;
+
+      meta_frames_unmanage_window (frames, frame->xwindow);
     }
   g_slist_free (winlist);
 
@@ -269,13 +291,24 @@
 static void
 queue_recalc_func (gpointer key, gpointer value, gpointer data)
 {
-  MetaUIFrame *frame = value;
+  MetaUIFrame *frame;
+  MetaFrames *frames;
+
+  frames = META_FRAMES (data);
+  frame = value;
 
-  invalidate_whole_window (frame);
+  invalidate_whole_window (frames, frame);
   meta_core_queue_frame_resize (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
                                 frame->xwindow);
+  if (frame->text_layout)
+    {
+      /* save title to recreate layout */
+      g_free (frame->title);
 
-  g_clear_object (&frame->text_layout);
+      frame->title = g_strdup (pango_layout_get_text (frame->text_layout));
+
+      g_clear_object (&frame->text_layout);
+    }
 }
 
 static void
@@ -296,8 +329,13 @@
 static void
 queue_draw_func (gpointer key, gpointer value, gpointer data)
 {
-  MetaUIFrame *frame = value;
-  invalidate_whole_window (frame);
+  MetaUIFrame *frame;
+  MetaFrames *frames;
+
+  frames = META_FRAMES (data);
+  frame = value;
+
+  invalidate_whole_window (frames, frame);
 }
 
 static void
@@ -310,8 +348,13 @@
 static void
 reattach_style_func (gpointer key, gpointer value, gpointer data)
 {
-  MetaUIFrame *frame = value;
-  meta_ui_frame_attach_style (frame);
+  MetaUIFrame *frame;
+  MetaFrames *frames;
+
+  frames = META_FRAMES (data);
+  frame = value;
+
+  meta_frames_attach_style (frames, frame);
 }
 
 static void
@@ -325,7 +368,8 @@
 
   update_style_contexts (frames);
 
-  g_hash_table_foreach (frames->frames, reattach_style_func, NULL);
+  g_hash_table_foreach (frames->frames,
+                        reattach_style_func, frames);
 
   meta_retheme_all ();
 
@@ -333,23 +377,35 @@
 }
 
 static void
-meta_ui_frame_ensure_layout (MetaUIFrame    *frame,
-                             MetaFrameType   type)
+meta_frames_ensure_layout (MetaFrames  *frames,
+                           MetaUIFrame *frame)
 {
-  MetaFrames *frames = frame->frames;
   GtkWidget *widget;
-  MetaFrameLayout *layout;
+  MetaFrameFlags flags;
+  MetaFrameType type;
+  MetaFrameStyle *style;
 
   widget = GTK_WIDGET (frames);
 
   g_return_if_fail (gtk_widget_get_realized (widget));
 
-  layout = meta_theme_get_frame_layout (meta_theme_get_default (), type);
+  meta_core_get (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), frame->xwindow,
+                 META_CORE_GET_FRAME_FLAGS, &flags,
+                 META_CORE_GET_FRAME_TYPE, &type,
+                 META_CORE_GET_END);
 
-  if (layout != frame->cache_layout)
-    g_clear_object (&frame->text_layout);
+  style = meta_theme_get_frame_style (meta_theme_get_default (), type, flags);
+
+  if (style != frame->cache_style)
+    {
+      if (frame->text_layout)
+        {
+          g_assert (g_str_equal (frame->title, pango_layout_get_text (frame->text_layout)));
+          g_clear_object (&frame->text_layout);
+        }
+    }
 
-  frame->cache_layout = layout;
+  frame->cache_style = style;
 
   if (frame->text_layout == NULL)
     {
@@ -364,7 +420,7 @@
       pango_layout_set_single_paragraph_mode (frame->text_layout, TRUE);
 
       font_desc = meta_style_info_create_font_desc (frame->style_info);
-      meta_frame_layout_apply_scale (layout, font_desc);
+      meta_frame_style_apply_scale (style, font_desc);
 
       size = pango_font_description_get_size (font_desc);
 
@@ -389,23 +445,31 @@
                                          font_desc);
 
       pango_font_description_free (font_desc);
+
+      /* Save some RAM */
+      g_free (frame->title);
+      frame->title = NULL;
     }
 }
 
 static void
-meta_ui_frame_calc_geometry (MetaUIFrame       *frame,
-                             MetaFrameGeometry *fgeom)
+meta_frames_calc_geometry (MetaFrames        *frames,
+                           MetaUIFrame       *frame,
+                           MetaFrameGeometry *fgeom)
 {
+  int width, height;
   MetaFrameFlags flags;
   MetaFrameType type;
   MetaButtonLayout button_layout;
-  MetaWindowX11 *window_x11 = META_WINDOW_X11 (frame->meta_window);
-  MetaWindowX11Private *priv = window_x11->priv;
 
-  flags = meta_frame_get_flags (frame->meta_window->frame);
-  type = meta_window_get_frame_type (frame->meta_window);
+  meta_core_get (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), frame->xwindow,
+                 META_CORE_GET_CLIENT_WIDTH, &width,
+                 META_CORE_GET_CLIENT_HEIGHT, &height,
+                 META_CORE_GET_FRAME_FLAGS, &flags,
+                 META_CORE_GET_FRAME_TYPE, &type,
+                 META_CORE_GET_END);
 
-  meta_ui_frame_ensure_layout (frame, type);
+  meta_frames_ensure_layout (frames, frame);
 
   meta_prefs_get_button_layout (&button_layout);
 
@@ -414,8 +478,7 @@
                             type,
                             frame->text_height,
                             flags,
-                            priv->client_rect.width,
-                            priv->client_rect.height,
+                            width, height,
                             &button_layout,
                             fgeom);
 }
@@ -446,23 +509,6 @@
   return frames;
 }
 
-static const char *
-get_theme_variant_override (MetaFrames *frames)
-{
-  GdkScreen *screen = gtk_widget_get_screen (GTK_WIDGET (frames));
-  GtkSettings *settings = gtk_settings_get_for_screen (screen);
-  gboolean dark_theme_requested;
-
-  g_object_get (settings,
-                "gtk-application-prefer-dark-theme", &dark_theme_requested,
-                NULL);
-
-  if (dark_theme_requested)
-    return "dark";
-
-  return NULL;
-}
-
 /* In order to use a style with a window it has to be attached to that
  * window. Actually, the colormaps just have to match, but since GTK+
  * already takes care of making sure that its cheap to attach a style
@@ -470,21 +516,20 @@
  * and attach separately for each window.
  */
 static void
-meta_ui_frame_attach_style (MetaUIFrame *frame)
+meta_frames_attach_style (MetaFrames  *frames,
+                          MetaUIFrame *frame)
 {
-  MetaFrames *frames = frame->frames;
-  const char *variant;
-  const char *variant_override;
+  gboolean has_frame;
+  char *variant = NULL;
 
   if (frame->style_info != NULL)
     meta_style_info_unref (frame->style_info);
 
-  variant_override = get_theme_variant_override (frame->frames);
-
-  if (variant_override)
-    variant = variant_override;
-  else
-    variant = frame->meta_window->gtk_theme_variant;
+  meta_core_get (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                 frame->xwindow,
+                 META_CORE_WINDOW_HAS_FRAME, &has_frame,
+                 META_CORE_GET_THEME_VARIANT, &variant,
+                 META_CORE_GET_END);
 
   if (variant == NULL || strcmp(variant, "normal") == 0)
     frame->style_info = meta_style_info_ref (frames->normal_style);
@@ -493,9 +538,8 @@
                                                                             variant));
 }
 
-MetaUIFrame *
+void
 meta_frames_manage_window (MetaFrames *frames,
-                           MetaWindow *meta_window,
                            Window      xwindow,
                            GdkWindow  *window)
 {
@@ -505,7 +549,6 @@
 
   frame = g_new (MetaUIFrame, 1);
 
-  frame->frames = frames;
   frame->window = window;
 
   gdk_window_set_user_data (frame->window, frames);
@@ -515,8 +558,7 @@
   /* Don't set event mask here, it's in frame.c */
 
   frame->xwindow = xwindow;
-  frame->meta_window = meta_window;
-  frame->cache_layout = NULL;
+  frame->cache_style = NULL;
   frame->text_layout = NULL;
   frame->text_height = -1;
   frame->title = NULL;
@@ -526,49 +568,72 @@
   meta_core_grab_buttons (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), frame->xwindow);
 
   g_hash_table_replace (frames->frames, &frame->xwindow, frame);
-
-  return frame;
 }
 
 void
-meta_ui_frame_unmanage (MetaUIFrame *frame)
+meta_frames_unmanage_window (MetaFrames *frames,
+                             Window      xwindow)
 {
-  MetaFrames *frames = frame->frames;
+  MetaUIFrame *frame;
 
-  /* restore the cursor */
-  meta_core_set_screen_cursor (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
-                               frame->xwindow,
-                               META_CURSOR_DEFAULT);
+  frame = g_hash_table_lookup (frames->frames, &xwindow);
 
-  gdk_window_set_user_data (frame->window, NULL);
+  if (frame)
+    {
+      /* restore the cursor */
+      meta_core_set_screen_cursor (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                                   frame->xwindow,
+                                   META_CURSOR_DEFAULT);
 
-  g_hash_table_remove (frames->frames, &frame->xwindow);
+      gdk_window_set_user_data (frame->window, NULL);
 
-  meta_style_info_unref (frame->style_info);
+      if (frames->last_motion_frame == frame)
+        frames->last_motion_frame = NULL;
 
-  gdk_window_destroy (frame->window);
+      g_hash_table_remove (frames->frames, &frame->xwindow);
 
-  if (frame->text_layout)
-    g_object_unref (G_OBJECT (frame->text_layout));
+      meta_style_info_unref (frame->style_info);
 
-  g_free (frame->title);
+      gdk_window_destroy (frame->window);
+
+      if (frame->text_layout)
+        g_object_unref (G_OBJECT (frame->text_layout));
+
+      g_free (frame->title);
 
-  g_free (frame);
+      g_free (frame);
+    }
+  else
+    meta_warning ("Frame 0x%lx not managed, can't unmanage\n", xwindow);
 }
 
-void
-meta_ui_frame_get_borders (MetaUIFrame *frame,
+static MetaUIFrame*
+meta_frames_lookup_window (MetaFrames *frames,
+                           Window      xwindow)
+{
+  MetaUIFrame *frame;
+
+  frame = g_hash_table_lookup (frames->frames, &xwindow);
+
+  return frame;
+}
+
+static void
+meta_ui_frame_get_borders (MetaFrames *frames,
+                           MetaUIFrame *frame,
                            MetaFrameBorders *borders)
 {
   MetaFrameFlags flags;
   MetaFrameType type;
 
-  flags = meta_frame_get_flags (frame->meta_window->frame);
-  type = meta_window_get_frame_type (frame->meta_window);
+  meta_core_get (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), frame->xwindow,
+                 META_CORE_GET_FRAME_FLAGS, &flags,
+                 META_CORE_GET_FRAME_TYPE, &type,
+                 META_CORE_GET_END);
 
   g_return_if_fail (type < META_FRAME_TYPE_LAST);
 
-  meta_ui_frame_ensure_layout (frame, type);
+  meta_frames_ensure_layout (frames, frame);
 
   /* We can't get the full geometry, because that depends on
    * the client window size and probably we're being called
@@ -583,17 +648,34 @@
                                 borders);
 }
 
+void
+meta_frames_get_borders (MetaFrames *frames,
+                         Window xwindow,
+                         MetaFrameBorders *borders)
+{
+  MetaUIFrame *frame;
+
+  frame = meta_frames_lookup_window (frames, xwindow);
+
+  if (frame == NULL)
+    meta_bug ("No such frame 0x%lx\n", xwindow);
+
+  meta_ui_frame_get_borders (frames, frame, borders);
+}
+
 /* The client rectangle surrounds client window; it subtracts both
  * the visible and invisible borders from the frame window's size.
  */
 static void
 get_client_rect (MetaFrameGeometry     *fgeom,
+                 int                    window_width,
+                 int                    window_height,
                  cairo_rectangle_int_t *rect)
 {
   rect->x = fgeom->borders.total.left;
   rect->y = fgeom->borders.total.top;
-  rect->width = fgeom->width - fgeom->borders.total.right - rect->x;
-  rect->height = fgeom->height - fgeom->borders.total.bottom - rect->y;
+  rect->width = window_width - fgeom->borders.total.right - rect->x;
+  rect->height = window_height - fgeom->borders.total.bottom - rect->y;
 }
 
 /* The visible frame rectangle surrounds the visible portion of the
@@ -602,17 +684,22 @@
  */
 static void
 get_visible_frame_rect (MetaFrameGeometry     *fgeom,
+                        int                    window_width,
+                        int                    window_height,
                         cairo_rectangle_int_t *rect)
 {
   rect->x = fgeom->borders.invisible.left;
   rect->y = fgeom->borders.invisible.top;
-  rect->width = fgeom->width - fgeom->borders.invisible.right - rect->x;
-  rect->height = fgeom->height - fgeom->borders.invisible.bottom - rect->y;
+  rect->width = window_width - fgeom->borders.invisible.right - rect->x;
+  rect->height = window_height - fgeom->borders.invisible.bottom - rect->y;
 }
 
 static cairo_region_t *
-get_visible_region (MetaUIFrame       *frame,
-                    MetaFrameGeometry *fgeom)
+get_visible_region (MetaFrames        *frames,
+                    MetaUIFrame       *frame,
+                    MetaFrameGeometry *fgeom,
+                    int                window_width,
+                    int                window_height)
 {
   cairo_region_t *corners_region;
   cairo_region_t *visible_region;
@@ -620,7 +707,7 @@
   cairo_rectangle_int_t frame_rect;
 
   corners_region = cairo_region_create ();
-  get_visible_frame_rect (fgeom, &frame_rect);
+  get_visible_frame_rect (fgeom, window_width, window_height, &frame_rect);
 
   if (fgeom->top_left_corner_rounded_radius != 0)
     {
@@ -702,17 +789,33 @@
 }
 
 cairo_region_t *
-meta_ui_frame_get_bounds (MetaUIFrame *frame)
+meta_frames_get_frame_bounds (MetaFrames *frames,
+                              Window      xwindow,
+                              int         window_width,
+                              int         window_height)
 {
+  MetaUIFrame *frame;
   MetaFrameGeometry fgeom;
-  meta_ui_frame_calc_geometry (frame, &fgeom);
-  return get_visible_region (frame, &fgeom);
+
+  frame = meta_frames_lookup_window (frames, xwindow);
+  g_return_val_if_fail (frame != NULL, NULL);
+
+  meta_frames_calc_geometry (frames, frame, &fgeom);
+
+  return get_visible_region (frames, frame,
+                             &fgeom,
+                             window_width, window_height);
 }
 
 void
-meta_ui_frame_move_resize (MetaUIFrame *frame,
-                           int x, int y, int width, int height)
+meta_frames_move_resize_frame (MetaFrames *frames,
+                               Window      xwindow,
+                               int         x,
+                               int         y,
+                               int         width,
+                               int         height)
 {
+  MetaUIFrame *frame = meta_frames_lookup_window (frames, xwindow);
   int old_width, old_height;
 
   old_width = gdk_window_get_width (frame->window);
@@ -721,42 +824,78 @@
   gdk_window_move_resize (frame->window, x, y, width, height);
 
   if (old_width != width || old_height != height)
-    invalidate_whole_window (frame);
+    invalidate_whole_window (frames, frame);
 }
 
 void
-meta_ui_frame_queue_draw (MetaUIFrame *frame)
+meta_frames_queue_draw (MetaFrames *frames,
+                        Window      xwindow)
 {
-  invalidate_whole_window (frame);
+  MetaUIFrame *frame;
+
+  frame = meta_frames_lookup_window (frames, xwindow);
+
+  invalidate_whole_window (frames, frame);
 }
 
 void
-meta_ui_frame_set_title (MetaUIFrame *frame,
-                         const char *title)
+meta_frames_set_title (MetaFrames *frames,
+                       Window      xwindow,
+                       const char *title)
 {
+  MetaUIFrame *frame;
+
+  frame = meta_frames_lookup_window (frames, xwindow);
+
+  g_assert (frame);
+
   g_free (frame->title);
   frame->title = g_strdup (title);
 
   g_clear_object (&frame->text_layout);
 
-  invalidate_whole_window (frame);
+  invalidate_whole_window (frames, frame);
+}
+
+void
+meta_frames_update_frame_style (MetaFrames *frames,
+                                Window      xwindow)
+{
+  MetaUIFrame *frame;
+
+  frame = meta_frames_lookup_window (frames, xwindow);
+
+  g_assert (frame);
+
+  meta_frames_attach_style (frames, frame);
+  invalidate_whole_window (frames, frame);
 }
 
 void
-meta_ui_frame_update_style (MetaUIFrame *frame)
+meta_frames_repaint_frame (MetaFrames *frames,
+                           Window      xwindow)
 {
-  meta_ui_frame_attach_style (frame);
-  invalidate_whole_window (frame);
+  MetaUIFrame *frame;
+
+  frame = meta_frames_lookup_window (frames, xwindow);
+
+  g_assert (frame);
+
+  /* repaint everything, so the other frame don't
+   * lag behind if they are exposed
+   */
+  gdk_window_process_all_updates ();
 }
 
 static void
-redraw_control (MetaUIFrame *frame,
+redraw_control (MetaFrames *frames,
+                MetaUIFrame *frame,
                 MetaFrameControl control)
 {
   MetaFrameGeometry fgeom;
   GdkRectangle *rect;
 
-  meta_ui_frame_calc_geometry (frame, &fgeom);
+  meta_frames_calc_geometry (frames, frame, &fgeom);
 
   rect = control_rect (control, &fgeom);
 
@@ -764,33 +903,43 @@
 }
 
 static gboolean
-meta_frame_titlebar_event (MetaUIFrame *frame,
-                           ClutterButtonEvent *event,
-                           int action)
+meta_frame_titlebar_event (MetaUIFrame    *frame,
+                           GdkEventButton *event,
+                           int            action)
 {
   MetaFrameFlags flags;
   Display *display;
 
   display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
 
-  flags = meta_frame_get_flags (frame->meta_window->frame);
-
   switch (action)
     {
     case G_DESKTOP_TITLEBAR_ACTION_TOGGLE_SHADE:
       {
+        meta_core_get (display, frame->xwindow,
+                       META_CORE_GET_FRAME_FLAGS, &flags,
+                       META_CORE_GET_END);
+
         if (flags & META_FRAME_ALLOWS_SHADE)
           {
             if (flags & META_FRAME_SHADED)
-              meta_window_unshade (frame->meta_window, event->time);
+              meta_core_unshade (display,
+                                 frame->xwindow,
+                                 event->time);
             else
-              meta_window_shade (frame->meta_window, event->time);
+              meta_core_shade (display,
+                               frame->xwindow,
+                               event->time);
           }
       }
       break;
 
     case G_DESKTOP_TITLEBAR_ACTION_TOGGLE_MAXIMIZE:
       {
+        meta_core_get (display, frame->xwindow,
+                       META_CORE_GET_FRAME_FLAGS, &flags,
+                       META_CORE_GET_END);
+
         if (flags & META_FRAME_ALLOWS_MAXIMIZE)
           {
             meta_core_toggle_maximize (display, frame->xwindow);
@@ -800,6 +949,10 @@
 
     case G_DESKTOP_TITLEBAR_ACTION_TOGGLE_MAXIMIZE_HORIZONTALLY:
       {
+        meta_core_get (display, frame->xwindow,
+                       META_CORE_GET_FRAME_FLAGS, &flags,
+                       META_CORE_GET_END);
+
         if (flags & META_FRAME_ALLOWS_MAXIMIZE)
           {
             meta_core_toggle_maximize_horizontally (display, frame->xwindow);
@@ -809,6 +962,10 @@
 
     case G_DESKTOP_TITLEBAR_ACTION_TOGGLE_MAXIMIZE_VERTICALLY:
       {
+        meta_core_get (display, frame->xwindow,
+                       META_CORE_GET_FRAME_FLAGS, &flags,
+                       META_CORE_GET_END);
+
         if (flags & META_FRAME_ALLOWS_MAXIMIZE)
           {
             meta_core_toggle_maximize_vertically (display, frame->xwindow);
@@ -818,8 +975,14 @@
 
     case G_DESKTOP_TITLEBAR_ACTION_MINIMIZE:
       {
+        meta_core_get (display, frame->xwindow,
+                       META_CORE_GET_FRAME_FLAGS, &flags,
+                       META_CORE_GET_END);
+
         if (flags & META_FRAME_ALLOWS_MINIMIZE)
-          meta_window_minimize (frame->meta_window);
+          {
+            meta_core_minimize (display, frame->xwindow);
+          }
       }
       break;
 
@@ -837,8 +1000,8 @@
       meta_core_show_window_menu (display,
                                   frame->xwindow,
                                   META_WINDOW_MENU_WM,
-                                  event->x,
-                                  event->y,
+                                  event->x_root,
+                                  event->y_root,
                                   event->time);
       break;
     }
@@ -847,8 +1010,8 @@
 }
 
 static gboolean
-meta_frame_double_click_event (MetaUIFrame  *frame,
-                               ClutterButtonEvent *event)
+meta_frame_double_click_event (MetaUIFrame    *frame,
+                               GdkEventButton *event)
 {
   int action = meta_prefs_get_action_double_click_titlebar ();
 
@@ -856,8 +1019,8 @@
 }
 
 static gboolean
-meta_frame_middle_click_event (MetaUIFrame *frame,
-                               ClutterButtonEvent *event)
+meta_frame_middle_click_event (MetaUIFrame    *frame,
+                               GdkEventButton *event)
 {
   int action = meta_prefs_get_action_middle_click_titlebar();
 
@@ -865,8 +1028,8 @@
 }
 
 static gboolean
-meta_frame_right_click_event (MetaUIFrame *frame,
-                              ClutterButtonEvent *event)
+meta_frame_right_click_event(MetaUIFrame     *frame,
+                             GdkEventButton  *event)
 {
   int action = meta_prefs_get_action_right_click_titlebar();
 
@@ -874,13 +1037,13 @@
 }
 
 static gboolean
-meta_frames_try_grab_op (MetaUIFrame *frame,
+meta_frames_try_grab_op (MetaFrames  *frames,
+                         MetaUIFrame *frame,
                          MetaGrabOp   op,
                          gdouble      grab_x,
                          gdouble      grab_y,
                          guint32      time)
 {
-  MetaFrames *frames = frame->frames;
   Display *display;
   gboolean ret;
 
@@ -931,57 +1094,82 @@
                                   frames->grab_y);
 }
 
-static MetaGrabOp
-grab_op_from_resize_control (MetaFrameControl control)
+static gboolean
+meta_frames_button_press_event (GtkWidget      *widget,
+                                GdkEventButton *event)
 {
-  switch (control)
+  MetaUIFrame *frame;
+  MetaFrames *frames;
+  MetaFrameControl control;
+  Display *display;
+
+  frames = META_FRAMES (widget);
+  display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+
+  /* Remember that the display may have already done something with this event.
+   * If so there's probably a GrabOp in effect.
+   */
+
+  frame = meta_frames_lookup_window (frames, GDK_WINDOW_XID (event->window));
+  if (frame == NULL)
+    return FALSE;
+
+  control = get_control (frames, frame, event->x, event->y);
+
+  /* focus on click, even if click was on client area */
+  if (event->button == 1 &&
+      !(control == META_FRAME_CONTROL_MINIMIZE ||
+        control == META_FRAME_CONTROL_DELETE ||
+        control == META_FRAME_CONTROL_MAXIMIZE))
     {
-    case META_FRAME_CONTROL_RESIZE_SE:
-      return META_GRAB_OP_RESIZING_SE;
-    case META_FRAME_CONTROL_RESIZE_S:
-      return META_GRAB_OP_RESIZING_S;
-    case META_FRAME_CONTROL_RESIZE_SW:
-      return META_GRAB_OP_RESIZING_SW;
-    case META_FRAME_CONTROL_RESIZE_NE:
-      return META_GRAB_OP_RESIZING_NE;
-    case META_FRAME_CONTROL_RESIZE_N:
-      return META_GRAB_OP_RESIZING_N;
-    case META_FRAME_CONTROL_RESIZE_NW:
-      return META_GRAB_OP_RESIZING_NW;
-    case META_FRAME_CONTROL_RESIZE_E:
-      return META_GRAB_OP_RESIZING_E;
-    case META_FRAME_CONTROL_RESIZE_W:
-      return META_GRAB_OP_RESIZING_W;
-    default:
-      g_assert_not_reached ();
+      meta_topic (META_DEBUG_FOCUS,
+                  "Focusing window with frame 0x%lx due to button 1 press\n",
+                  frame->xwindow);
+      meta_core_user_focus (display,
+                            frame->xwindow,
+                            event->time);
     }
-}
 
-static gboolean
-meta_frame_left_click_event (MetaUIFrame *frame,
-                             ClutterButtonEvent *event)
-{
-  Display *display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-  MetaFrameControl control = get_control (frame, event->x, event->y);
+  /* don't do the rest of this if on client area */
+  if (control == META_FRAME_CONTROL_CLIENT_AREA)
+    return FALSE; /* not on the frame, just passed through from client */
 
-  switch (control)
+  /* We want to shade even if we have a GrabOp, since we'll have a move grab
+   * if we double click the titlebar.
+   */
+  if (control == META_FRAME_CONTROL_TITLE &&
+      event->button == 1 &&
+      event->type == GDK_2BUTTON_PRESS)
     {
-    case META_FRAME_CONTROL_MAXIMIZE:
-    case META_FRAME_CONTROL_UNMAXIMIZE:
-    case META_FRAME_CONTROL_MINIMIZE:
-    case META_FRAME_CONTROL_DELETE:
-    case META_FRAME_CONTROL_SHADE:
-    case META_FRAME_CONTROL_UNSHADE:
-    case META_FRAME_CONTROL_ABOVE:
-    case META_FRAME_CONTROL_UNABOVE:
-    case META_FRAME_CONTROL_STICK:
-    case META_FRAME_CONTROL_UNSTICK:
-    case META_FRAME_CONTROL_MENU:
-    case META_FRAME_CONTROL_APPMENU:
+      meta_core_end_grab_op (display, event->time);
+      return meta_frame_double_click_event (frame, event);
+    }
+
+  if (meta_core_get_grab_op (display) != META_GRAB_OP_NONE)
+    return FALSE; /* already up to something */
+
+  frame->grab_button = event->button;
+
+  if (event->button == 1 &&
+      (control == META_FRAME_CONTROL_MAXIMIZE ||
+       control == META_FRAME_CONTROL_UNMAXIMIZE ||
+       control == META_FRAME_CONTROL_MINIMIZE ||
+       control == META_FRAME_CONTROL_DELETE ||
+       control == META_FRAME_CONTROL_SHADE ||
+       control == META_FRAME_CONTROL_UNSHADE ||
+       control == META_FRAME_CONTROL_ABOVE ||
+       control == META_FRAME_CONTROL_UNABOVE ||
+       control == META_FRAME_CONTROL_STICK ||
+       control == META_FRAME_CONTROL_UNSTICK ||
+       control == META_FRAME_CONTROL_MENU ||
+       control == META_FRAME_CONTROL_APPMENU))
+    {
+      frames->grab_xwindow = frame->xwindow;
+
       frame->grab_button = event->button;
       frame->button_state = META_BUTTON_STATE_PRESSED;
       frame->prelit_control = control;
-      redraw_control (frame, control);
+      redraw_control (frames, frame, control);
 
       if (control == META_FRAME_CONTROL_MENU ||
           control == META_FRAME_CONTROL_APPMENU)
@@ -992,11 +1180,13 @@
           MetaWindowMenuType menu;
           int win_x, win_y;
 
-          meta_ui_frame_calc_geometry (frame, &fgeom);
+          meta_frames_calc_geometry (frames, frame, &fgeom);
 
           rect = control_rect (control, &fgeom);
 
-          gdk_window_get_position (frame->window, &win_x, &win_y);
+          /* convert to root coords */
+          win_x = event->x_root - event->x;
+          win_y = event->y_root - event->y;
 
           root_rect.x = win_x + rect->x;
           root_rect.y = win_y + rect->y;
@@ -1004,7 +1194,7 @@
           root_rect.height = rect->height;
 
           menu = control == META_FRAME_CONTROL_MENU ? META_WINDOW_MENU_WM
-            : META_WINDOW_MENU_APP;
+                                                    : META_WINDOW_MENU_APP;
 
           /* if the compositor takes a grab for showing the menu, we will
            * get a LeaveNotify event we want to ignore, to keep the pressed
@@ -1017,160 +1207,142 @@
                                                &root_rect,
                                                event->time);
         }
-      else
+    }
+  else if (event->button == 1 &&
+           (control == META_FRAME_CONTROL_RESIZE_SE ||
+            control == META_FRAME_CONTROL_RESIZE_S ||
+            control == META_FRAME_CONTROL_RESIZE_SW ||
+            control == META_FRAME_CONTROL_RESIZE_NE ||
+            control == META_FRAME_CONTROL_RESIZE_N ||
+            control == META_FRAME_CONTROL_RESIZE_NW ||
+            control == META_FRAME_CONTROL_RESIZE_E ||
+            control == META_FRAME_CONTROL_RESIZE_W))
+    {
+      MetaGrabOp op;
+
+      op = META_GRAB_OP_NONE;
+
+      switch (control)
         {
-          meta_frames_try_grab_op (frame, META_GRAB_OP_FRAME_BUTTON,
-                                   event->x, event->y,
-                                   event->time);
+        case META_FRAME_CONTROL_RESIZE_SE:
+          op = META_GRAB_OP_RESIZING_SE;
+          break;
+        case META_FRAME_CONTROL_RESIZE_S:
+          op = META_GRAB_OP_RESIZING_S;
+          break;
+        case META_FRAME_CONTROL_RESIZE_SW:
+          op = META_GRAB_OP_RESIZING_SW;
+          break;
+        case META_FRAME_CONTROL_RESIZE_NE:
+          op = META_GRAB_OP_RESIZING_NE;
+          break;
+        case META_FRAME_CONTROL_RESIZE_N:
+          op = META_GRAB_OP_RESIZING_N;
+          break;
+        case META_FRAME_CONTROL_RESIZE_NW:
+          op = META_GRAB_OP_RESIZING_NW;
+          break;
+        case META_FRAME_CONTROL_RESIZE_E:
+          op = META_GRAB_OP_RESIZING_E;
+          break;
+        case META_FRAME_CONTROL_RESIZE_W:
+          op = META_GRAB_OP_RESIZING_W;
+          break;
+        default:
+          g_assert_not_reached ();
+          break;
         }
 
-      return TRUE;
-    case META_FRAME_CONTROL_RESIZE_SE:
-    case META_FRAME_CONTROL_RESIZE_S:
-    case META_FRAME_CONTROL_RESIZE_SW:
-    case META_FRAME_CONTROL_RESIZE_NE:
-    case META_FRAME_CONTROL_RESIZE_N:
-    case META_FRAME_CONTROL_RESIZE_NW:
-    case META_FRAME_CONTROL_RESIZE_E:
-    case META_FRAME_CONTROL_RESIZE_W:
-      meta_frames_try_grab_op (frame,
-                               grab_op_from_resize_control (control),
-                               event->x, event->y,
+      meta_frames_try_grab_op (frames, frame, op,
+                               event->x_root, event->y_root,
                                event->time);
-
-      return TRUE;
-    case META_FRAME_CONTROL_TITLE:
-      {
-        MetaFrameFlags flags = meta_frame_get_flags (frame->meta_window->frame);
-
-        if (flags & META_FRAME_ALLOWS_MOVE)
-          {
-            meta_frames_try_grab_op (frame,
-                                     META_GRAB_OP_MOVING,
-                                     event->x, event->y,
-                                     event->time);
-          }
-      }
-
-      return TRUE;
-    case META_FRAME_CONTROL_NONE:
-      /* We can get this for example when trying to resize window
-       * that cannot be resized (e. g. it is maximized and the theme
-       * currently used has borders for maximized windows), see #751884 */
-      return FALSE;
-    default:
-      g_assert_not_reached ();
     }
-}
-
-static gboolean
-handle_button_press_event (MetaUIFrame *frame,
-                           ClutterButtonEvent *event)
-{
-  MetaFrameControl control;
-  Display *display;
-
-  display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
-
-  control = get_control (frame, event->x, event->y);
-
-  /* focus on click, even if click was on client area */
-  if (event->button == 1 &&
-      !(control == META_FRAME_CONTROL_MINIMIZE ||
-        control == META_FRAME_CONTROL_DELETE ||
-        control == META_FRAME_CONTROL_MAXIMIZE))
+  else if (control == META_FRAME_CONTROL_TITLE &&
+           event->button == 1)
     {
-      meta_topic (META_DEBUG_FOCUS,
-                  "Focusing window with frame 0x%lx due to button 1 press\n",
-                  frame->xwindow);
-      meta_window_focus (frame->meta_window, event->time);
-    }
+      MetaFrameFlags flags;
 
-  /* don't do the rest of this if on client area */
-  if (control == META_FRAME_CONTROL_CLIENT_AREA)
-    return FALSE; /* not on the frame, just passed through from client */
+      meta_core_get (display, frame->xwindow,
+                     META_CORE_GET_FRAME_FLAGS, &flags,
+                     META_CORE_GET_END);
 
-  /* We want to shade even if we have a GrabOp, since we'll have a move grab
-   * if we double click the titlebar.
-   */
-  if (control == META_FRAME_CONTROL_TITLE &&
-      event->button == 1 &&
-      event->click_count == 2)
-    {
-      meta_core_end_grab_op (display, event->time);
-      return meta_frame_double_click_event (frame, event);
+      if (flags & META_FRAME_ALLOWS_MOVE)
+        {
+          meta_frames_try_grab_op (frames, frame,
+                                   META_GRAB_OP_MOVING,
+                                   event->x_root, event->y_root,
+                                   event->time);
+        }
     }
-
-  if (meta_core_get_grab_op (display) != META_GRAB_OP_NONE)
-    return FALSE; /* already up to something */
-
-  frame->grab_button = event->button;
-
-  switch (event->button)
+  else if (event->button == 2)
     {
-    case 1:
-      return meta_frame_left_click_event (frame, event);
-    case 2:
       return meta_frame_middle_click_event (frame, event);
-    case 3:
+    }
+  else if (event->button == 3)
+    {
       return meta_frame_right_click_event (frame, event);
-    default:
-      return FALSE;
     }
+
+  return TRUE;
 }
 
 static gboolean
-handle_button_release_event (MetaUIFrame *frame,
-                             ClutterButtonEvent *event)
+meta_frames_button_release_event    (GtkWidget           *widget,
+                                     GdkEventButton      *event)
 {
-  Display *display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+  MetaUIFrame *frame;
+  MetaFrames *frames;
+  Display *display;
+
+  frames = META_FRAMES (widget);
+  display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+  frames->current_grab_op = META_GRAB_OP_NONE;
 
-  meta_core_end_grab_op (display, event->time);
+  frame = meta_frames_lookup_window (frames, GDK_WINDOW_XID (event->window));
+  if (frame == NULL)
+    return FALSE;
 
   /* We only handle the releases we handled the presses for (things
    * involving frame controls). Window ops that don't require a
    * frame are handled in the Xlib part of the code, display.c/window.c
    */
-  if (((int) event->button) == frame->grab_button &&
+  if (frame->xwindow == frames->grab_xwindow &&
+      ((int) event->button) == frame->grab_button &&
       frame->button_state == META_BUTTON_STATE_PRESSED)
     {
       switch (frame->prelit_control)
         {
         case META_FRAME_CONTROL_MINIMIZE:
-          meta_window_minimize (frame->meta_window);
+          meta_core_minimize (display, frame->xwindow);
           break;
         case META_FRAME_CONTROL_MAXIMIZE:
           /* Focus the window on the maximize */
-          meta_window_focus (frame->meta_window, event->time);
-          if (meta_prefs_get_raise_on_click ())
-            meta_window_raise (frame->meta_window);
-          meta_window_maximize (frame->meta_window, META_MAXIMIZE_BOTH);
+          meta_core_user_focus (display, frame->xwindow, event->time);
+          meta_core_maximize (display, frame->xwindow);
           break;
         case META_FRAME_CONTROL_UNMAXIMIZE:
-          if (meta_prefs_get_raise_on_click ())
-            meta_window_raise (frame->meta_window);
-          meta_window_unmaximize (frame->meta_window, META_MAXIMIZE_BOTH);
+          meta_core_unmaximize (display, frame->xwindow);
           break;
         case META_FRAME_CONTROL_DELETE:
-          meta_window_delete (frame->meta_window, event->time);
+          meta_core_delete (display, frame->xwindow, event->time);
           break;
         case META_FRAME_CONTROL_SHADE:
-          meta_window_shade (frame->meta_window, event->time);
+          meta_core_shade (display, frame->xwindow, event->time);
           break;
         case META_FRAME_CONTROL_UNSHADE:
-          meta_window_unshade (frame->meta_window, event->time);
+          meta_core_unshade (display, frame->xwindow, event->time);
           break;
         case META_FRAME_CONTROL_ABOVE:
-          meta_window_make_above (frame->meta_window);
+          meta_core_make_above (display, frame->xwindow);
           break;
         case META_FRAME_CONTROL_UNABOVE:
-          meta_window_unmake_above (frame->meta_window);
+          meta_core_unmake_above (display, frame->xwindow);
           break;
         case META_FRAME_CONTROL_STICK:
-          meta_window_stick (frame->meta_window);
+          meta_core_stick (display, frame->xwindow);
           break;
         case META_FRAME_CONTROL_UNSTICK:
-          meta_window_unstick (frame->meta_window);
+          meta_core_unstick (display, frame->xwindow);
           break;
         default:
           break;
@@ -1181,16 +1353,17 @@
        * prelit so to let the user know that it can now be pressed.
        * :)
        */
-      MetaFrameControl control = get_control (frame, event->x, event->y);
-      meta_ui_frame_update_prelit_control (frame, control);
+      MetaFrameControl control = get_control (frames, frame, event->x, event->y);
+      meta_frames_update_prelit_control (frames, frame, control);
     }
 
   return TRUE;
 }
 
 static void
-meta_ui_frame_update_prelit_control (MetaUIFrame     *frame,
-                                     MetaFrameControl control)
+meta_frames_update_prelit_control (MetaFrames      *frames,
+                                   MetaUIFrame     *frame,
+                                   MetaFrameControl control)
 {
   MetaFrameControl old_control;
   MetaCursor cursor;
@@ -1295,18 +1468,26 @@
   frame->button_state = META_BUTTON_STATE_PRELIGHT;
   frame->prelit_control = control;
 
-  redraw_control (frame, old_control);
-  redraw_control (frame, control);
+  redraw_control (frames, frame, old_control);
+  redraw_control (frames, frame, control);
 }
 
 static gboolean
-handle_motion_notify_event (MetaUIFrame *frame,
-                            ClutterMotionEvent *event)
+meta_frames_motion_notify_event     (GtkWidget           *widget,
+                                     GdkEventMotion      *event)
 {
-  MetaFrames *frames = frame->frames;
+  MetaUIFrame *frame;
+  MetaFrames *frames;
   MetaFrameControl control;
 
-  control = get_control (frame, event->x, event->y);
+  frames = META_FRAMES (widget);
+  frame = meta_frames_lookup_window (frames, GDK_WINDOW_XID (event->window));
+  if (frame == NULL)
+    return FALSE;
+
+  frames->last_motion_frame = frame;
+
+  control = get_control (frames, frame, event->x, event->y);
 
   if (frame->button_state == META_BUTTON_STATE_PRESSED)
     {
@@ -1315,34 +1496,57 @@
       if (frame->prelit_control != control)
         {
           frame->button_state = META_BUTTON_STATE_NORMAL;
-          redraw_control (frame, frame->prelit_control);
+          redraw_control (frames, frame, frame->prelit_control);
         }
     }
   else
     {
       /* Update prelit control and cursor */
-      meta_ui_frame_update_prelit_control (frame, control);
+      meta_frames_update_prelit_control (frames, frame, control);
     }
 
-  if ((event->modifier_state & CLUTTER_BUTTON1_MASK) &&
+  if ((event->state & GDK_BUTTON1_MASK) &&
       frames->current_grab_op != META_GRAB_OP_NONE)
     meta_frames_retry_grab_op (frames, event->time);
 
   return TRUE;
 }
 
+static gboolean
+meta_frames_destroy_event           (GtkWidget           *widget,
+                                     GdkEventAny         *event)
+{
+  MetaUIFrame *frame;
+  MetaFrames *frames;
+
+  frames = META_FRAMES (widget);
+
+  frame = meta_frames_lookup_window (frames, GDK_WINDOW_XID (event->window));
+  if (frame == NULL)
+    return FALSE;
+
+  return TRUE;
+}
+
+
 static cairo_region_t *
 get_visible_frame_border_region (MetaUIFrame *frame)
 {
+  MetaRectangle frame_rect;
   cairo_rectangle_int_t area;
   cairo_region_t *frame_border;
   MetaFrameFlags flags;
   MetaFrameType type;
   MetaFrameBorders borders;
-  MetaRectangle frame_rect = frame->meta_window->rect;
+  Display *display;
+
+  display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
 
-  flags = meta_frame_get_flags (frame->meta_window->frame);
-  type = meta_window_get_frame_type (frame->meta_window);
+  meta_core_get (display, frame->xwindow,
+                 META_CORE_GET_FRAME_FLAGS, &flags,
+                 META_CORE_GET_FRAME_TYPE, &type,
+                 META_CORE_GET_FRAME_RECT, &frame_rect,
+                 META_CORE_GET_END);
 
   meta_theme_get_frame_borders (meta_theme_get_default (), frame->style_info,
                                 type, frame->text_height, flags,
@@ -1385,30 +1589,35 @@
  *
  * @frame: This frame
  * @xwindow: The X window for the frame, which has the client window as a child
+ * @width: The width of the framed window including any invisible borders
+ * @height: The height of the framed window including any invisible borders
  * @cr: Used to draw the resulting mask
  */
 void
-meta_ui_frame_get_mask (MetaUIFrame *frame,
-                        cairo_t     *cr)
+meta_frames_get_mask (MetaFrames          *frames,
+                      Window               xwindow,
+                      guint                width,
+                      guint                height,
+                      cairo_t             *cr)
 {
+  MetaUIFrame *frame = meta_frames_lookup_window (frames, xwindow);
   MetaFrameBorders borders;
   MetaFrameFlags flags;
-  MetaRectangle frame_rect;
-  int scale = meta_theme_get_window_scaling_factor ();
 
-  meta_window_get_frame_rect (frame->meta_window, &frame_rect);
+  if (frame == NULL)
+    meta_bug ("No such frame 0x%lx\n", xwindow);
 
-  flags = meta_frame_get_flags (frame->meta_window->frame);
+  meta_core_get (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                 xwindow,
+                 META_CORE_GET_FRAME_FLAGS, &flags,
+                 META_CORE_GET_END);
 
   meta_style_info_set_flags (frame->style_info, flags);
-  meta_ui_frame_get_borders (frame, &borders);
-
-  /* See comment in meta_frame_layout_draw_with_style() for details on HiDPI handling */
-  cairo_scale (cr, scale, scale);
+  meta_ui_frame_get_borders (frames, frame, &borders);
   gtk_render_background (frame->style_info->styles[META_STYLE_ELEMENT_FRAME], cr,
-                         borders.invisible.left / scale,
-                         borders.invisible.top / scale,
-                         frame_rect.width / scale, frame_rect.height / scale);
+                         borders.invisible.left, borders.invisible.top,
+                         width - borders.invisible.left - borders.invisible.right,
+                         height - borders.invisible.top - borders.invisible.bottom);
 }
 
 /* XXX -- this is disgusting. Find a better approach here.
@@ -1446,25 +1655,28 @@
   gdk_cairo_region (cr, region);
   cairo_clip (cr);
 
-  meta_ui_frame_paint (frame, cr);
+  meta_frames_paint (frames, frame, cr);
   cairo_region_destroy (region);
 
   return TRUE;
 }
 
 static void
-meta_ui_frame_paint (MetaUIFrame  *frame,
-                     cairo_t      *cr)
+meta_frames_paint (MetaFrames   *frames,
+                   MetaUIFrame  *frame,
+                   cairo_t      *cr)
 {
   MetaFrameFlags flags;
   MetaFrameType type;
-  cairo_surface_t *mini_icon;
+  GdkPixbuf *mini_icon;
+  int w, h;
   MetaButtonState button_states[META_BUTTON_TYPE_LAST];
   int i;
   int button_type = -1;
   MetaButtonLayout button_layout;
-  MetaWindowX11 *window_x11 = META_WINDOW_X11 (frame->meta_window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  Display *display;
+
+  display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
 
   for (i = 0; i < META_BUTTON_TYPE_LAST; i++)
     button_states[i] = META_BUTTON_STATE_NORMAL;
@@ -1515,11 +1727,15 @@
   if (button_type > -1)
     button_states[button_type] = frame->button_state;
 
-  mini_icon = frame->meta_window->mini_icon;
-  flags = meta_frame_get_flags (frame->meta_window->frame);
-  type = meta_window_get_frame_type (frame->meta_window);
+  meta_core_get (display, frame->xwindow,
+                 META_CORE_GET_FRAME_FLAGS, &flags,
+                 META_CORE_GET_FRAME_TYPE, &type,
+                 META_CORE_GET_MINI_ICON, &mini_icon,
+                 META_CORE_GET_CLIENT_WIDTH, &w,
+                 META_CORE_GET_CLIENT_HEIGHT, &h,
+                 META_CORE_GET_END);
 
-  meta_ui_frame_ensure_layout (frame, type);
+  meta_frames_ensure_layout (frames, frame);
 
   meta_prefs_get_button_layout (&button_layout);
 
@@ -1528,8 +1744,7 @@
                          cr,
                          type,
                          flags,
-                         priv->client_rect.width,
-                         priv->client_rect.height,
+                         w, h,
                          frame->text_layout,
                          frame->text_height,
                          &button_layout,
@@ -1538,26 +1753,42 @@
 }
 
 static gboolean
-handle_enter_notify_event (MetaUIFrame *frame,
-                           ClutterCrossingEvent *event)
+meta_frames_enter_notify_event      (GtkWidget           *widget,
+                                     GdkEventCrossing    *event)
 {
+  MetaUIFrame *frame;
+  MetaFrames *frames;
   MetaFrameControl control;
 
+  frames = META_FRAMES (widget);
+
+  frame = meta_frames_lookup_window (frames, GDK_WINDOW_XID (event->window));
+  if (frame == NULL)
+    return FALSE;
+
   frame->maybe_ignore_leave_notify = FALSE;
 
-  control = get_control (frame, event->x, event->y);
-  meta_ui_frame_update_prelit_control (frame, control);
+  control = get_control (frames, frame, event->x, event->y);
+  meta_frames_update_prelit_control (frames, frame, control);
 
   return TRUE;
 }
 
 static gboolean
-handle_leave_notify_event (MetaUIFrame *frame,
-                           ClutterCrossingEvent *event)
+meta_frames_leave_notify_event      (GtkWidget           *widget,
+                                     GdkEventCrossing    *event)
 {
+  MetaUIFrame *frame;
+  MetaFrames *frames;
   Display *display;
   MetaGrabOp grab_op;
 
+  frames = META_FRAMES (widget);
+
+  frame = meta_frames_lookup_window (frames, GDK_WINDOW_XID (event->window));
+  if (frame == NULL)
+    return FALSE;
+
   display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
   grab_op = meta_core_get_grab_op (display);
 
@@ -1570,32 +1801,11 @@
   if (frame->maybe_ignore_leave_notify)
     return FALSE;
 
-  meta_ui_frame_update_prelit_control (frame, META_FRAME_CONTROL_NONE);
+  meta_frames_update_prelit_control (frames, frame, META_FRAME_CONTROL_NONE);
 
   return TRUE;
 }
 
-gboolean
-meta_ui_frame_handle_event (MetaUIFrame *frame,
-                            const ClutterEvent *event)
-{
-  switch (event->any.type)
-    {
-    case CLUTTER_BUTTON_PRESS:
-      return handle_button_press_event (frame, (ClutterButtonEvent *) event);
-    case CLUTTER_BUTTON_RELEASE:
-      return handle_button_release_event (frame, (ClutterButtonEvent *) event);
-    case CLUTTER_MOTION:
-      return handle_motion_notify_event (frame, (ClutterMotionEvent *) event);
-    case CLUTTER_ENTER:
-      return handle_enter_notify_event (frame, (ClutterCrossingEvent *) event);
-    case CLUTTER_LEAVE:
-      return handle_leave_notify_event (frame, (ClutterCrossingEvent *) event);
-    default:
-      return FALSE;
-    }
-}
-
 static GdkRectangle*
 control_rect (MetaFrameControl control,
               MetaFrameGeometry *fgeom)
@@ -1670,7 +1880,9 @@
 #define TOP_RESIZE_HEIGHT 4
 #define CORNER_SIZE_MULT 2
 static MetaFrameControl
-get_control (MetaUIFrame *frame, int root_x, int root_y)
+get_control (MetaFrames *frames,
+             MetaUIFrame *frame,
+             int x, int y)
 {
   MetaFrameGeometry fgeom;
   MetaFrameFlags flags;
@@ -1678,15 +1890,9 @@
   gboolean has_vert, has_horiz;
   gboolean has_north_resize;
   cairo_rectangle_int_t client;
-  int x, y;
-  int win_x, win_y;
-
-  gdk_window_get_position (frame->window, &win_x, &win_y);
-  x = root_x - win_x;
-  y = root_y - win_y;
 
-  meta_ui_frame_calc_geometry (frame, &fgeom);
-  get_client_rect (&fgeom, &client);
+  meta_frames_calc_geometry (frames, frame, &fgeom);
+  get_client_rect (&fgeom, fgeom.width, fgeom.height, &client);
 
   if (POINT_IN_RECT (x, y, client))
     return META_FRAME_CONTROL_CLIENT_AREA;
@@ -1703,8 +1909,11 @@
   if (POINT_IN_RECT (x, y, fgeom.appmenu_rect.clickable))
     return META_FRAME_CONTROL_APPMENU;
 
-  flags = meta_frame_get_flags (frame->meta_window->frame);
-  type = meta_window_get_frame_type (frame->meta_window);
+  meta_core_get (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()),
+                 frame->xwindow,
+                 META_CORE_GET_FRAME_FLAGS, &flags,
+                 META_CORE_GET_FRAME_TYPE, &type,
+                 META_CORE_GET_END);
 
   has_north_resize = (type != META_FRAME_TYPE_ATTACHED);
   has_vert = (flags & META_FRAME_ALLOWS_VERTICAL_RESIZE) != 0;
@@ -1826,3 +2035,10 @@
   else
     return META_FRAME_CONTROL_TITLE;
 }
+
+static void
+invalidate_whole_window (MetaFrames *frames,
+                         MetaUIFrame *frame)
+{
+  gdk_window_invalidate_rect (frame->window, NULL, FALSE);
+}
diff '--exclude=.git' -urN a/src/ui/frames.h b/src/ui/frames.h
--- a/src/ui/frames.h	2015-10-30 16:39:40.975006658 -0400
+++ b/src/ui/frames.h	2015-10-31 10:11:55.867944867 -0400
@@ -25,7 +25,6 @@
 #include <gtk/gtk.h>
 #include <gdk/gdkx.h>
 #include <meta/common.h>
-#include <meta/types.h>
 #include "theme-private.h"
 
 typedef enum
@@ -73,12 +72,10 @@
 
 struct _MetaUIFrame
 {
-  MetaFrames *frames;
-  MetaWindow *meta_window;
   Window xwindow;
   GdkWindow *window;
   MetaStyleInfo *style_info;
-  MetaFrameLayout *cache_layout;
+  MetaFrameStyle *cache_style;
   PangoLayout *text_layout;
   int text_height;
   char *title; /* NULL once we have a layout */
@@ -97,6 +94,7 @@
   GHashTable *text_heights;
 
   GHashTable *frames;
+  MetaUIFrame *last_motion_frame;
 
   MetaStyleInfo *normal_style;
   GHashTable *style_variants;
@@ -106,6 +104,8 @@
   guint grab_button;
   gdouble grab_x;
   gdouble grab_y;
+
+  Window grab_xwindow;
 };
 
 struct _MetaFramesClass
@@ -118,31 +118,43 @@
 
 MetaFrames *meta_frames_new (int screen_number);
 
-MetaUIFrame * meta_frames_manage_window (MetaFrames *frames,
-                                         MetaWindow *meta_window,
-                                         Window      xwindow,
-                                         GdkWindow  *window);
-
-void meta_ui_frame_unmanage (MetaUIFrame *frame);
-
-void meta_ui_frame_set_title (MetaUIFrame *frame,
-                              const char *title);
-
-void meta_ui_frame_update_style (MetaUIFrame *frame);
-
-void meta_ui_frame_get_borders (MetaUIFrame      *frame,
-                                MetaFrameBorders *borders);
-
-cairo_region_t * meta_ui_frame_get_bounds (MetaUIFrame *frame);
-
-void meta_ui_frame_get_mask (MetaUIFrame *frame,
-                             cairo_t     *cr);
-
-void meta_ui_frame_move_resize (MetaUIFrame *frame,
-                                int x, int y, int width, int height);
-
-void meta_ui_frame_queue_draw (MetaUIFrame *frame);
-
-gboolean meta_ui_frame_handle_event (MetaUIFrame *frame, const ClutterEvent *event);
+void meta_frames_manage_window (MetaFrames *frames,
+                                Window      xwindow,
+				GdkWindow  *window);
+void meta_frames_unmanage_window (MetaFrames *frames,
+                                  Window      xwindow);
+void meta_frames_set_title (MetaFrames *frames,
+                            Window      xwindow,
+                            const char *title);
+
+void meta_frames_update_frame_style (MetaFrames *frames,
+                                     Window      xwindow);
+
+void meta_frames_repaint_frame (MetaFrames *frames,
+                                Window      xwindow);
+
+void meta_frames_get_borders (MetaFrames *frames,
+                              Window xwindow,
+                              MetaFrameBorders *borders);
+
+cairo_region_t *meta_frames_get_frame_bounds (MetaFrames *frames,
+                                              Window      xwindow,
+                                              int         window_width,
+                                              int         window_height);
+
+void meta_frames_get_mask (MetaFrames *frames,
+                           Window      xwindow,
+                           guint       width,
+                           guint       height,
+                           cairo_t    *cr);
+
+void meta_frames_move_resize_frame (MetaFrames *frames,
+				    Window      xwindow,
+				    int         x,
+				    int         y,
+				    int         width,
+				    int         height);
+void meta_frames_queue_draw (MetaFrames *frames,
+                             Window      xwindow);
 
 #endif
diff '--exclude=.git' -urN a/src/ui/gradient.c b/src/ui/gradient.c
--- a/src/ui/gradient.c	1969-12-31 19:00:00.000000000 -0500
+++ b/src/ui/gradient.c	2015-10-31 13:33:56.668252083 -0400
@@ -0,0 +1,902 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2001 Havoc Pennington, 99% copied from wrlib in
+ * WindowMaker, Copyright (C) 1997-2000 Dan Pascu and Alfredo Kojima
+ * Copyright (C) 2005 Elijah Newren
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.  */
+
+/**
+ * SECTION:gradient
+ * @title: Gradients
+ * @short_description: Metacity gradient rendering
+ */
+
+#include <meta/gradient.h>
+#include <meta/util.h>
+#include <string.h>
+
+/* This is all Alfredo's and Dan's usual very nice WindowMaker code,
+ * slightly GTK-ized
+ */
+static GdkPixbuf* meta_gradient_create_horizontal       (int             width,
+                                                         int             height,
+                                                         const GdkRGBA  *from,
+                                                         const GdkRGBA  *to);
+static GdkPixbuf* meta_gradient_create_vertical         (int             width,
+                                                         int             height,
+                                                         const GdkRGBA  *from,
+                                                         const GdkRGBA  *to);
+static GdkPixbuf* meta_gradient_create_diagonal         (int             width,
+                                                         int             height,
+                                                         const GdkRGBA  *from,
+                                                         const GdkRGBA  *to);
+static GdkPixbuf* meta_gradient_create_multi_horizontal (int             width,
+                                                         int             height,
+                                                         const GdkRGBA  *colors,
+                                                         int             count);
+static GdkPixbuf* meta_gradient_create_multi_vertical   (int             width,
+                                                         int             height,
+                                                         const GdkRGBA  *colors,
+                                                         int             count);
+static GdkPixbuf* meta_gradient_create_multi_diagonal   (int             width,
+                                                         int             height,
+                                                         const GdkRGBA  *colors,
+                                                         int             count);
+
+
+/* Used as the destroy notification function for gdk_pixbuf_new() */
+static void
+free_buffer (guchar *pixels, gpointer data)
+{
+  g_free (pixels);
+}
+
+static GdkPixbuf*
+blank_pixbuf (int width, int height)
+{
+  guchar *buf;
+  int rowstride;
+
+  g_return_val_if_fail (width > 0, NULL);
+  g_return_val_if_fail (height > 0, NULL);
+
+  /* Always align rows to 32-bit boundaries */
+  rowstride = 4 * ((4 * width + 4) / 4);
+
+  buf = g_try_malloc (height * rowstride);
+  if (!buf)
+    return NULL;
+
+  return gdk_pixbuf_new_from_data (buf, GDK_COLORSPACE_RGB,
+                                   TRUE, 8,
+                                   width, height, rowstride,
+                                   free_buffer, NULL);
+}
+
+/**
+ * meta_gradient_create_simple:
+ * @width: Width in pixels
+ * @height: Height in pixels
+ * @from: Starting color
+ * @to: Ending color
+ * @style: Gradient style
+ *
+ * Returns: (transfer full): A new linear gradient
+ */
+GdkPixbuf*
+meta_gradient_create_simple (int              width,
+                             int              height,
+                             const GdkRGBA   *from,
+                             const GdkRGBA   *to,
+                             MetaGradientType style)
+{
+  switch (style)
+    {
+    case META_GRADIENT_HORIZONTAL:
+      return meta_gradient_create_horizontal (width, height,
+                                              from, to);
+    case META_GRADIENT_VERTICAL:
+      return meta_gradient_create_vertical (width, height,
+                                            from, to);
+
+    case META_GRADIENT_DIAGONAL:
+      return meta_gradient_create_diagonal (width, height,
+                                            from, to);
+    case META_GRADIENT_LAST:
+      break;
+    }
+  g_assert_not_reached ();
+  return NULL;
+}
+
+/**
+ * meta_gradient_create_multi:
+ * @width: Width in pixels
+ * @height: Height in pixels
+ * @colors: (array length=n_colors): Array of colors
+ * @n_colors: Number of colors
+ * @style: Gradient style
+ *
+ * Returns: (transfer full): A new multi-step linear gradient
+ */
+GdkPixbuf*
+meta_gradient_create_multi (int              width,
+                            int              height,
+                            const GdkRGBA   *colors,
+                            int              n_colors,
+                            MetaGradientType style)
+{
+
+  if (n_colors > 2)
+    {
+      switch (style)
+        {
+        case META_GRADIENT_HORIZONTAL:
+          return meta_gradient_create_multi_horizontal (width, height, colors, n_colors);
+        case META_GRADIENT_VERTICAL:
+          return meta_gradient_create_multi_vertical (width, height, colors, n_colors);
+        case META_GRADIENT_DIAGONAL:
+          return meta_gradient_create_multi_diagonal (width, height, colors, n_colors);
+        case META_GRADIENT_LAST:
+          g_assert_not_reached ();
+          break;
+        }
+    }
+  else if (n_colors > 1)
+    {
+      return meta_gradient_create_simple (width, height, &colors[0], &colors[1],
+                                          style);
+    }
+  else if (n_colors > 0)
+    {
+      return meta_gradient_create_simple (width, height, &colors[0], &colors[0],
+                                          style);
+    }
+  g_assert_not_reached ();
+  return NULL;
+}
+
+/**
+ * meta_gradient_create_interwoven: (skip)
+ * @width: Width in pixels
+ * @height: Height in pixels
+ * @colors1: Array of colors
+ * @thickness1: Thickness
+ * @colors2: Array of colors
+ * @thickness2: Thickness
+ *
+ * Interwoven essentially means we have two vertical gradients,
+ * cut into horizontal strips of the given thickness, and then the strips
+ * are alternated. I'm not sure what it's good for, just copied since
+ * WindowMaker had it.
+ */
+GdkPixbuf*
+meta_gradient_create_interwoven (int            width,
+                                 int            height,
+                                 const GdkRGBA  colors1[2],
+                                 int            thickness1,
+                                 const GdkRGBA  colors2[2],
+                                 int            thickness2)
+{
+
+  int i, j, k, l, ll;
+  long r1, g1, b1, a1, dr1, dg1, db1, da1;
+  long r2, g2, b2, a2, dr2, dg2, db2, da2;
+  GdkPixbuf *pixbuf;
+  unsigned char *ptr;
+  unsigned char *pixels;
+  int rowstride;
+
+  pixbuf = blank_pixbuf (width, height);
+  if (pixbuf == NULL)
+    return NULL;
+
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+
+  r1 = (long)(colors1[0].red*0xffffff);
+  g1 = (long)(colors1[0].green*0xffffff);
+  b1 = (long)(colors1[0].blue*0xffffff);
+  a1 = (long)(colors1[0].alpha*0xffffff);
+
+  r2 = (long)(colors2[0].red*0xffffff);
+  g2 = (long)(colors2[0].green*0xffffff);
+  b2 = (long)(colors2[0].blue*0xffffff);
+  a2 = (long)(colors2[0].alpha*0xffffff);
+
+  dr1 = ((colors1[1].red-colors1[0].red)*0xffffff)/(int)height;
+  dg1 = ((colors1[1].green-colors1[0].green)*0xffffff)/(int)height;
+  db1 = ((colors1[1].blue-colors1[0].blue)*0xffffff)/(int)height;
+  da1 = ((colors1[1].alpha-colors1[0].alpha)*0xffffff)/(int)height;
+
+  dr2 = ((colors2[1].red-colors2[0].red)*0xffffff)/(int)height;
+  dg2 = ((colors2[1].green-colors2[0].green)*0xffffff)/(int)height;
+  db2 = ((colors2[1].blue-colors2[0].blue)*0xffffff)/(int)height;
+  da2 = ((colors2[1].alpha-colors2[0].alpha)*0xffffff)/(int)height;
+
+  for (i=0,k=0,l=0,ll=thickness1; i<height; i++)
+    {
+      ptr = pixels + i * rowstride;
+
+      if (k == 0)
+        {
+          ptr[0] = (unsigned char) (r1>>16);
+          ptr[1] = (unsigned char) (g1>>16);
+          ptr[2] = (unsigned char) (b1>>16);
+          ptr[3] = (unsigned char) (a1>>16);
+        }
+      else
+        {
+          ptr[0] = (unsigned char) (r2>>16);
+          ptr[1] = (unsigned char) (g2>>16);
+          ptr[2] = (unsigned char) (b2>>16);
+          ptr[3] = (unsigned char) (a2>>16);
+        }
+
+      for (j=1; j <= width/2; j *= 2)
+        memcpy (&(ptr[j*4]), ptr, j*4);
+      memcpy (&(ptr[j*4]), ptr, (width - j)*4);
+
+      if (++l == ll)
+        {
+          if (k == 0)
+            {
+              k = 1;
+              ll = thickness2;
+            }
+          else
+            {
+              k = 0;
+              ll = thickness1;
+            }
+          l = 0;
+        }
+      r1+=dr1;
+      g1+=dg1;
+      b1+=db1;
+      a1+=da1;
+
+      r2+=dr2;
+      g2+=dg2;
+      b2+=db2;
+      a2+=da2;
+    }
+
+  return pixbuf;
+}
+
+/*
+ *----------------------------------------------------------------------
+ * meta_gradient_create_horizontal--
+ * 	Renders a horizontal linear gradient of the specified size in the
+ * GdkPixbuf format with a border of the specified type.
+ *
+ * Returns:
+ * 	A 24bit GdkPixbuf with the gradient (no alpha channel).
+ *
+ * Side effects:
+ * 	None
+ *----------------------------------------------------------------------
+ */
+static GdkPixbuf*
+meta_gradient_create_horizontal (int width, int height,
+                                 const GdkRGBA *from,
+                                 const GdkRGBA *to)
+{
+  int i;
+  long r, g, b, a, dr, dg, db, da;
+  GdkPixbuf *pixbuf;
+  unsigned char *ptr;
+  unsigned char *pixels;
+  int r0, g0, b0, a0;
+  int rf, gf, bf, af;
+  int rowstride;
+
+  pixbuf = blank_pixbuf (width, height);
+  if (pixbuf == NULL)
+    return NULL;
+
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  ptr = pixels;
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+
+  r0 = (guchar) (from->red * 0xff);
+  g0 = (guchar) (from->green * 0xff);
+  b0 = (guchar) (from->blue * 0xff);
+  a0 = (guchar) (from->alpha * 0xff);
+  rf = (guchar) (to->red * 0xff);
+  gf = (guchar) (to->green * 0xff);
+  bf = (guchar) (to->blue * 0xff);
+  af = (guchar) (to->alpha * 0xff);
+
+  r = r0 << 16;
+  g = g0 << 16;
+  b = b0 << 16;
+  a = a0 << 16;
+
+  dr = ((rf-r0)<<16)/(int)width;
+  dg = ((gf-g0)<<16)/(int)width;
+  db = ((bf-b0)<<16)/(int)width;
+  da = ((af-a0)<<16)/(int)width;
+  /* render the first line */
+  for (i=0; i<width; i++)
+    {
+      *(ptr++) = (unsigned char)(r>>16);
+      *(ptr++) = (unsigned char)(g>>16);
+      *(ptr++) = (unsigned char)(b>>16);
+      *(ptr++) = (unsigned char)(a>>16);
+      r += dr;
+      g += dg;
+      b += db;
+      a += da;
+    }
+
+  /* copy the first line to the other lines */
+  for (i=1; i<height; i++)
+    {
+      memcpy (&(pixels[i*rowstride]), pixels, rowstride);
+    }
+  return pixbuf;
+}
+
+/*
+ *----------------------------------------------------------------------
+ * meta_gradient_create_vertical--
+ *      Renders a vertical linear gradient of the specified size in the
+ * GdkPixbuf format with a border of the specified type.
+ *
+ * Returns:
+ *      A 24bit GdkPixbuf with the gradient (no alpha channel).
+ *
+ * Side effects:
+ *      None
+ *----------------------------------------------------------------------
+ */
+static GdkPixbuf*
+meta_gradient_create_vertical (int width, int height,
+                               const GdkRGBA *from,
+                               const GdkRGBA *to)
+{
+  int i, j;
+  long r, g, b, a, dr, dg, db, da;
+  GdkPixbuf *pixbuf;
+  unsigned char *ptr;
+  int r0, g0, b0, a0;
+  int rf, gf, bf, af;
+  int rowstride;
+  unsigned char *pixels;
+
+  pixbuf = blank_pixbuf (width, height);
+  if (pixbuf == NULL)
+    return NULL;
+
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+
+  r0 = (guchar) (from->red * 0xff);
+  g0 = (guchar) (from->green * 0xff);
+  b0 = (guchar) (from->blue * 0xff);
+  a0 = (guchar) (from->alpha * 0xff);
+  rf = (guchar) (to->red * 0xff);
+  gf = (guchar) (to->green * 0xff);
+  bf = (guchar) (to->blue * 0xff);
+  af = (guchar) (to->alpha * 0xff);
+
+  r = r0<<16;
+  g = g0<<16;
+  b = b0<<16;
+  a = a0<<16;
+
+  dr = ((rf-r0)<<16)/(int)height;
+  dg = ((gf-g0)<<16)/(int)height;
+  db = ((bf-b0)<<16)/(int)height;
+  da = ((af-a0)<<16)/(int)height;
+
+  for (i=0; i<height; i++)
+    {
+      ptr = pixels + i * rowstride;
+
+      ptr[0] = (unsigned char)(r>>16);
+      ptr[1] = (unsigned char)(g>>16);
+      ptr[2] = (unsigned char)(b>>16);
+      ptr[3] = (unsigned char)(a>>16);
+
+      for (j=1; j <= width/2; j *= 2)
+        memcpy (&(ptr[j*4]), ptr, j*4);
+      memcpy (&(ptr[j*4]), ptr, (width - j)*4);
+
+      r+=dr;
+      g+=dg;
+      b+=db;
+      a+=da;
+    }
+  return pixbuf;
+}
+
+
+/*
+ *----------------------------------------------------------------------
+ * meta_gradient_create_diagonal--
+ *      Renders a diagonal linear gradient of the specified size in the
+ * GdkPixbuf format with a border of the specified type.
+ *
+ * Returns:
+ *      A 24bit GdkPixbuf with the gradient (no alpha channel).
+ *
+ * Side effects:
+ *      None
+ *----------------------------------------------------------------------
+ */
+
+
+static GdkPixbuf*
+meta_gradient_create_diagonal (int width, int height,
+                               const GdkRGBA *from,
+                               const GdkRGBA *to)
+{
+  GdkPixbuf *pixbuf, *tmp;
+  int j;
+  float a, offset;
+  unsigned char *ptr;
+  unsigned char *pixels;
+  int rowstride;
+
+  if (width == 1)
+    return meta_gradient_create_vertical (width, height, from, to);
+  else if (height == 1)
+    return meta_gradient_create_horizontal (width, height, from, to);
+
+  pixbuf = blank_pixbuf (width, height);
+  if (pixbuf == NULL)
+    return NULL;
+
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+
+  tmp = meta_gradient_create_horizontal (2*width-1, 1, from, to);
+  if (!tmp)
+    {
+      g_object_unref (G_OBJECT (pixbuf));
+      return NULL;
+    }
+
+  ptr = gdk_pixbuf_get_pixels (tmp);
+
+  a = ((float)(width - 1))/((float)(height - 1));
+  width = width * 4;
+
+  /* copy the first line to the other lines with corresponding offset */
+  for (j=0, offset=0.0; j<rowstride*height; j += rowstride)
+    {
+      memcpy (&(pixels[j]), &ptr[4*(int)offset], width);
+      offset += a;
+    }
+
+  g_object_unref (G_OBJECT (tmp));
+  return pixbuf;
+}
+
+
+static GdkPixbuf*
+meta_gradient_create_multi_horizontal (int width, int height,
+                                       const GdkRGBA *colors,
+                                       int count)
+{
+  int i, j, k;
+  long r, g, b, a, dr, dg, db, da;
+  GdkPixbuf *pixbuf;
+  unsigned char *ptr;
+  unsigned char *pixels;
+  int width2;
+  int rowstride;
+
+  g_return_val_if_fail (count > 2, NULL);
+
+  pixbuf = blank_pixbuf (width, height);
+  if (pixbuf == NULL)
+    return NULL;
+
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  ptr = pixels;
+
+  if (count > width)
+    count = width;
+
+  if (count > 1)
+    width2 = width/(count-1);
+  else
+    width2 = width;
+
+  k = 0;
+
+  r = (long)(colors[0].red * 0xffffff);
+  g = (long)(colors[0].green * 0xffffff);
+  b = (long)(colors[0].blue * 0xffffff);
+  a = (long)(colors[0].alpha * 0xffffff);
+
+  /* render the first line */
+  for (i=1; i<count; i++)
+    {
+      dr = (int)((colors[i].red   - colors[i-1].red)  *0xffffff)/(int)width2;
+      dg = (int)((colors[i].green - colors[i-1].green)*0xffffff)/(int)width2;
+      db = (int)((colors[i].blue  - colors[i-1].blue) *0xffffff)/(int)width2;
+      da = (int)((colors[i].alpha  - colors[i-1].alpha) *0xffffff)/(int)width2;
+      for (j=0; j<width2; j++)
+        {
+          *ptr++ = (unsigned char)(r>>16);
+          *ptr++ = (unsigned char)(g>>16);
+          *ptr++ = (unsigned char)(b>>16);
+          *ptr++ = (unsigned char)(a>>16);
+          r += dr;
+          g += dg;
+          b += db;
+          a += da;
+          k++;
+	}
+      r = (long)(colors[i].red   * 0xffffff);
+      g = (long)(colors[i].green * 0xffffff);
+      b = (long)(colors[i].blue  * 0xffffff);
+      a = (long)(colors[i].alpha  * 0xffffff);
+    }
+  for (j=k; j<width; j++)
+    {
+      *ptr++ = (unsigned char)(r>>16);
+      *ptr++ = (unsigned char)(g>>16);
+      *ptr++ = (unsigned char)(b>>16);
+      *ptr++ = (unsigned char)(a>>16);
+    }
+
+  /* copy the first line to the other lines */
+  for (i=1; i<height; i++)
+    {
+      memcpy (&(pixels[i*rowstride]), pixels, rowstride);
+    }
+  return pixbuf;
+}
+
+static GdkPixbuf*
+meta_gradient_create_multi_vertical (int width, int height,
+                                     const GdkRGBA *colors,
+                                     int count)
+{
+  int i, j, k;
+  long r, g, b, a, dr, dg, db, da;
+  GdkPixbuf *pixbuf;
+  unsigned char *ptr, *tmp, *pixels;
+  int height2;
+  int x;
+  int rowstride;
+
+  g_return_val_if_fail (count > 2, NULL);
+
+  pixbuf = blank_pixbuf (width, height);
+  if (pixbuf == NULL)
+    return NULL;
+
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  ptr = pixels;
+
+  if (count > height)
+    count = height;
+
+  if (count > 1)
+    height2 = height/(count-1);
+  else
+    height2 = height;
+
+  k = 0;
+
+  r = (long)(colors[0].red * 0xffffff);
+  g = (long)(colors[0].green * 0xffffff);
+  b = (long)(colors[0].blue * 0xffffff);
+  a = (long)(colors[0].alpha * 0xffffff);
+
+  for (i=1; i<count; i++)
+    {
+      dr = (int)((colors[i].red   - colors[i-1].red)  *0xffffff)/(int)height2;
+      dg = (int)((colors[i].green - colors[i-1].green)*0xffffff)/(int)height2;
+      db = (int)((colors[i].blue  - colors[i-1].blue) *0xffffff)/(int)height2;
+      da = (int)((colors[i].alpha  - colors[i-1].alpha) *0xffffff)/(int)height2;
+
+      for (j=0; j<height2; j++)
+        {
+          ptr[0] = (unsigned char)(r>>16);
+          ptr[1] = (unsigned char)(g>>16);
+          ptr[2] = (unsigned char)(b>>16);
+          ptr[3] = (unsigned char)(a>>16);
+
+          for (x=1; x <= width/2; x *= 2)
+            memcpy (&(ptr[x*4]), ptr, x*4);
+          memcpy (&(ptr[x*4]), ptr, (width - x)*4);
+
+          ptr += rowstride;
+
+          r += dr;
+          g += dg;
+          b += db;
+          a += da;
+          k++;
+	}
+      r = (long)(colors[i].red   * 0xffffff);
+      g = (long)(colors[i].green * 0xffffff);
+      b = (long)(colors[i].blue  * 0xffffff);
+      a = (long)(colors[i].alpha  * 0xffffff);
+    }
+
+  if (k<height)
+    {
+      tmp = ptr;
+
+      ptr[0] = (unsigned char) (r>>16);
+      ptr[1] = (unsigned char) (g>>16);
+      ptr[2] = (unsigned char) (b>>16);
+      ptr[3] = (unsigned char) (a>>16);
+
+      for (x=1; x <= width/2; x *= 2)
+        memcpy (&(ptr[x*4]), ptr, x*4);
+      memcpy (&(ptr[x*4]), ptr, (width - x)*4);
+
+      ptr += rowstride;
+
+      for (j=k+1; j<height; j++)
+        {
+          memcpy (ptr, tmp, rowstride);
+          ptr += rowstride;
+        }
+    }
+
+  return pixbuf;
+}
+
+
+static GdkPixbuf*
+meta_gradient_create_multi_diagonal (int width, int height,
+                                     const GdkRGBA *colors,
+                                     int count)
+{
+  GdkPixbuf *pixbuf, *tmp;
+  float a, offset;
+  int j;
+  unsigned char *ptr;
+  unsigned char *pixels;
+  int rowstride;
+
+  g_return_val_if_fail (count > 2, NULL);
+
+  if (width == 1)
+    return meta_gradient_create_multi_vertical (width, height, colors, count);
+  else if (height == 1)
+    return meta_gradient_create_multi_horizontal (width, height, colors, count);
+
+  pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, FALSE, 8,
+                           width, height);
+  if (pixbuf == NULL)
+    return NULL;
+
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+
+  if (count > width)
+    count = width;
+  if (count > height)
+    count = height;
+
+  if (count > 2)
+    tmp = meta_gradient_create_multi_horizontal (2*width-1, 1, colors, count);
+  else
+    /* wrlib multiplies these colors by 256 before passing them in, but
+     * I think it's a bug in wrlib, so changed here. I could be wrong
+     * though, if we notice two-color multi diagonals not working.
+     */
+    tmp = meta_gradient_create_horizontal (2*width-1, 1,
+                                           &colors[0], &colors[1]);
+
+  if (!tmp)
+    {
+      g_object_unref (G_OBJECT (pixbuf));
+      return NULL;
+    }
+  ptr = gdk_pixbuf_get_pixels (tmp);
+
+  a = ((float)(width - 1))/((float)(height - 1));
+  width = width * 3;
+
+  /* copy the first line to the other lines with corresponding offset */
+  for (j=0, offset=0; j<rowstride*height; j += rowstride)
+    {
+      memcpy (&(pixels[j]), &ptr[3*(int)offset], width);
+      offset += a;
+    }
+
+  g_object_unref (G_OBJECT (tmp));
+  return pixbuf;
+}
+
+static void
+simple_multiply_alpha (GdkPixbuf *pixbuf,
+                       guchar     alpha)
+{
+  guchar *pixels;
+  int rowstride;
+  int height;
+  int row;
+
+  g_return_if_fail (GDK_IS_PIXBUF (pixbuf));
+
+  if (alpha == 255)
+    return;
+
+  g_assert (gdk_pixbuf_get_has_alpha (pixbuf));
+
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+
+  row = 0;
+  while (row < height)
+    {
+      guchar *p;
+      guchar *end;
+
+      p = pixels + row * rowstride;
+      end = p + rowstride;
+
+      while (p != end)
+        {
+          p += 3; /* skip RGB */
+
+          /* multiply the two alpha channels. not sure this is right.
+           * but some end cases are that if the pixbuf contains 255,
+           * then it should be modified to contain "alpha"; if the
+           * pixbuf contains 0, it should remain 0.
+           */
+          /* ((*p / 255.0) * (alpha / 255.0)) * 255; */
+          *p = (guchar) (((int) *p * (int) alpha) / (int) 255);
+
+          ++p; /* skip A */
+        }
+
+      ++row;
+    }
+}
+
+static void
+meta_gradient_add_alpha_horizontal (GdkPixbuf           *pixbuf,
+                                    const unsigned char *alphas,
+                                    int                  n_alphas)
+{
+  int i, j;
+  long a, da;
+  unsigned char *p;
+  unsigned char *pixels;
+  int width2;
+  int rowstride;
+  int width, height;
+  unsigned char *gradient;
+  unsigned char *gradient_p;
+  unsigned char *gradient_end;
+
+  g_return_if_fail (n_alphas > 0);
+
+  if (n_alphas == 1)
+    {
+      /* Optimize this */
+      simple_multiply_alpha (pixbuf, alphas[0]);
+      return;
+    }
+
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+
+  gradient = g_new (unsigned char, width);
+  gradient_end = gradient + width;
+
+  if (n_alphas > width)
+    n_alphas = width;
+
+  if (n_alphas > 1)
+    width2 = width / (n_alphas - 1);
+  else
+    width2 = width;
+
+  a = alphas[0] << 8;
+  gradient_p = gradient;
+
+  /* render the gradient into an array */
+  for (i = 1; i < n_alphas; i++)
+    {
+      da = (((int)(alphas[i] - (int) alphas[i-1])) << 8) / (int) width2;
+
+      for (j = 0; j < width2; j++)
+        {
+          *gradient_p++ = (a >> 8);
+
+          a += da;
+	}
+
+      a = alphas[i] << 8;
+    }
+
+  /* get leftover pixels */
+  while (gradient_p != gradient_end)
+    {
+      *gradient_p++ = a >> 8;
+    }
+
+  /* Now for each line of the pixbuf, fill in with the gradient */
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+
+  p = pixels;
+  i = 0;
+  while (i < height)
+    {
+      unsigned char *row_end = p + rowstride;
+      gradient_p = gradient;
+
+      p += 3;
+      while (gradient_p != gradient_end)
+        {
+          /* multiply the two alpha channels. not sure this is right.
+           * but some end cases are that if the pixbuf contains 255,
+           * then it should be modified to contain "alpha"; if the
+           * pixbuf contains 0, it should remain 0.
+           */
+          /* ((*p / 255.0) * (alpha / 255.0)) * 255; */
+          *p = (guchar) (((int) *p * (int) *gradient_p) / (int) 255);
+
+          p += 4;
+          ++gradient_p;
+        }
+
+      p = row_end;
+      ++i;
+    }
+
+  g_free (gradient);
+}
+
+void
+meta_gradient_add_alpha (GdkPixbuf       *pixbuf,
+                         const guchar    *alphas,
+                         int              n_alphas,
+                         MetaGradientType type)
+{
+  g_return_if_fail (GDK_IS_PIXBUF (pixbuf));
+  g_return_if_fail (gdk_pixbuf_get_has_alpha (pixbuf));
+  g_return_if_fail (n_alphas > 0);
+
+  switch (type)
+    {
+    case META_GRADIENT_HORIZONTAL:
+      meta_gradient_add_alpha_horizontal (pixbuf, alphas, n_alphas);
+      break;
+
+    case META_GRADIENT_VERTICAL:
+      g_printerr ("metacity: vertical alpha channel gradient not implemented yet\n");
+      break;
+
+    case META_GRADIENT_DIAGONAL:
+      g_printerr ("metacity: diagonal alpha channel gradient not implemented yet\n");
+      break;
+
+    case META_GRADIENT_LAST:
+      g_assert_not_reached ();
+      break;
+    }
+}
diff '--exclude=.git' -urN a/src/ui/resizepopup.c b/src/ui/resizepopup.c
--- a/src/ui/resizepopup.c	1969-12-31 19:00:00.000000000 -0500
+++ b/src/ui/resizepopup.c	2015-10-31 08:10:52.054906336 -0400
@@ -0,0 +1,238 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* Metacity resizing-terminal-window feedback */
+
+/*
+ * Copyright (C) 2001 Havoc Pennington
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <config.h>
+#include "resizepopup.h"
+#include "util-private.h"
+#include <gtk/gtk.h>
+#include <gdk/gdkx.h>
+
+struct _MetaResizePopup
+{
+  GtkWidget *size_window;
+  GtkWidget *size_label;
+  Display *display;
+  int screen_number;
+
+  int vertical_size;
+  int horizontal_size;
+
+  gboolean showing;
+
+  MetaRectangle rect;
+};
+
+MetaResizePopup*
+meta_ui_resize_popup_new (Display *display,
+                          int      screen_number)
+{
+  MetaResizePopup *popup;
+
+  popup = g_new0 (MetaResizePopup, 1);
+
+  popup->display = display;
+  popup->screen_number = screen_number;
+
+  return popup;
+}
+
+void
+meta_ui_resize_popup_free (MetaResizePopup *popup)
+{
+  g_return_if_fail (popup != NULL);
+
+  if (popup->size_window)
+    gtk_widget_destroy (popup->size_window);
+
+  g_free (popup);
+}
+
+static gboolean
+size_window_draw (GtkWidget *widget,
+                  cairo_t *cr,
+                  MetaResizePopup *popup)
+{
+  GtkStyleContext *context;
+  gint width, height;
+
+  context = gtk_widget_get_style_context (widget);
+  width = gtk_widget_get_allocated_width (widget);
+  height = gtk_widget_get_allocated_height (widget);
+
+  gtk_render_background (context, cr, 0, 0, width, height);
+  gtk_render_frame (context, cr, 0, 0, width, height);
+
+  return FALSE;
+}
+
+static void
+ensure_size_window (MetaResizePopup *popup)
+{
+  GdkVisual *visual;
+  GdkScreen *screen;
+
+  if (popup->size_window)
+    return;
+
+  popup->size_window = gtk_window_new (GTK_WINDOW_POPUP);
+  screen = gdk_display_get_screen (gdk_x11_lookup_xdisplay (popup->display),
+                                   popup->screen_number);
+  visual = gdk_screen_get_rgba_visual (screen);
+
+  gtk_window_set_screen (GTK_WINDOW (popup->size_window), screen);
+  if (visual != NULL)
+    gtk_widget_set_visual (popup->size_window, visual);
+
+  gtk_window_set_type_hint (GTK_WINDOW (popup->size_window),
+                            GDK_WINDOW_TYPE_HINT_TOOLTIP);
+  gtk_window_set_resizable (GTK_WINDOW (popup->size_window), FALSE);
+
+  gtk_widget_set_app_paintable (popup->size_window, TRUE);
+  gtk_style_context_add_class (gtk_widget_get_style_context (popup->size_window),
+                               GTK_STYLE_CLASS_TOOLTIP);
+  g_signal_connect (popup->size_window, "draw",
+                    G_CALLBACK (size_window_draw), popup);
+
+  popup->size_label = gtk_label_new ("");
+  g_object_set (popup->size_label, "margin", 6, NULL);
+
+  gtk_container_add (GTK_CONTAINER (popup->size_window), popup->size_label);
+
+  gtk_widget_show (popup->size_label);
+}
+
+static void
+update_size_window (MetaResizePopup *popup)
+{
+  char *str;
+  int x, y;
+  int width, height;
+
+  g_return_if_fail (popup->size_window != NULL);
+
+  /* Translators: This represents the size of a window.  The first number is
+   * the width of the window and the second is the height.
+   */
+  str = g_strdup_printf (_("%d x %d"),
+                         popup->horizontal_size,
+                         popup->vertical_size);
+
+  gtk_label_set_text (GTK_LABEL (popup->size_label), str);
+
+  g_free (str);
+
+  gtk_window_get_size (GTK_WINDOW (popup->size_window), &width, &height);
+
+  x = popup->rect.x + (popup->rect.width - width) / 2;
+  y = popup->rect.y + (popup->rect.height - height) / 2;
+
+  if (gtk_widget_get_realized (popup->size_window))
+    {
+      /* using move_resize to avoid jumpiness */
+      gdk_window_move_resize (gtk_widget_get_window (popup->size_window),
+                              x, y,
+                              width, height);
+    }
+  else
+    {
+      gtk_window_move   (GTK_WINDOW (popup->size_window),
+                         x, y);
+    }
+}
+
+static void
+sync_showing (MetaResizePopup *popup)
+{
+  if (popup->showing)
+    {
+      if (popup->size_window)
+        gtk_widget_show (popup->size_window);
+
+      if (popup->size_window && gtk_widget_get_realized (popup->size_window))
+        gdk_window_raise (gtk_widget_get_window (popup->size_window));
+    }
+  else
+    {
+      if (popup->size_window)
+        gtk_widget_hide (popup->size_window);
+    }
+}
+
+void
+meta_ui_resize_popup_set (MetaResizePopup *popup,
+                          MetaRectangle    rect,
+                          int              base_width,
+                          int              base_height,
+                          int              width_inc,
+                          int              height_inc)
+{
+  gboolean need_update_size;
+  int display_w, display_h;
+
+  g_return_if_fail (popup != NULL);
+
+  need_update_size = FALSE;
+
+  display_w = rect.width - base_width;
+  if (width_inc > 0)
+    display_w /= width_inc;
+
+  display_h = rect.height - base_height;
+  if (height_inc > 0)
+    display_h /= height_inc;
+
+  if (!meta_rectangle_equal(&popup->rect, &rect) ||
+      display_w != popup->horizontal_size ||
+      display_h != popup->vertical_size)
+    need_update_size = TRUE;
+
+  popup->rect = rect;
+  popup->vertical_size = display_h;
+  popup->horizontal_size = display_w;
+
+  if (need_update_size)
+    {
+      ensure_size_window (popup);
+      update_size_window (popup);
+    }
+
+  sync_showing (popup);
+}
+
+void
+meta_ui_resize_popup_set_showing  (MetaResizePopup *popup,
+                                   gboolean         showing)
+{
+  g_return_if_fail (popup != NULL);
+
+  if (showing == popup->showing)
+    return;
+
+  popup->showing = !!showing;
+
+  if (popup->showing)
+    {
+      ensure_size_window (popup);
+      update_size_window (popup);
+    }
+
+  sync_showing (popup);
+}
diff '--exclude=.git' -urN a/src/ui/resizepopup.h b/src/ui/resizepopup.h
--- a/src/ui/resizepopup.h	1969-12-31 19:00:00.000000000 -0500
+++ b/src/ui/resizepopup.h	2015-10-31 08:10:52.054906336 -0400
@@ -0,0 +1,47 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* Mutter resizing-terminal-window feedback */
+
+/*
+ * Copyright (C) 2001 Havoc Pennington
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef META_RESIZEPOPUP_H
+#define META_RESIZEPOPUP_H
+
+/* Don't include gtk.h or gdk.h here */
+#include <meta/boxes.h>
+#include <meta/common.h>
+#include <X11/Xlib.h>
+#include <glib.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+
+typedef struct _MetaResizePopup MetaResizePopup;
+
+MetaResizePopup* meta_ui_resize_popup_new          (Display *display,
+                                                    int      screen_number);
+void             meta_ui_resize_popup_free         (MetaResizePopup *popup);
+void             meta_ui_resize_popup_set (MetaResizePopup *popup,
+                                           MetaRectangle    rect,
+                                           int              base_width,
+                                           int              base_height,
+                                           int              width_inc,
+                                           int              height_inc);
+void             meta_ui_resize_popup_set_showing  (MetaResizePopup *popup,
+                                                    gboolean         showing);
+
+#endif
+
diff '--exclude=.git' -urN a/src/ui/testgradient.c b/src/ui/testgradient.c
--- a/src/ui/testgradient.c	1969-12-31 19:00:00.000000000 -0500
+++ b/src/ui/testgradient.c	2015-10-31 13:33:56.668252083 -0400
@@ -0,0 +1,315 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* Mutter gradient test program */
+
+/*
+ * Copyright (C) 2002 Havoc Pennington
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.  */
+
+#include <meta/gradient.h>
+#include <gtk/gtk.h>
+
+typedef void (* RenderGradientFunc) (cairo_t     *cr,
+                                     int          width,
+                                     int          height);
+
+static void
+draw_checkerboard (cairo_t *cr,
+                   int      width,
+                   int      height)
+{
+  gint i, j, xcount, ycount;
+  GdkRGBA color1, color2;
+
+#define CHECK_SIZE 10
+#define SPACING 2
+
+  color1.red = 30000. / 65535.;
+  color1.green = 30000. / 65535.;
+  color1.blue = 30000. / 65535.;
+  color1.alpha = 1.0;
+
+  color2.red = 50000. / 65535.;
+  color2.green = 50000. / 65535.;
+  color2.blue = 50000. / 65535.;
+  color2.alpha = 1.0;
+
+  xcount = 0;
+  i = SPACING;
+  while (i < width)
+    {
+      j = SPACING;
+      ycount = xcount % 2; /* start with even/odd depending on row */
+      while (j < height)
+	{
+	  if (ycount % 2)
+	    gdk_cairo_set_source_rgba (cr, &color1);
+	  else
+	    gdk_cairo_set_source_rgba (cr, &color2);
+
+	  /* If we're outside event->area, this will do nothing.
+	   * It might be mildly more efficient if we handled
+	   * the clipping ourselves, but again we're feeling lazy.
+	   */
+          cairo_rectangle (cr, i, j, CHECK_SIZE, CHECK_SIZE);
+          cairo_fill (cr);
+
+	  j += CHECK_SIZE + SPACING;
+	  ++ycount;
+	}
+
+      i += CHECK_SIZE + SPACING;
+      ++xcount;
+    }
+}
+
+static void
+render_simple (cairo_t     *cr,
+               int width, int height,
+               MetaGradientType type,
+               gboolean    with_alpha)
+{
+  GdkPixbuf *pixbuf;
+  GdkRGBA from, to;
+
+  gdk_rgba_parse (&from, "blue");
+  gdk_rgba_parse (&to, "green");
+
+  pixbuf = meta_gradient_create_simple (width, height,
+                                        &from, &to,
+                                        type);
+
+  if (with_alpha)
+    {
+      const unsigned char alphas[] = { 0xff, 0xaa, 0x2f, 0x0, 0xcc, 0xff, 0xff };
+
+      if (!gdk_pixbuf_get_has_alpha (pixbuf))
+        {
+          GdkPixbuf *new_pixbuf;
+
+          new_pixbuf = gdk_pixbuf_add_alpha (pixbuf, FALSE, 0, 0, 0);
+          g_object_unref (G_OBJECT (pixbuf));
+          pixbuf = new_pixbuf;
+        }
+
+      meta_gradient_add_alpha (pixbuf,
+                               alphas, G_N_ELEMENTS (alphas),
+                               META_GRADIENT_HORIZONTAL);
+
+      draw_checkerboard (cr , width, height);
+    }
+
+  gdk_cairo_set_source_pixbuf (cr, pixbuf, 0, 0);
+  cairo_rectangle (cr, 0, 0, width, height);
+  cairo_fill (cr);
+
+  g_object_unref (G_OBJECT (pixbuf));
+}
+
+static void
+render_vertical_func (cairo_t *cr,
+                      int width, int height)
+{
+  render_simple (cr, width, height, META_GRADIENT_VERTICAL, FALSE);
+}
+
+static void
+render_horizontal_func (cairo_t *cr,
+                        int width, int height)
+{
+  render_simple (cr, width, height, META_GRADIENT_HORIZONTAL, FALSE);
+}
+
+static void
+render_diagonal_func (cairo_t *cr,
+                      int width, int height)
+{
+  render_simple (cr, width, height, META_GRADIENT_DIAGONAL, FALSE);
+}
+
+static void
+render_diagonal_alpha_func (cairo_t *cr,
+                            int width, int height)
+{
+  render_simple (cr, width, height, META_GRADIENT_DIAGONAL, TRUE);
+}
+
+static void
+render_multi (cairo_t     *cr,
+              int width, int height,
+              MetaGradientType type)
+{
+  GdkPixbuf *pixbuf;
+#define N_COLORS 5
+  GdkRGBA colors[N_COLORS];
+
+  gdk_rgba_parse (&colors[0], "red");
+  gdk_rgba_parse (&colors[1], "blue");
+  gdk_rgba_parse (&colors[2], "orange");
+  gdk_rgba_parse (&colors[3], "pink");
+  gdk_rgba_parse (&colors[4], "green");
+
+  pixbuf = meta_gradient_create_multi (width, height,
+                                       colors, N_COLORS,
+                                       type);
+
+  gdk_cairo_set_source_pixbuf (cr, pixbuf, 0, 0);
+  cairo_rectangle (cr, 0, 0, width, height);
+  cairo_fill (cr);
+
+  g_object_unref (G_OBJECT (pixbuf));
+#undef N_COLORS
+}
+
+static void
+render_vertical_multi_func (cairo_t *cr,
+                            int width, int height)
+{
+  render_multi (cr, width, height, META_GRADIENT_VERTICAL);
+}
+
+static void
+render_horizontal_multi_func (cairo_t *cr,
+                              int width, int height)
+{
+  render_multi (cr, width, height, META_GRADIENT_HORIZONTAL);
+}
+
+static void
+render_diagonal_multi_func (cairo_t *cr,
+                            int width, int height)
+{
+  render_multi (cr, width, height, META_GRADIENT_DIAGONAL);
+}
+
+static void
+render_interwoven_func (cairo_t *cr,
+                        int width, int height)
+{
+  GdkPixbuf *pixbuf;
+#define N_COLORS 4
+  GdkRGBA colors[N_COLORS];
+
+  gdk_rgba_parse (&colors[0], "red");
+  gdk_rgba_parse (&colors[1], "blue");
+  gdk_rgba_parse (&colors[2], "pink");
+  gdk_rgba_parse (&colors[3], "green");
+
+  pixbuf = meta_gradient_create_interwoven (width, height,
+                                            colors, height / 10,
+                                            colors + 2, height / 14);
+
+  gdk_cairo_set_source_pixbuf (cr, pixbuf, 0, 0);
+  cairo_rectangle (cr, 0, 0, width, height);
+  cairo_fill (cr);
+
+  g_object_unref (G_OBJECT (pixbuf));
+}
+
+static gboolean
+draw_callback (GtkWidget *widget,
+               cairo_t   *cr,
+               gpointer   data)
+{
+  RenderGradientFunc func = data;
+  GtkStyleContext *style;
+  GdkRGBA color;
+
+  style = gtk_widget_get_style_context (widget);
+
+  gtk_style_context_save (style);
+  gtk_style_context_set_state (style, gtk_widget_get_state_flags (widget));
+  gtk_style_context_lookup_color (style, "foreground-color", &color);
+  gtk_style_context_restore (style);
+
+  gdk_cairo_set_source_rgba (cr, &color);
+
+  (* func) (cr,
+            gtk_widget_get_allocated_width (widget),
+            gtk_widget_get_allocated_height (widget));
+
+  return FALSE;
+}
+
+static GtkWidget*
+create_gradient_window (const char *title,
+                        RenderGradientFunc func)
+{
+  GtkWidget *window;
+  GtkWidget *drawing_area;
+
+  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+
+  gtk_window_set_title (GTK_WINDOW (window), title);
+
+  drawing_area = gtk_drawing_area_new ();
+
+  gtk_widget_set_size_request (drawing_area, 1, 1);
+
+  gtk_window_set_default_size (GTK_WINDOW (window), 175, 175);
+
+  g_signal_connect (G_OBJECT (drawing_area),
+                    "draw",
+                    G_CALLBACK (draw_callback),
+                    func);
+
+  gtk_container_add (GTK_CONTAINER (window), drawing_area);
+
+  gtk_widget_show_all (window);
+
+  return window;
+}
+
+static void
+meta_gradient_test (void)
+{
+  create_gradient_window ("Simple vertical",
+                          render_vertical_func);
+
+  create_gradient_window ("Simple horizontal",
+                          render_horizontal_func);
+
+  create_gradient_window ("Simple diagonal",
+                          render_diagonal_func);
+
+  create_gradient_window ("Multi vertical",
+                          render_vertical_multi_func);
+
+  create_gradient_window ("Multi horizontal",
+                          render_horizontal_multi_func);
+
+  create_gradient_window ("Multi diagonal",
+                          render_diagonal_multi_func);
+
+  create_gradient_window ("Interwoven",
+                          render_interwoven_func);
+
+  create_gradient_window ("Simple diagonal with horizontal multi alpha",
+                          render_diagonal_alpha_func);
+
+}
+
+int
+main (int argc, char **argv)
+{
+  gtk_init (&argc, &argv);
+
+  meta_gradient_test ();
+
+  gtk_main ();
+
+  return 0;
+}
+
diff '--exclude=.git' -urN a/src/ui/theme-parser.c b/src/ui/theme-parser.c
--- a/src/ui/theme-parser.c	1969-12-31 19:00:00.000000000 -0500
+++ b/src/ui/theme-parser.c	2015-10-31 13:33:56.668252083 -0400
@@ -0,0 +1,4344 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* Metacity theme parsing */
+
+/*
+ * Copyright (C) 2001 Havoc Pennington
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <config.h>
+#include "theme-private.h"
+#include "util-private.h"
+#include <string.h>
+#include <stdlib.h>
+
+/* We were intending to put the version number
+ * in the subdirectory name, but we ended up
+ * using the filename instead.  The "-1" survives
+ * as a fossil.
+ */
+#define THEME_SUBDIR "metacity-1"
+
+/* Highest version of the theme format to
+ * look out for.
+ */
+#define THEME_MAJOR_VERSION 3
+#define THEME_MINOR_VERSION 5
+#define THEME_VERSION (1000 * THEME_MAJOR_VERSION + THEME_MINOR_VERSION)
+
+#define METACITY_THEME_FILENAME_FORMAT "metacity-theme-%d.xml"
+
+typedef enum
+{
+  STATE_START,
+  STATE_THEME,
+  /* info section */
+  STATE_INFO,
+  STATE_NAME,
+  STATE_AUTHOR,
+  STATE_COPYRIGHT,
+  STATE_DATE,
+  STATE_DESCRIPTION,
+  /* constants */
+  STATE_CONSTANT,
+  /* geometry */
+  STATE_FRAME_GEOMETRY,
+  STATE_DISTANCE,
+  STATE_BORDER,
+  STATE_ASPECT_RATIO,
+  /* draw ops */
+  STATE_DRAW_OPS,
+  STATE_LINE,
+  STATE_RECTANGLE,
+  STATE_ARC,
+  STATE_CLIP,
+  STATE_TINT,
+  STATE_GRADIENT,
+  STATE_IMAGE,
+  STATE_GTK_ARROW,
+  STATE_GTK_BOX,
+  STATE_GTK_VLINE,
+  STATE_ICON,
+  STATE_TITLE,
+  STATE_INCLUDE, /* include another draw op list */
+  STATE_TILE,    /* tile another draw op list */
+  /* sub-parts of gradient */
+  STATE_COLOR,
+  /* frame style */
+  STATE_FRAME_STYLE,
+  STATE_PIECE,
+  STATE_BUTTON,
+  /* style set */
+  STATE_FRAME_STYLE_SET,
+  STATE_FRAME,
+  /* assigning style sets to windows */
+  STATE_WINDOW,
+  /* things we don't use any more but we can still parse: */
+  STATE_MENU_ICON,
+  STATE_FALLBACK
+} ParseState;
+
+typedef struct
+{
+  /* This two lists contain stacks of state and required version
+   * (cast to pointers.) There is one list item for each currently
+   * open element. */
+  GSList *states;
+  GSList *required_versions;
+
+  const char *theme_name;       /* name of theme (directory it's in) */
+  const char *theme_file;       /* theme filename */
+  const char *theme_dir;        /* dir the theme is inside */
+  MetaTheme *theme;             /* theme being parsed */
+  guint format_version;         /* version of format of theme file */
+  char *name;                   /* name of named thing being parsed */
+  MetaFrameLayout *layout;      /* layout being parsed if any */
+  MetaDrawOpList *op_list;      /* op list being parsed if any */
+  MetaDrawOp *op;               /* op being parsed if any */
+  MetaFrameStyle *style;        /* frame style being parsed if any */
+  MetaFrameStyleSet *style_set; /* frame style set being parsed if any */
+  MetaFramePiece piece;         /* position of piece being parsed */
+  MetaButtonType button_type;   /* type of button/menuitem being parsed */
+  MetaButtonState button_state; /* state of button being parsed */
+  int skip_level;               /* depth of elements that we're ignoring */
+} ParseInfo;
+
+typedef enum {
+  THEME_PARSE_ERROR_TOO_OLD,
+  THEME_PARSE_ERROR_TOO_FAILED
+} ThemeParseError;
+
+static GQuark
+theme_parse_error_quark (void)
+{
+  return g_quark_from_static_string ("theme-parse-error-quark");
+}
+
+#define THEME_PARSE_ERROR (theme_parse_error_quark ())
+
+static void set_error (GError             **err,
+                       GMarkupParseContext *context,
+                       int                  error_domain,
+                       int                  error_code,
+                       const char          *format,
+                       ...) G_GNUC_PRINTF (5, 6);
+
+static void add_context_to_error (GError             **err,
+                                  GMarkupParseContext *context);
+
+static void       parse_info_init (ParseInfo *info);
+static void       parse_info_free (ParseInfo *info);
+
+static void       push_state (ParseInfo  *info,
+                              ParseState  state);
+static void       pop_state  (ParseInfo  *info);
+static ParseState peek_state (ParseInfo  *info);
+
+
+static void parse_toplevel_element  (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+static void parse_info_element      (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+static void parse_geometry_element  (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+static void parse_draw_op_element   (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+static void parse_gradient_element  (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+static void parse_style_element     (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+static void parse_style_set_element (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+
+static void parse_piece_element     (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+
+static void parse_button_element    (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+
+static void parse_menu_icon_element (GMarkupParseContext  *context,
+                                     const gchar          *element_name,
+                                     const gchar         **attribute_names,
+                                     const gchar         **attribute_values,
+                                     ParseInfo            *info,
+                                     GError              **error);
+
+static void start_element_handler (GMarkupParseContext  *context,
+                                   const gchar          *element_name,
+                                   const gchar         **attribute_names,
+                                   const gchar         **attribute_values,
+                                   gpointer              user_data,
+                                   GError              **error);
+static void end_element_handler   (GMarkupParseContext  *context,
+                                   const gchar          *element_name,
+                                   gpointer              user_data,
+                                   GError              **error);
+static void text_handler          (GMarkupParseContext  *context,
+                                   const gchar          *text,
+                                   gsize                 text_len,
+                                   gpointer              user_data,
+                                   GError              **error);
+
+/* Translators: This means that an attribute which should have been found
+ * on an XML element was not in fact found.
+ */
+#define ATTRIBUTE_NOT_FOUND _("No \"%s\" attribute on element <%s>")
+
+static GMarkupParser metacity_theme_parser = {
+  start_element_handler,
+  end_element_handler,
+  text_handler,
+  NULL,
+  NULL
+};
+
+static void
+set_error (GError             **err,
+           GMarkupParseContext *context,
+           int                  error_domain,
+           int                  error_code,
+           const char          *format,
+           ...)
+{
+  int line, ch;
+  va_list args;
+  char *str;
+
+  g_markup_parse_context_get_position (context, &line, &ch);
+
+  va_start (args, format);
+  str = g_strdup_vprintf (format, args);
+  va_end (args);
+
+  g_set_error (err, error_domain, error_code,
+               _("Line %d character %d: %s"),
+               line, ch, str);
+
+  g_free (str);
+}
+
+static void
+add_context_to_error (GError             **err,
+                      GMarkupParseContext *context)
+{
+  int line, ch;
+  char *str;
+
+  if (err == NULL || *err == NULL)
+    return;
+
+  g_markup_parse_context_get_position (context, &line, &ch);
+
+  str = g_strdup_printf (_("Line %d character %d: %s"),
+                         line, ch, (*err)->message);
+  g_free ((*err)->message);
+  (*err)->message = str;
+}
+
+static void
+parse_info_init (ParseInfo *info)
+{
+  info->theme_file = NULL;
+  info->states = g_slist_prepend (NULL, GINT_TO_POINTER (STATE_START));
+  info->required_versions = NULL;
+  info->theme = NULL;
+  info->name = NULL;
+  info->layout = NULL;
+  info->op_list = NULL;
+  info->op = NULL;
+  info->style = NULL;
+  info->style_set = NULL;
+  info->piece = META_FRAME_PIECE_LAST;
+  info->button_type = META_BUTTON_TYPE_LAST;
+  info->button_state = META_BUTTON_STATE_LAST;
+  info->skip_level = 0;
+}
+
+static void
+parse_info_free (ParseInfo *info)
+{
+  g_slist_free (info->states);
+  g_slist_free (info->required_versions);
+
+  if (info->theme)
+    meta_theme_free (info->theme);
+
+  if (info->layout)
+    meta_frame_layout_unref (info->layout);
+
+  if (info->op_list)
+    meta_draw_op_list_unref (info->op_list);
+
+  if (info->op)
+    meta_draw_op_free (info->op);
+
+  if (info->style)
+    meta_frame_style_unref (info->style);
+
+  if (info->style_set)
+    meta_frame_style_set_unref (info->style_set);
+}
+
+static void
+push_state (ParseInfo  *info,
+            ParseState  state)
+{
+  info->states = g_slist_prepend (info->states, GINT_TO_POINTER (state));
+}
+
+static void
+pop_state (ParseInfo *info)
+{
+  g_return_if_fail (info->states != NULL);
+
+  info->states = g_slist_remove (info->states, info->states->data);
+}
+
+static ParseState
+peek_state (ParseInfo *info)
+{
+  g_return_val_if_fail (info->states != NULL, STATE_START);
+
+  return GPOINTER_TO_INT (info->states->data);
+}
+
+static void
+push_required_version (ParseInfo *info,
+                       int        version)
+{
+  info->required_versions = g_slist_prepend (info->required_versions,
+                                             GINT_TO_POINTER (version));
+}
+
+static void
+pop_required_version (ParseInfo *info)
+{
+  g_return_if_fail (info->required_versions != NULL);
+
+  info->required_versions = g_slist_delete_link (info->required_versions, info->required_versions);
+}
+
+static int
+peek_required_version (ParseInfo *info)
+{
+  if (info->required_versions)
+    return GPOINTER_TO_INT (info->required_versions->data);
+  else
+    return info->format_version;
+}
+
+#define ELEMENT_IS(name) (strcmp (element_name, (name)) == 0)
+
+typedef struct
+{
+  const char  *name;
+  const char **retloc;
+  gboolean required;
+} LocateAttr;
+
+/* Attribute names can have a leading '!' to indicate that they are
+ * required.
+ */
+static gboolean
+locate_attributes (GMarkupParseContext *context,
+                   const char  *element_name,
+                   const char **attribute_names,
+                   const char **attribute_values,
+                   GError     **error,
+                   const char  *first_attribute_name,
+                   const char **first_attribute_retloc,
+                   ...)
+{
+  va_list args;
+  const char *name;
+  const char **retloc;
+  int n_attrs;
+#define MAX_ATTRS 24
+  LocateAttr attrs[MAX_ATTRS];
+  gboolean retval;
+  int i;
+
+  g_return_val_if_fail (first_attribute_name != NULL, FALSE);
+  g_return_val_if_fail (first_attribute_retloc != NULL, FALSE);
+
+  retval = TRUE;
+
+  /* FIXME: duplicated code; refactor loop */
+  n_attrs = 1;
+  attrs[0].name = first_attribute_name;
+  attrs[0].retloc = first_attribute_retloc;
+  attrs[0].required = attrs[0].name[0]=='!';
+  if (attrs[0].required)
+    attrs[0].name++; /* skip past it */
+  *first_attribute_retloc = NULL;
+
+  va_start (args, first_attribute_retloc);
+
+  name = va_arg (args, const char*);
+  retloc = va_arg (args, const char**);
+
+  while (name != NULL)
+    {
+      if (retloc == NULL)
+        {
+          retval = FALSE;
+          goto out;
+        }
+
+      g_assert (n_attrs < MAX_ATTRS);
+
+      attrs[n_attrs].name = name;
+      attrs[n_attrs].retloc = retloc;
+      attrs[n_attrs].required = attrs[n_attrs].name[0]=='!';
+      if (attrs[n_attrs].required)
+        attrs[n_attrs].name++; /* skip past it */
+
+      n_attrs += 1;
+      *retloc = NULL;
+
+      name = va_arg (args, const char*);
+      retloc = va_arg (args, const char**);
+    }
+
+  va_end (args);
+
+  i = 0;
+  while (attribute_names[i])
+    {
+      int j;
+      gboolean found;
+
+      /* Can be present anywhere */
+      if (strcmp (attribute_names[i], "version") == 0)
+        {
+          ++i;
+          continue;
+        }
+
+      found = FALSE;
+      j = 0;
+      while (j < n_attrs)
+        {
+          if (strcmp (attrs[j].name, attribute_names[i]) == 0)
+            {
+              retloc = attrs[j].retloc;
+
+              if (*retloc != NULL)
+                {
+
+                  set_error (error, context,
+                             G_MARKUP_ERROR,
+                             G_MARKUP_ERROR_PARSE,
+                             _("Attribute \"%s\" repeated twice on the same <%s> element"),
+                             attrs[j].name, element_name);
+                  retval = FALSE;
+                  goto out;
+                }
+
+              *retloc = attribute_values[i];
+              found = TRUE;
+            }
+
+          ++j;
+        }
+
+      if (!found)
+        {
+      j = 0;
+      while (j < n_attrs)
+        {
+          g_warning ("It could have been %s.\n", attrs[j++].name);
+        }
+
+          set_error (error, context,
+                     G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Attribute \"%s\" is invalid on <%s> element in this context"),
+                     attribute_names[i], element_name);
+          retval = FALSE;
+          goto out;
+        }
+
+      ++i;
+    }
+
+    /* Did we catch them all? */
+    i = 0;
+    while (i < n_attrs)
+      {
+        if (attrs[i].required && *(attrs[i].retloc)==NULL)
+          {
+            set_error (error, context,
+                       G_MARKUP_ERROR,
+                       G_MARKUP_ERROR_PARSE,
+                       ATTRIBUTE_NOT_FOUND,
+                       attrs[i].name, element_name);
+            retval = FALSE;
+            goto out;
+          }
+
+        ++i;
+      }
+
+ out:
+  return retval;
+}
+
+static gboolean
+check_no_attributes (GMarkupParseContext *context,
+                     const char  *element_name,
+                     const char **attribute_names,
+                     const char **attribute_values,
+                     GError     **error)
+{
+  int i = 0;
+
+  /* Can be present anywhere */
+  if (attribute_names[0] && strcmp (attribute_names[i], "version") == 0)
+    i++;
+
+  if (attribute_names[i] != NULL)
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR,
+                 G_MARKUP_ERROR_PARSE,
+                 _("Attribute \"%s\" is invalid on <%s> element in this context"),
+                 attribute_names[0], element_name);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+#define MAX_REASONABLE 4096
+static gboolean
+parse_positive_integer (const char          *str,
+                        int                 *val,
+                        GMarkupParseContext *context,
+                        MetaTheme           *theme,
+                        GError             **error)
+{
+  char *end;
+  long l;
+  int j;
+
+  *val = 0;
+
+  end = NULL;
+
+  /* Is str a constant? */
+
+  if (META_THEME_ALLOWS (theme, META_THEME_UBIQUITOUS_CONSTANTS) &&
+      meta_theme_lookup_int_constant (theme, str, &j))
+    {
+      /* Yes. */
+      l = j;
+    }
+  else
+    {
+      /* No. Let's try parsing it instead. */
+
+      l = strtol (str, &end, 10);
+
+      if (end == NULL || end == str)
+      {
+        set_error (error, context, G_MARKUP_ERROR,
+                   G_MARKUP_ERROR_PARSE,
+                   _("Could not parse \"%s\" as an integer"),
+                   str);
+        return FALSE;
+      }
+
+    if (*end != '\0')
+      {
+        set_error (error, context, G_MARKUP_ERROR,
+                   G_MARKUP_ERROR_PARSE,
+                   _("Did not understand trailing characters \"%s\" in string \"%s\""),
+                   end, str);
+        return FALSE;
+      }
+    }
+
+  if (l < 0)
+    {
+      set_error (error, context, G_MARKUP_ERROR,
+                 G_MARKUP_ERROR_PARSE,
+                 _("Integer %ld must be positive"), l);
+      return FALSE;
+    }
+
+  if (l > MAX_REASONABLE)
+    {
+      set_error (error, context, G_MARKUP_ERROR,
+                 G_MARKUP_ERROR_PARSE,
+                 _("Integer %ld is too large, current max is %d"),
+                 l, MAX_REASONABLE);
+      return FALSE;
+    }
+
+  *val = (int) l;
+
+  return TRUE;
+}
+
+static gboolean
+parse_double (const char          *str,
+              double              *val,
+              GMarkupParseContext *context,
+              GError             **error)
+{
+  char *end;
+
+  *val = 0;
+
+  end = NULL;
+
+  *val = g_ascii_strtod (str, &end);
+
+  if (end == NULL || end == str)
+    {
+      set_error (error, context, G_MARKUP_ERROR,
+                 G_MARKUP_ERROR_PARSE,
+                 _("Could not parse \"%s\" as a floating point number"),
+                 str);
+      return FALSE;
+    }
+
+  if (*end != '\0')
+    {
+      set_error (error, context, G_MARKUP_ERROR,
+                 G_MARKUP_ERROR_PARSE,
+                 _("Did not understand trailing characters \"%s\" in string \"%s\""),
+                 end, str);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
+parse_boolean (const char          *str,
+               gboolean            *val,
+               GMarkupParseContext *context,
+               GError             **error)
+{
+  if (strcmp ("true", str) == 0)
+    *val = TRUE;
+  else if (strcmp ("false", str) == 0)
+    *val = FALSE;
+  else
+    {
+      set_error (error, context, G_MARKUP_ERROR,
+                 G_MARKUP_ERROR_PARSE,
+                 _("Boolean values must be \"true\" or \"false\" not \"%s\""),
+                 str);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
+parse_rounding (const char          *str,
+                guint               *val,
+                GMarkupParseContext *context,
+                MetaTheme           *theme,
+                GError             **error)
+{
+  if (strcmp ("true", str) == 0)
+    *val = 5; /* historical "true" value */
+  else if (strcmp ("false", str) == 0)
+    *val = 0;
+  else
+    {
+      int tmp;
+      gboolean result;
+       if (!META_THEME_ALLOWS (theme, META_THEME_VARIED_ROUND_CORNERS))
+         {
+           /* Not known in this version, so bail. */
+           set_error (error, context, G_MARKUP_ERROR,
+                      G_MARKUP_ERROR_PARSE,
+                      _("Boolean values must be \"true\" or \"false\" not \"%s\""),
+                      str);
+           return FALSE;
+         }
+
+      result = parse_positive_integer (str, &tmp, context, theme, error);
+
+      *val = tmp;
+
+      return result;
+    }
+
+  return TRUE;
+}
+
+static gboolean
+parse_angle (const char          *str,
+             double              *val,
+             GMarkupParseContext *context,
+             GError             **error)
+{
+  if (!parse_double (str, val, context, error))
+    return FALSE;
+
+  if (*val < (0.0 - 1e6) || *val > (360.0 + 1e6))
+    {
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Angle must be between 0.0 and 360.0, was %g\n"),
+                 *val);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
+parse_alpha (const char             *str,
+             MetaAlphaGradientSpec **spec_ret,
+             GMarkupParseContext    *context,
+             GError                **error)
+{
+  char **split;
+  int i;
+  int n_alphas;
+  MetaAlphaGradientSpec *spec;
+
+  *spec_ret = NULL;
+
+  split = g_strsplit (str, ":", -1);
+
+  i = 0;
+  while (split[i])
+    ++i;
+
+  if (i == 0)
+    {
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Could not parse \"%s\" as a floating point number"),
+                 str);
+
+      g_strfreev (split);
+
+      return FALSE;
+    }
+
+  n_alphas = i;
+
+  /* FIXME allow specifying horizontal/vertical/diagonal in theme format,
+   * once we implement vertical/diagonal in gradient.c
+   */
+  spec = meta_alpha_gradient_spec_new (META_GRADIENT_HORIZONTAL,
+                                       n_alphas);
+
+  i = 0;
+  while (i < n_alphas)
+    {
+      double v;
+
+      if (!parse_double (split[i], &v, context, error))
+        {
+          /* clear up, but don't set error: it was set by parse_double */
+          g_strfreev (split);
+          meta_alpha_gradient_spec_free (spec);
+
+          return FALSE;
+        }
+
+      if (v < (0.0 - 1e-6) || v > (1.0 + 1e-6))
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Alpha must be between 0.0 (invisible) and 1.0 (fully opaque), was %g\n"),
+                     v);
+
+          g_strfreev (split);
+          meta_alpha_gradient_spec_free (spec);
+
+          return FALSE;
+        }
+
+      spec->alphas[i] = (unsigned char) (v * 255);
+
+      ++i;
+    }
+
+  g_strfreev (split);
+
+  *spec_ret = spec;
+
+  return TRUE;
+}
+
+static MetaColorSpec*
+parse_color (MetaTheme *theme,
+             const char        *str,
+             GError           **err)
+{
+  char* referent;
+
+  if (META_THEME_ALLOWS (theme, META_THEME_COLOR_CONSTANTS) &&
+      meta_theme_lookup_color_constant (theme, str, &referent))
+    {
+      if (referent)
+        return meta_color_spec_new_from_string (referent, err);
+
+      /* no need to free referent: it's a pointer into the actual hash table */
+    }
+
+  return meta_color_spec_new_from_string (str, err);
+}
+
+static gboolean
+parse_title_scale (const char          *str,
+                   double              *val,
+                   GMarkupParseContext *context,
+                   GError             **error)
+{
+  double factor;
+
+  if (strcmp (str, "xx-small") == 0)
+    factor = PANGO_SCALE_XX_SMALL;
+  else if (strcmp (str, "x-small") == 0)
+    factor = PANGO_SCALE_X_SMALL;
+  else if (strcmp (str, "small") == 0)
+    factor = PANGO_SCALE_SMALL;
+  else if (strcmp (str, "medium") == 0)
+    factor = PANGO_SCALE_MEDIUM;
+  else if (strcmp (str, "large") == 0)
+    factor = PANGO_SCALE_LARGE;
+  else if (strcmp (str, "x-large") == 0)
+    factor = PANGO_SCALE_X_LARGE;
+  else if (strcmp (str, "xx-large") == 0)
+    factor = PANGO_SCALE_XX_LARGE;
+  else
+    {
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Invalid title scale \"%s\" (must be one of xx-small,x-small,small,medium,large,x-large,xx-large)\n"),
+                 str);
+      return FALSE;
+    }
+
+  *val = factor;
+
+  return TRUE;
+}
+
+static void
+parse_toplevel_element (GMarkupParseContext  *context,
+                        const gchar          *element_name,
+                        const gchar         **attribute_names,
+                        const gchar         **attribute_values,
+                        ParseInfo            *info,
+                        GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_THEME);
+
+  if (ELEMENT_IS ("info"))
+    {
+      if (!check_no_attributes (context, element_name,
+                                attribute_names, attribute_values,
+                                error))
+        return;
+
+      push_state (info, STATE_INFO);
+    }
+  else if (ELEMENT_IS ("constant"))
+    {
+      const char *name;
+      const char *value;
+      int ival = 0;
+      double dval = 0.0;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!name", &name, "!value", &value,
+                              NULL))
+        return;
+
+      /* We don't know how a a constant is going to be used, so we have guess its
+       * type from its contents:
+       *
+       *  - Starts like a number and contains a '.': float constant
+       *  - Starts like a number and doesn't contain a '.': int constant
+       *  - Starts with anything else: a color constant.
+       *    (colors always start with # or a letter)
+       */
+      if (value[0] == '.' || value[0] == '+' || value[0] == '-' || (value[0] >= '0' && value[0] <= '9'))
+        {
+          if (strchr (value, '.'))
+            {
+              if (!parse_double (value, &dval, context, error))
+                return;
+
+              if (!meta_theme_define_float_constant (info->theme,
+                                                     name,
+                                                     dval,
+                                                     error))
+                {
+                  add_context_to_error (error, context);
+                  return;
+                }
+            }
+          else
+            {
+              if (!parse_positive_integer (value, &ival, context, info->theme, error))
+                return;
+
+              if (!meta_theme_define_int_constant (info->theme,
+                                                   name,
+                                                   ival,
+                                                   error))
+                {
+                  add_context_to_error (error, context);
+                  return;
+                }
+            }
+        }
+      else
+        {
+          if (!meta_theme_define_color_constant (info->theme,
+                                                 name,
+                                                 value,
+                                                 error))
+            {
+              add_context_to_error (error, context);
+              return;
+            }
+        }
+
+      push_state (info, STATE_CONSTANT);
+    }
+  else if (ELEMENT_IS ("frame_geometry"))
+    {
+      const char *name = NULL;
+      const char *parent = NULL;
+      const char *has_title = NULL;
+      const char *title_scale = NULL;
+      const char *rounded_top_left = NULL;
+      const char *rounded_top_right = NULL;
+      const char *rounded_bottom_left = NULL;
+      const char *rounded_bottom_right = NULL;
+      const char *hide_buttons = NULL;
+      gboolean has_title_val;
+      guint rounded_top_left_val;
+      guint rounded_top_right_val;
+      guint rounded_bottom_left_val;
+      guint rounded_bottom_right_val;
+      gboolean hide_buttons_val;
+      double title_scale_val;
+      MetaFrameLayout *parent_layout;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!name", &name, "parent", &parent,
+                              "has_title", &has_title, "title_scale", &title_scale,
+                              "rounded_top_left", &rounded_top_left,
+                              "rounded_top_right", &rounded_top_right,
+                              "rounded_bottom_left", &rounded_bottom_left,
+                              "rounded_bottom_right", &rounded_bottom_right,
+                              "hide_buttons", &hide_buttons,
+                              NULL))
+        return;
+
+      has_title_val = TRUE;
+      if (has_title && !parse_boolean (has_title, &has_title_val, context, error))
+        return;
+
+      hide_buttons_val = FALSE;
+      if (hide_buttons && !parse_boolean (hide_buttons, &hide_buttons_val, context, error))
+        return;
+
+      rounded_top_left_val = 0;
+      rounded_top_right_val = 0;
+      rounded_bottom_left_val = 0;
+      rounded_bottom_right_val = 0;
+
+      if (rounded_top_left && !parse_rounding (rounded_top_left, &rounded_top_left_val, context, info->theme, error))
+        return;
+      if (rounded_top_right && !parse_rounding (rounded_top_right, &rounded_top_right_val, context, info->theme, error))
+        return;
+      if (rounded_bottom_left && !parse_rounding (rounded_bottom_left, &rounded_bottom_left_val, context, info->theme, error))
+        return;
+      if (rounded_bottom_right && !parse_rounding (rounded_bottom_right, &rounded_bottom_right_val, context, info->theme, error))
+        return;
+
+      title_scale_val = 1.0;
+      if (title_scale && !parse_title_scale (title_scale, &title_scale_val, context, error))
+        return;
+
+      if (meta_theme_lookup_layout (info->theme, name))
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("<%s> name \"%s\" used a second time"),
+                     element_name, name);
+          return;
+        }
+
+      parent_layout = NULL;
+      if (parent)
+        {
+          parent_layout = meta_theme_lookup_layout (info->theme, parent);
+          if (parent_layout == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("<%s> parent \"%s\" has not been defined"),
+                         element_name, parent);
+              return;
+            }
+        }
+
+      g_assert (info->layout == NULL);
+
+      if (parent_layout)
+        info->layout = meta_frame_layout_copy (parent_layout);
+      else
+        info->layout = meta_frame_layout_new ();
+
+      if (has_title) /* only if explicit, otherwise inherit */
+        info->layout->has_title = has_title_val;
+
+      if (META_THEME_ALLOWS (info->theme, META_THEME_HIDDEN_BUTTONS) && hide_buttons_val)
+          info->layout->hide_buttons = hide_buttons_val;
+
+      if (title_scale)
+	info->layout->title_scale = title_scale_val;
+
+      if (rounded_top_left)
+        info->layout->top_left_corner_rounded_radius = rounded_top_left_val;
+
+      if (rounded_top_right)
+        info->layout->top_right_corner_rounded_radius = rounded_top_right_val;
+
+      if (rounded_bottom_left)
+        info->layout->bottom_left_corner_rounded_radius = rounded_bottom_left_val;
+
+      if (rounded_bottom_right)
+        info->layout->bottom_right_corner_rounded_radius = rounded_bottom_right_val;
+
+      meta_theme_insert_layout (info->theme, name, info->layout);
+
+      push_state (info, STATE_FRAME_GEOMETRY);
+    }
+  else if (ELEMENT_IS ("draw_ops"))
+    {
+      const char *name = NULL;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!name", &name,
+                              NULL))
+        return;
+
+      if (meta_theme_lookup_draw_op_list (info->theme, name))
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("<%s> name \"%s\" used a second time"),
+                     element_name, name);
+          return;
+        }
+
+      g_assert (info->op_list == NULL);
+      info->op_list = meta_draw_op_list_new (2);
+
+      meta_theme_insert_draw_op_list (info->theme, name, info->op_list);
+
+      push_state (info, STATE_DRAW_OPS);
+    }
+  else if (ELEMENT_IS ("frame_style"))
+    {
+      const char *name = NULL;
+      const char *parent = NULL;
+      const char *geometry = NULL;
+      const char *background = NULL;
+      const char *alpha = NULL;
+      MetaFrameStyle *parent_style;
+      MetaFrameLayout *layout;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!name", &name, "parent", &parent,
+                              "geometry", &geometry,
+                              "background", &background,
+                              "alpha", &alpha,
+                              NULL))
+        return;
+
+      if (meta_theme_lookup_style (info->theme, name))
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("<%s> name \"%s\" used a second time"),
+                     element_name, name);
+          return;
+        }
+
+      parent_style = NULL;
+      if (parent)
+        {
+          parent_style = meta_theme_lookup_style (info->theme, parent);
+          if (parent_style == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("<%s> parent \"%s\" has not been defined"),
+                         element_name, parent);
+              return;
+            }
+        }
+
+      layout = NULL;
+      if (geometry)
+        {
+          layout = meta_theme_lookup_layout (info->theme, geometry);
+          if (layout == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("<%s> geometry \"%s\" has not been defined"),
+                         element_name, geometry);
+              return;
+            }
+        }
+      else if (parent_style)
+        {
+          layout = parent_style->layout;
+        }
+
+      if (layout == NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("<%s> must specify either a geometry or a parent that has a geometry"),
+                     element_name);
+          return;
+        }
+
+      g_assert (info->style == NULL);
+
+      info->style = meta_frame_style_new (parent_style);
+      g_assert (info->style->layout == NULL);
+      meta_frame_layout_ref (layout);
+      info->style->layout = layout;
+
+      if (background != NULL && META_THEME_ALLOWS (info->theme, META_THEME_FRAME_BACKGROUNDS))
+        {
+          info->style->window_background_color = meta_color_spec_new_from_string (background, error);
+          if (!info->style->window_background_color)
+            return;
+
+          if (alpha != NULL)
+            {
+
+               gboolean success;
+               MetaAlphaGradientSpec *alpha_vector;
+
+               g_clear_error (error);
+               /* fortunately, we already have a routine to parse alpha values,
+                * though it produces a vector of them, which is a superset of
+                * what we want.
+                */
+               success = parse_alpha (alpha, &alpha_vector, context, error);
+               if (!success)
+                 return;
+
+               /* alpha_vector->alphas must contain at least one element */
+               info->style->window_background_alpha = alpha_vector->alphas[0];
+
+               meta_alpha_gradient_spec_free (alpha_vector);
+            }
+        }
+      else if (alpha != NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("You must specify a background for an alpha value to be meaningful"));
+          return;
+        }
+
+      meta_theme_insert_style (info->theme, name, info->style);
+
+      push_state (info, STATE_FRAME_STYLE);
+    }
+  else if (ELEMENT_IS ("frame_style_set"))
+    {
+      const char *name = NULL;
+      const char *parent = NULL;
+      MetaFrameStyleSet *parent_set;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!name", &name, "parent", &parent,
+                              NULL))
+        return;
+
+      if (meta_theme_lookup_style_set (info->theme, name))
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("<%s> name \"%s\" used a second time"),
+                     element_name, name);
+          return;
+        }
+
+      parent_set = NULL;
+      if (parent)
+        {
+          parent_set = meta_theme_lookup_style_set (info->theme, parent);
+          if (parent_set == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("<%s> parent \"%s\" has not been defined"),
+                         element_name, parent);
+              return;
+            }
+        }
+
+      g_assert (info->style_set == NULL);
+
+      info->style_set = meta_frame_style_set_new (parent_set);
+
+      meta_theme_insert_style_set (info->theme, name, info->style_set);
+
+      push_state (info, STATE_FRAME_STYLE_SET);
+    }
+  else if (ELEMENT_IS ("window"))
+    {
+      const char *type_name = NULL;
+      const char *style_set_name = NULL;
+      MetaFrameStyleSet *style_set;
+      MetaFrameType type;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!type", &type_name, "!style_set", &style_set_name,
+                              NULL))
+        return;
+
+      type = meta_frame_type_from_string (type_name);
+
+      if (type == META_FRAME_TYPE_LAST ||
+          (type == META_FRAME_TYPE_ATTACHED && peek_required_version (info) < 3002))
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Unknown type \"%s\" on <%s> element"),
+                     type_name, element_name);
+          return;
+        }
+
+      style_set = meta_theme_lookup_style_set (info->theme,
+                                               style_set_name);
+
+      if (style_set == NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Unknown style_set \"%s\" on <%s> element"),
+                     style_set_name, element_name);
+          return;
+        }
+
+      if (info->theme->style_sets_by_type[type] != NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Window type \"%s\" has already been assigned a style set"),
+                     type_name);
+          return;
+        }
+
+      meta_frame_style_set_ref (style_set);
+      info->theme->style_sets_by_type[type] = style_set;
+
+      push_state (info, STATE_WINDOW);
+    }
+  else if (ELEMENT_IS ("menu_icon"))
+    {
+      /* Not supported any more, but we have to parse it if they include it,
+       * for backwards compatibility.
+       */
+      g_assert (info->op_list == NULL);
+
+      push_state (info, STATE_MENU_ICON);
+    }
+  else if (ELEMENT_IS ("fallback"))
+    {
+      /* Not supported any more, but we have to parse it if they include it,
+       * for backwards compatibility.
+       */
+      push_state (info, STATE_FALLBACK);
+    }
+   else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "metacity_theme");
+    }
+}
+
+static void
+parse_info_element (GMarkupParseContext  *context,
+                    const gchar          *element_name,
+                    const gchar         **attribute_names,
+                    const gchar         **attribute_values,
+                    ParseInfo            *info,
+                    GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_INFO);
+
+  if (ELEMENT_IS ("name"))
+    {
+      if (!check_no_attributes (context, element_name,
+                                attribute_names, attribute_values,
+                                error))
+        return;
+
+      push_state (info, STATE_NAME);
+    }
+  else if (ELEMENT_IS ("author"))
+    {
+      if (!check_no_attributes (context, element_name,
+                                attribute_names, attribute_values,
+                                error))
+        return;
+
+      push_state (info, STATE_AUTHOR);
+    }
+  else if (ELEMENT_IS ("copyright"))
+    {
+      if (!check_no_attributes (context, element_name,
+                                attribute_names, attribute_values,
+                                error))
+        return;
+
+      push_state (info, STATE_COPYRIGHT);
+    }
+  else if (ELEMENT_IS ("description"))
+    {
+      if (!check_no_attributes (context, element_name,
+                                attribute_names, attribute_values,
+                                error))
+        return;
+
+      push_state (info, STATE_DESCRIPTION);
+    }
+  else if (ELEMENT_IS ("date"))
+    {
+      if (!check_no_attributes (context, element_name,
+                                attribute_names, attribute_values,
+                                error))
+        return;
+
+      push_state (info, STATE_DATE);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "info");
+    }
+}
+
+static void
+parse_distance (GMarkupParseContext  *context,
+                const gchar          *element_name,
+                const gchar         **attribute_names,
+                const gchar         **attribute_values,
+                ParseInfo            *info,
+                GError              **error)
+{
+  const char *name;
+  const char *value;
+  int val;
+
+  if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                          error,
+                          "!name", &name, "!value", &value,
+                          NULL))
+    return;
+
+  val = 0;
+  if (!parse_positive_integer (value, &val, context, info->theme, error))
+    return;
+
+  g_assert (val >= 0); /* yeah, "non-negative" not "positive" get over it */
+  g_assert (info->layout);
+
+  if (strcmp (name, "left_width") == 0)
+    info->layout->left_width = val;
+  else if (strcmp (name, "right_width") == 0)
+    info->layout->right_width = val;
+  else if (strcmp (name, "bottom_height") == 0)
+    info->layout->bottom_height = val;
+  else if (strcmp (name, "title_vertical_pad") == 0)
+    info->layout->title_vertical_pad = val;
+  else if (strcmp (name, "right_titlebar_edge") == 0)
+    info->layout->right_titlebar_edge = val;
+  else if (strcmp (name, "left_titlebar_edge") == 0)
+    info->layout->left_titlebar_edge = val;
+  else if (strcmp (name, "button_width") == 0)
+    {
+      info->layout->button_width = val;
+
+      if (!(info->layout->button_sizing == META_BUTTON_SIZING_LAST ||
+            info->layout->button_sizing == META_BUTTON_SIZING_FIXED))
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Cannot specify both \"button_width\"/\"button_height\" and \"aspect_ratio\" for buttons"));
+          return;
+        }
+
+      info->layout->button_sizing = META_BUTTON_SIZING_FIXED;
+    }
+  else if (strcmp (name, "button_height") == 0)
+    {
+      info->layout->button_height = val;
+
+      if (!(info->layout->button_sizing == META_BUTTON_SIZING_LAST ||
+            info->layout->button_sizing == META_BUTTON_SIZING_FIXED))
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Cannot specify both \"button_width\"/\"button_height\" and \"aspect_ratio\" for buttons"));
+          return;
+        }
+
+      info->layout->button_sizing = META_BUTTON_SIZING_FIXED;
+    }
+  else
+    {
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Distance \"%s\" is unknown"), name);
+      return;
+    }
+}
+
+static void
+parse_aspect_ratio (GMarkupParseContext  *context,
+                    const gchar          *element_name,
+                    const gchar         **attribute_names,
+                    const gchar         **attribute_values,
+                    ParseInfo            *info,
+                    GError              **error)
+{
+  const char *name;
+  const char *value;
+  double val;
+
+  if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                          error,
+                          "!name", &name, "!value", &value,
+                          NULL))
+    return;
+
+  val = 0;
+  if (!parse_double (value, &val, context, error))
+    return;
+
+  g_assert (info->layout);
+
+  if (strcmp (name, "button") == 0)
+    {
+      info->layout->button_aspect = val;
+
+      if (info->layout->button_sizing != META_BUTTON_SIZING_LAST)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Cannot specify both \"button_width\"/\"button_height\" and \"aspect_ratio\" for buttons"));
+          return;
+        }
+
+      info->layout->button_sizing = META_BUTTON_SIZING_ASPECT;
+    }
+  else
+    {
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Aspect ratio \"%s\" is unknown"), name);
+      return;
+    }
+}
+
+static void
+parse_border (GMarkupParseContext  *context,
+              const gchar          *element_name,
+              const gchar         **attribute_names,
+              const gchar         **attribute_values,
+              ParseInfo            *info,
+              GError              **error)
+{
+  const char *name;
+  const char *top;
+  const char *bottom;
+  const char *left;
+  const char *right;
+  int top_val;
+  int bottom_val;
+  int left_val;
+  int right_val;
+  GtkBorder *border;
+
+  if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                          error,
+                          "!name", &name,
+                          "!top", &top,
+                          "!bottom", &bottom,
+                          "!left", &left,
+                          "!right", &right,
+                          NULL))
+    return;
+
+  top_val = 0;
+  if (!parse_positive_integer (top, &top_val, context, info->theme, error))
+    return;
+
+  bottom_val = 0;
+  if (!parse_positive_integer (bottom, &bottom_val, context, info->theme, error))
+    return;
+
+  left_val = 0;
+  if (!parse_positive_integer (left, &left_val, context, info->theme, error))
+    return;
+
+  right_val = 0;
+  if (!parse_positive_integer (right, &right_val, context, info->theme, error))
+    return;
+
+  g_assert (info->layout);
+
+  border = NULL;
+
+  if (strcmp (name, "title_border") == 0)
+    border = &info->layout->title_border;
+  else if (strcmp (name, "button_border") == 0)
+    border = &info->layout->button_border;
+
+  if (border == NULL)
+    {
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Border \"%s\" is unknown"), name);
+      return;
+    }
+
+  border->top = top_val;
+  border->bottom = bottom_val;
+  border->left = left_val;
+  border->right = right_val;
+}
+
+static void
+parse_geometry_element (GMarkupParseContext  *context,
+                        const gchar          *element_name,
+                        const gchar         **attribute_names,
+                        const gchar         **attribute_values,
+                        ParseInfo            *info,
+                        GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_FRAME_GEOMETRY);
+
+  if (ELEMENT_IS ("distance"))
+    {
+      parse_distance (context, element_name,
+                      attribute_names, attribute_values,
+                      info, error);
+      push_state (info, STATE_DISTANCE);
+    }
+  else if (ELEMENT_IS ("border"))
+    {
+      parse_border (context, element_name,
+                    attribute_names, attribute_values,
+                    info, error);
+      push_state (info, STATE_BORDER);
+    }
+  else if (ELEMENT_IS ("aspect_ratio"))
+    {
+      parse_aspect_ratio (context, element_name,
+                          attribute_names, attribute_values,
+                          info, error);
+
+      push_state (info, STATE_ASPECT_RATIO);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "frame_geometry");
+    }
+}
+
+#if 0
+static gboolean
+check_expression (PosToken            *tokens,
+                  int                  n_tokens,
+                  gboolean             has_object,
+                  MetaTheme           *theme,
+                  GMarkupParseContext *context,
+                  GError             **error)
+{
+  MetaPositionExprEnv env;
+  int x, y;
+
+  /* We set it all to 0 to try and catch divide-by-zero screwups.
+   * it's possible we should instead guarantee that widths and heights
+   * are at least 1.
+   */
+
+  env.rect = meta_rect (0, 0, 0, 0);
+  if (has_object)
+    {
+      env.object_width = 0;
+      env.object_height = 0;
+    }
+  else
+    {
+      env.object_width = -1;
+      env.object_height = -1;
+    }
+
+  env.left_width = 0;
+  env.right_width = 0;
+  env.top_height = 0;
+  env.bottom_height = 0;
+  env.title_width = 0;
+  env.title_height = 0;
+
+  env.icon_width = 0;
+  env.icon_height = 0;
+  env.mini_icon_width = 0;
+  env.mini_icon_height = 0;
+  env.theme = theme;
+
+  if (!meta_parse_position_expression (tokens, n_tokens,
+                                       &env,
+                                       &x, &y,
+                                       error))
+    {
+      add_context_to_error (error, context);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+#endif
+
+static void
+parse_draw_op_element (GMarkupParseContext  *context,
+                       const gchar          *element_name,
+                       const gchar         **attribute_names,
+                       const gchar         **attribute_values,
+                       ParseInfo            *info,
+                       GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_DRAW_OPS);
+
+  if (ELEMENT_IS ("line"))
+    {
+      MetaDrawOp *op;
+      const char *color;
+      const char *x1;
+      const char *y1;
+      const char *x2;
+      const char *y2;
+      const char *dash_on_length;
+      const char *dash_off_length;
+      const char *width;
+      MetaColorSpec *color_spec;
+      int dash_on_val;
+      int dash_off_val;
+      int width_val;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!color", &color,
+                              "!x1", &x1, "!y1", &y1,
+                              "!x2", &x2, "!y2", &y2,
+                              "dash_on_length", &dash_on_length,
+                              "dash_off_length", &dash_off_length,
+                              "width", &width,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x1, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y1, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (x2, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y2, FALSE, info->theme, context, error))
+        return;
+#endif
+
+      dash_on_val = 0;
+      if (dash_on_length &&
+          !parse_positive_integer (dash_on_length, &dash_on_val, context, info->theme, error))
+        return;
+
+      dash_off_val = 0;
+      if (dash_off_length &&
+          !parse_positive_integer (dash_off_length, &dash_off_val, context, info->theme, error))
+        return;
+
+      width_val = 0;
+      if (width &&
+          !parse_positive_integer (width, &width_val, context, info->theme, error))
+        return;
+
+      /* Check last so we don't have to free it when other
+       * stuff fails
+       */
+      color_spec = parse_color (info->theme, color, error);
+      if (color_spec == NULL)
+        {
+          add_context_to_error (error, context);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_LINE);
+
+      op->data.line.color_spec = color_spec;
+
+      op->data.line.x1 = meta_draw_spec_new (info->theme, x1, NULL);
+      op->data.line.y1 = meta_draw_spec_new (info->theme, y1, NULL);
+
+      if (strcmp(x1, x2)==0)
+        op->data.line.x2 = NULL;
+      else
+        op->data.line.x2 = meta_draw_spec_new (info->theme, x2, NULL);
+
+      if (strcmp(y1, y2)==0)
+        op->data.line.y2 = NULL;
+      else
+        op->data.line.y2 = meta_draw_spec_new (info->theme, y2, NULL);
+
+      op->data.line.width = width_val;
+      op->data.line.dash_on_length = dash_on_val;
+      op->data.line.dash_off_length = dash_off_val;
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_LINE);
+    }
+  else if (ELEMENT_IS ("rectangle"))
+    {
+      MetaDrawOp *op;
+      const char *color;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      const char *filled;
+      gboolean filled_val;
+      MetaColorSpec *color_spec;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!color", &color,
+                              "!x", &x, "!y", &y,
+                              "!width", &width, "!height", &height,
+                              "filled", &filled,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (height, FALSE, info->theme, context, error))
+        return;
+#endif
+
+      filled_val = FALSE;
+      if (filled && !parse_boolean (filled, &filled_val, context, error))
+        return;
+
+      /* Check last so we don't have to free it when other
+       * stuff fails
+       */
+      color_spec = parse_color (info->theme, color, error);
+      if (color_spec == NULL)
+        {
+          add_context_to_error (error, context);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_RECTANGLE);
+
+      op->data.rectangle.color_spec = color_spec;
+      op->data.rectangle.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.rectangle.y = meta_draw_spec_new (info->theme, y, NULL);
+      op->data.rectangle.width = meta_draw_spec_new (info->theme, width, NULL);
+      op->data.rectangle.height = meta_draw_spec_new (info->theme,
+                                                      height, NULL);
+
+      op->data.rectangle.filled = filled_val;
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_RECTANGLE);
+    }
+  else if (ELEMENT_IS ("arc"))
+    {
+      MetaDrawOp *op;
+      const char *color;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      const char *filled;
+      const char *start_angle;
+      const char *extent_angle;
+      const char *from;
+      const char *to;
+      gboolean filled_val;
+      double start_angle_val;
+      double extent_angle_val;
+      MetaColorSpec *color_spec;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!color", &color,
+                              "!x", &x, "!y", &y,
+                              "!width", &width, "!height", &height,
+                              "filled", &filled,
+                              "start_angle", &start_angle,
+                              "extent_angle", &extent_angle,
+                              "from", &from,
+                              "to", &to,
+                              NULL))
+        return;
+
+      if (META_THEME_ALLOWS (info->theme, META_THEME_DEGREES_IN_ARCS) )
+        {
+          if (start_angle == NULL && from == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("No \"start_angle\" or \"from\" attribute on element <%s>"), element_name);
+              return;
+            }
+
+          if (extent_angle == NULL && to == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("No \"extent_angle\" or \"to\" attribute on element <%s>"), element_name);
+              return;
+            }
+        }
+      else
+        {
+          if (start_angle == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         ATTRIBUTE_NOT_FOUND, "start_angle", element_name);
+              return;
+            }
+
+          if (extent_angle == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         ATTRIBUTE_NOT_FOUND, "extent_angle", element_name);
+              return;
+            }
+        }
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (height, FALSE, info->theme, context, error))
+        return;
+#endif
+
+      if (start_angle == NULL)
+        {
+          if (!parse_angle (from, &start_angle_val, context, error))
+            return;
+
+          start_angle_val = (180-start_angle_val)/360.0;
+        }
+      else
+        {
+          if (!parse_angle (start_angle, &start_angle_val, context, error))
+            return;
+        }
+
+      if (extent_angle == NULL)
+        {
+          if (!parse_angle (to, &extent_angle_val, context, error))
+            return;
+
+          extent_angle_val = ((180-extent_angle_val)/360.0) - start_angle_val;
+        }
+      else
+        {
+           if (!parse_angle (extent_angle, &extent_angle_val, context, error))
+             return;
+        }
+
+      filled_val = FALSE;
+      if (filled && !parse_boolean (filled, &filled_val, context, error))
+        return;
+
+      /* Check last so we don't have to free it when other
+       * stuff fails
+       */
+      color_spec = parse_color (info->theme, color, error);
+      if (color_spec == NULL)
+        {
+          add_context_to_error (error, context);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_ARC);
+
+      op->data.arc.color_spec = color_spec;
+
+      op->data.arc.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.arc.y = meta_draw_spec_new (info->theme, y, NULL);
+      op->data.arc.width = meta_draw_spec_new (info->theme, width, NULL);
+      op->data.arc.height = meta_draw_spec_new (info->theme, height, NULL);
+
+      op->data.arc.filled = filled_val;
+      op->data.arc.start_angle = start_angle_val;
+      op->data.arc.extent_angle = extent_angle_val;
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_ARC);
+    }
+  else if (ELEMENT_IS ("clip"))
+    {
+      MetaDrawOp *op;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!x", &x, "!y", &y,
+                              "!width", &width, "!height", &height,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (height, FALSE, info->theme, context, error))
+        return;
+#endif
+      op = meta_draw_op_new (META_DRAW_CLIP);
+
+      op->data.clip.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.clip.y = meta_draw_spec_new (info->theme, y, NULL);
+      op->data.clip.width = meta_draw_spec_new (info->theme, width, NULL);
+      op->data.clip.height = meta_draw_spec_new (info->theme, height, NULL);
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_CLIP);
+    }
+  else if (ELEMENT_IS ("tint"))
+    {
+      MetaDrawOp *op;
+      const char *color;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      const char *alpha;
+      MetaAlphaGradientSpec *alpha_spec;
+      MetaColorSpec *color_spec;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!color", &color,
+                              "!x", &x, "!y", &y,
+                              "!width", &width, "!height", &height,
+                              "!alpha", &alpha,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (height, FALSE, info->theme, context, error))
+        return;
+#endif
+      alpha_spec = NULL;
+      if (!parse_alpha (alpha, &alpha_spec, context, error))
+        return;
+
+      /* Check last so we don't have to free it when other
+       * stuff fails
+       */
+      color_spec = parse_color (info->theme, color, error);
+      if (color_spec == NULL)
+        {
+          if (alpha_spec)
+            meta_alpha_gradient_spec_free (alpha_spec);
+
+          add_context_to_error (error, context);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_TINT);
+
+      op->data.tint.color_spec = color_spec;
+      op->data.tint.alpha_spec = alpha_spec;
+
+      op->data.tint.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.tint.y = meta_draw_spec_new (info->theme, y, NULL);
+      op->data.tint.width = meta_draw_spec_new (info->theme, width, NULL);
+      op->data.tint.height = meta_draw_spec_new (info->theme, height, NULL);
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_TINT);
+    }
+  else if (ELEMENT_IS ("gradient"))
+    {
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      const char *type;
+      const char *alpha;
+      MetaAlphaGradientSpec *alpha_spec;
+      MetaGradientType type_val;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!type", &type,
+                              "!x", &x, "!y", &y,
+                              "!width", &width, "!height", &height,
+                              "alpha", &alpha,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (height, FALSE, info->theme, context, error))
+        return;
+#endif
+
+      type_val = meta_gradient_type_from_string (type);
+      if (type_val == META_GRADIENT_LAST)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Did not understand value \"%s\" for type of gradient"),
+                     type);
+          return;
+        }
+
+      alpha_spec = NULL;
+      if (alpha && !parse_alpha (alpha, &alpha_spec, context, error))
+        return;
+
+      g_assert (info->op == NULL);
+      info->op = meta_draw_op_new (META_DRAW_GRADIENT);
+
+      info->op->data.gradient.x = meta_draw_spec_new (info->theme, x, NULL);
+      info->op->data.gradient.y = meta_draw_spec_new (info->theme, y, NULL);
+      info->op->data.gradient.width = meta_draw_spec_new (info->theme,
+                                                        width, NULL);
+      info->op->data.gradient.height = meta_draw_spec_new (info->theme,
+                                                         height, NULL);
+
+      info->op->data.gradient.gradient_spec = meta_gradient_spec_new (type_val);
+
+      info->op->data.gradient.alpha_spec = alpha_spec;
+
+      push_state (info, STATE_GRADIENT);
+
+      /* op gets appended on close tag */
+    }
+  else if (ELEMENT_IS ("image"))
+    {
+      MetaDrawOp *op;
+      const char *filename;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      const char *alpha;
+      const char *colorize;
+      const char *fill_type;
+      MetaAlphaGradientSpec *alpha_spec;
+      GdkPixbuf *pixbuf;
+      MetaColorSpec *colorize_spec = NULL;
+      MetaImageFillType fill_type_val;
+      int h, w, c;
+      int pixbuf_width, pixbuf_height, pixbuf_n_channels, pixbuf_rowstride;
+      guchar *pixbuf_pixels;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!x", &x, "!y", &y,
+                              "!width", &width, "!height", &height,
+                              "alpha", &alpha, "!filename", &filename,
+                              "colorize", &colorize,
+                              "fill_type", &fill_type,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, TRUE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, TRUE, info->theme, context, error))
+        return;
+
+      if (!check_expression (width, TRUE, info->theme, context, error))
+        return;
+
+      if (!check_expression (height, TRUE, info->theme, context, error))
+        return;
+#endif
+      fill_type_val = META_IMAGE_FILL_SCALE;
+      if (fill_type)
+        {
+          fill_type_val = meta_image_fill_type_from_string (fill_type);
+
+          if (((int) fill_type_val) == -1)
+            {
+              set_error (error, context, G_MARKUP_ERROR,
+                         G_MARKUP_ERROR_PARSE,
+                         _("Did not understand fill type \"%s\" for <%s> element"),
+                         fill_type, element_name);
+            }
+        }
+
+      /* Check last so we don't have to free it when other
+       * stuff fails.
+       *
+       * If it's a theme image, ask for it at 64px, which is
+       * the largest possible. We scale it anyway.
+       */
+      pixbuf = meta_theme_load_image (info->theme, filename, 64, error);
+
+      if (pixbuf == NULL)
+        {
+          add_context_to_error (error, context);
+          return;
+        }
+
+      if (colorize)
+        {
+          colorize_spec = parse_color (info->theme, colorize, error);
+
+          if (colorize_spec == NULL)
+            {
+              add_context_to_error (error, context);
+              g_object_unref (G_OBJECT (pixbuf));
+              return;
+            }
+        }
+
+      alpha_spec = NULL;
+      if (alpha && !parse_alpha (alpha, &alpha_spec, context, error))
+        {
+          g_object_unref (G_OBJECT (pixbuf));
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_IMAGE);
+
+      op->data.image.pixbuf = pixbuf;
+      op->data.image.colorize_spec = colorize_spec;
+
+      op->data.image.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.image.y = meta_draw_spec_new (info->theme, y, NULL);
+      op->data.image.width = meta_draw_spec_new (info->theme, width, NULL);
+      op->data.image.height = meta_draw_spec_new (info->theme, height, NULL);
+
+      op->data.image.alpha_spec = alpha_spec;
+      op->data.image.fill_type = fill_type_val;
+
+      /* Check for vertical & horizontal stripes */
+      pixbuf_n_channels = gdk_pixbuf_get_n_channels(pixbuf);
+      pixbuf_width = gdk_pixbuf_get_width(pixbuf);
+      pixbuf_height = gdk_pixbuf_get_height(pixbuf);
+      pixbuf_rowstride = gdk_pixbuf_get_rowstride(pixbuf);
+      pixbuf_pixels = gdk_pixbuf_get_pixels(pixbuf);
+
+      /* Check for horizontal stripes */
+      for (h = 0; h < pixbuf_height; h++)
+        {
+          for (w = 1; w < pixbuf_width; w++)
+            {
+              for (c = 0; c < pixbuf_n_channels; c++)
+                {
+                  if (pixbuf_pixels[(h * pixbuf_rowstride) + c] !=
+                      pixbuf_pixels[(h * pixbuf_rowstride) + w + c])
+                    break;
+                }
+              if (c < pixbuf_n_channels)
+                break;
+            }
+          if (w < pixbuf_width)
+            break;
+        }
+
+      if (h >= pixbuf_height)
+        {
+          op->data.image.horizontal_stripes = TRUE;
+        }
+      else
+        {
+          op->data.image.horizontal_stripes = FALSE;
+        }
+
+      /* Check for vertical stripes */
+      for (w = 0; w < pixbuf_width; w++)
+        {
+          for (h = 1; h < pixbuf_height; h++)
+            {
+              for (c = 0; c < pixbuf_n_channels; c++)
+                {
+                  if (pixbuf_pixels[w + c] !=
+                      pixbuf_pixels[(h * pixbuf_rowstride) + w + c])
+                    break;
+                }
+              if (c < pixbuf_n_channels)
+                break;
+            }
+          if (h < pixbuf_height)
+            break;
+        }
+
+      if (w >= pixbuf_width)
+        {
+          op->data.image.vertical_stripes = TRUE;
+        }
+      else
+        {
+          op->data.image.vertical_stripes = FALSE;
+        }
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_IMAGE);
+    }
+  else if (ELEMENT_IS ("gtk_arrow"))
+    {
+      MetaDrawOp *op;
+      const char *state;
+      const char *shadow;
+      const char *arrow;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      const char *filled;
+      gboolean filled_val;
+      GtkStateFlags state_val;
+      GtkShadowType shadow_val;
+      GtkArrowType arrow_val;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!state", &state,
+                              "!shadow", &shadow,
+                              "!arrow", &arrow,
+                              "!x", &x, "!y", &y,
+                              "!width", &width, "!height", &height,
+                              "filled", &filled,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (height, FALSE, info->theme, context, error))
+        return;
+#endif
+      filled_val = TRUE;
+      if (filled && !parse_boolean (filled, &filled_val, context, error))
+        return;
+
+      state_val = meta_gtk_state_from_string (state);
+      if (((int) state_val) == -1)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Did not understand state \"%s\" for <%s> element"),
+                     state, element_name);
+          return;
+        }
+
+      shadow_val = meta_gtk_shadow_from_string (shadow);
+      if (((int) shadow_val) == -1)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Did not understand shadow \"%s\" for <%s> element"),
+                     shadow, element_name);
+          return;
+        }
+
+      arrow_val = meta_gtk_arrow_from_string (arrow);
+      if (((int) arrow_val) == -1)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Did not understand arrow \"%s\" for <%s> element"),
+                     arrow, element_name);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_GTK_ARROW);
+
+      op->data.gtk_arrow.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.gtk_arrow.y = meta_draw_spec_new (info->theme, y, NULL);
+      op->data.gtk_arrow.width = meta_draw_spec_new (info->theme, width, NULL);
+      op->data.gtk_arrow.height = meta_draw_spec_new (info->theme,
+                                                      height, NULL);
+
+      op->data.gtk_arrow.filled = filled_val;
+      op->data.gtk_arrow.state = state_val;
+      op->data.gtk_arrow.shadow = shadow_val;
+      op->data.gtk_arrow.arrow = arrow_val;
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_GTK_ARROW);
+    }
+  else if (ELEMENT_IS ("gtk_box"))
+    {
+      MetaDrawOp *op;
+      const char *state;
+      const char *shadow;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      GtkStateFlags state_val;
+      GtkShadowType shadow_val;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!state", &state,
+                              "!shadow", &shadow,
+                              "!x", &x, "!y", &y,
+                              "!width", &width, "!height", &height,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (height, FALSE, info->theme, context, error))
+        return;
+#endif
+      state_val = meta_gtk_state_from_string (state);
+      if (((int) state_val) == -1)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Did not understand state \"%s\" for <%s> element"),
+                     state, element_name);
+          return;
+        }
+
+      shadow_val = meta_gtk_shadow_from_string (shadow);
+      if (((int) shadow_val) == -1)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Did not understand shadow \"%s\" for <%s> element"),
+                     shadow, element_name);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_GTK_BOX);
+
+      op->data.gtk_box.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.gtk_box.y = meta_draw_spec_new (info->theme, y, NULL);
+      op->data.gtk_box.width = meta_draw_spec_new (info->theme, width, NULL);
+      op->data.gtk_box.height = meta_draw_spec_new (info->theme, height, NULL);
+
+      op->data.gtk_box.state = state_val;
+      op->data.gtk_box.shadow = shadow_val;
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_GTK_BOX);
+    }
+  else if (ELEMENT_IS ("gtk_vline"))
+    {
+      MetaDrawOp *op;
+      const char *state;
+      const char *x;
+      const char *y1;
+      const char *y2;
+      GtkStateFlags state_val;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!state", &state,
+                              "!x", &x, "!y1", &y1, "!y2", &y2,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y1, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y2, FALSE, info->theme, context, error))
+        return;
+#endif
+
+      state_val = meta_gtk_state_from_string (state);
+      if (((int) state_val) == -1)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Did not understand state \"%s\" for <%s> element"),
+                     state, element_name);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_GTK_VLINE);
+
+      op->data.gtk_vline.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.gtk_vline.y1 = meta_draw_spec_new (info->theme, y1, NULL);
+      op->data.gtk_vline.y2 = meta_draw_spec_new (info->theme, y2, NULL);
+
+      op->data.gtk_vline.state = state_val;
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_GTK_VLINE);
+    }
+  else if (ELEMENT_IS ("icon"))
+    {
+      MetaDrawOp *op;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      const char *alpha;
+      const char *fill_type;
+      MetaAlphaGradientSpec *alpha_spec;
+      MetaImageFillType fill_type_val;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!x", &x, "!y", &y,
+                              "!width", &width, "!height", &height,
+                              "alpha", &alpha,
+                              "fill_type", &fill_type,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (height, FALSE, info->theme, context, error))
+        return;
+#endif
+      fill_type_val = META_IMAGE_FILL_SCALE;
+      if (fill_type)
+        {
+          fill_type_val = meta_image_fill_type_from_string (fill_type);
+
+          if (((int) fill_type_val) == -1)
+            {
+              set_error (error, context, G_MARKUP_ERROR,
+                         G_MARKUP_ERROR_PARSE,
+                         _("Did not understand fill type \"%s\" for <%s> element"),
+                         fill_type, element_name);
+            }
+        }
+
+      alpha_spec = NULL;
+      if (alpha && !parse_alpha (alpha, &alpha_spec, context, error))
+        return;
+
+      op = meta_draw_op_new (META_DRAW_ICON);
+
+      op->data.icon.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.icon.y = meta_draw_spec_new (info->theme, y, NULL);
+      op->data.icon.width = meta_draw_spec_new (info->theme, width, NULL);
+      op->data.icon.height = meta_draw_spec_new (info->theme, height, NULL);
+
+      op->data.icon.alpha_spec = alpha_spec;
+      op->data.icon.fill_type = fill_type_val;
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_ICON);
+    }
+  else if (ELEMENT_IS ("title"))
+    {
+      MetaDrawOp *op;
+      const char *color;
+      const char *x;
+      const char *y;
+      const char *ellipsize_width;
+      MetaColorSpec *color_spec;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!color", &color,
+                              "!x", &x, "!y", &y,
+                              "ellipsize_width", &ellipsize_width,
+                              NULL))
+        return;
+
+#if 0
+      if (!check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (ellipsize_width, FALSE, info->theme, context, error))
+        return;
+#endif
+
+      if (ellipsize_width && peek_required_version (info) < 3001)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     ATTRIBUTE_NOT_FOUND, "ellipsize_width", element_name);
+          return;
+        }
+
+      /* Check last so we don't have to free it when other
+       * stuff fails
+       */
+      color_spec = parse_color (info->theme, color, error);
+      if (color_spec == NULL)
+        {
+          add_context_to_error (error, context);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_TITLE);
+
+      op->data.title.color_spec = color_spec;
+
+      op->data.title.x = meta_draw_spec_new (info->theme, x, NULL);
+      op->data.title.y = meta_draw_spec_new (info->theme, y, NULL);
+      if (ellipsize_width)
+        op->data.title.ellipsize_width = meta_draw_spec_new (info->theme, ellipsize_width, NULL);
+
+      g_assert (info->op_list);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_TITLE);
+    }
+  else if (ELEMENT_IS ("include"))
+    {
+      MetaDrawOp *op;
+      const char *name;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      MetaDrawOpList *op_list;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "x", &x, "y", &y,
+                              "width", &width, "height", &height,
+                              "!name", &name,
+                              NULL))
+        return;
+
+      /* x/y/width/height default to 0,0,width,height - should
+       * probably do this for all the draw ops
+       */
+#if 0
+      if (x && !check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (y && !check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (width && !check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (height && !check_expression (height, FALSE, info->theme, context, error))
+        return;
+#endif
+
+      op_list = meta_theme_lookup_draw_op_list (info->theme,
+                                                name);
+      if (op_list == NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("No <draw_ops> called \"%s\" has been defined"),
+                     name);
+          return;
+        }
+
+      g_assert (info->op_list);
+
+      if (op_list == info->op_list ||
+          meta_draw_op_list_contains (op_list, info->op_list))
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Including draw_ops \"%s\" here would create a circular reference"),
+                     name);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_OP_LIST);
+
+      meta_draw_op_list_ref (op_list);
+      op->data.op_list.op_list = op_list;
+
+      op->data.op_list.x = meta_draw_spec_new (info->theme, x ? x : "0", NULL);
+      op->data.op_list.y = meta_draw_spec_new (info->theme, y ? y : "0", NULL);
+      op->data.op_list.width = meta_draw_spec_new (info->theme,
+                                                   width ? width : "width",
+                                                   NULL);
+      op->data.op_list.height = meta_draw_spec_new (info->theme,
+                                                    height ? height : "height",
+                                                    NULL);
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_INCLUDE);
+    }
+  else if (ELEMENT_IS ("tile"))
+    {
+      MetaDrawOp *op;
+      const char *name;
+      const char *x;
+      const char *y;
+      const char *width;
+      const char *height;
+      const char *tile_xoffset;
+      const char *tile_yoffset;
+      const char *tile_width;
+      const char *tile_height;
+      MetaDrawOpList *op_list;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "x", &x, "y", &y,
+                              "width", &width, "height", &height,
+                              "!name", &name,
+                              "tile_xoffset", &tile_xoffset,
+                              "tile_yoffset", &tile_yoffset,
+                              "!tile_width", &tile_width,
+                              "!tile_height", &tile_height,
+                              NULL))
+        return;
+
+      /* These default to 0 */
+#if 0
+      if (tile_xoffset && !check_expression (tile_xoffset, FALSE, info->theme, context, error))
+        return;
+
+      if (tile_yoffset && !check_expression (tile_yoffset, FALSE, info->theme, context, error))
+        return;
+
+      /* x/y/width/height default to 0,0,width,height - should
+       * probably do this for all the draw ops
+       */
+      if (x && !check_expression (x, FALSE, info->theme, context, error))
+        return;
+
+      if (y && !check_expression (y, FALSE, info->theme, context, error))
+        return;
+
+      if (width && !check_expression (width, FALSE, info->theme, context, error))
+        return;
+
+      if (height && !check_expression (height, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (tile_width, FALSE, info->theme, context, error))
+        return;
+
+      if (!check_expression (tile_height, FALSE, info->theme, context, error))
+        return;
+#endif
+      op_list = meta_theme_lookup_draw_op_list (info->theme,
+                                                name);
+      if (op_list == NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("No <draw_ops> called \"%s\" has been defined"),
+                     name);
+          return;
+        }
+
+      g_assert (info->op_list);
+
+      if (op_list == info->op_list ||
+          meta_draw_op_list_contains (op_list, info->op_list))
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("Including draw_ops \"%s\" here would create a circular reference"),
+                     name);
+          return;
+        }
+
+      op = meta_draw_op_new (META_DRAW_TILE);
+
+      meta_draw_op_list_ref (op_list);
+
+      op->data.tile.x = meta_draw_spec_new (info->theme, x ? x : "0", NULL);
+      op->data.tile.y = meta_draw_spec_new (info->theme, y ? y : "0", NULL);
+      op->data.tile.width = meta_draw_spec_new (info->theme,
+                                                width ? width : "width",
+                                                NULL);
+      op->data.tile.height = meta_draw_spec_new (info->theme,
+                                                 height ? height : "height",
+                                                 NULL);
+      op->data.tile.tile_xoffset = meta_draw_spec_new (info->theme,
+                                                       tile_xoffset ? tile_xoffset : "0",
+                                                       NULL);
+      op->data.tile.tile_yoffset = meta_draw_spec_new (info->theme,
+                                                       tile_yoffset ? tile_yoffset : "0",
+                                                       NULL);
+      op->data.tile.tile_width = meta_draw_spec_new (info->theme, tile_width, NULL);
+      op->data.tile.tile_height = meta_draw_spec_new (info->theme, tile_height, NULL);
+
+      op->data.tile.op_list = op_list;
+
+      meta_draw_op_list_append (info->op_list, op);
+
+      push_state (info, STATE_TILE);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "draw_ops");
+    }
+}
+
+static void
+parse_gradient_element (GMarkupParseContext  *context,
+                        const gchar          *element_name,
+                        const gchar         **attribute_names,
+                        const gchar         **attribute_values,
+                        ParseInfo            *info,
+                        GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_GRADIENT);
+
+  if (ELEMENT_IS ("color"))
+    {
+      const char *value = NULL;
+      MetaColorSpec *color_spec;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!value", &value,
+                              NULL))
+        return;
+
+      color_spec = parse_color (info->theme, value, error);
+      if (color_spec == NULL)
+        {
+          add_context_to_error (error, context);
+          return;
+        }
+
+      g_assert (info->op);
+      g_assert (info->op->type == META_DRAW_GRADIENT);
+      g_assert (info->op->data.gradient.gradient_spec != NULL);
+      info->op->data.gradient.gradient_spec->color_specs =
+        g_slist_append (info->op->data.gradient.gradient_spec->color_specs,
+                        color_spec);
+
+      push_state (info, STATE_COLOR);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "gradient");
+    }
+}
+
+static void
+parse_style_element (GMarkupParseContext  *context,
+                     const gchar          *element_name,
+                     const gchar         **attribute_names,
+                     const gchar         **attribute_values,
+                     ParseInfo            *info,
+                     GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_FRAME_STYLE);
+
+  g_assert (info->style);
+
+  if (ELEMENT_IS ("piece"))
+    {
+      const char *position = NULL;
+      const char *draw_ops = NULL;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!position", &position,
+                              "draw_ops", &draw_ops,
+                              NULL))
+        return;
+
+      info->piece = meta_frame_piece_from_string (position);
+      if (info->piece == META_FRAME_PIECE_LAST)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Unknown position \"%s\" for frame piece"),
+                     position);
+          return;
+        }
+
+      if (info->style->pieces[info->piece] != NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Frame style already has a piece at position %s"),
+                     position);
+          return;
+        }
+
+      g_assert (info->op_list == NULL);
+
+      if (draw_ops)
+        {
+          MetaDrawOpList *op_list;
+
+          op_list = meta_theme_lookup_draw_op_list (info->theme,
+                                                    draw_ops);
+
+          if (op_list == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("No <draw_ops> with the name \"%s\" has been defined"),
+                         draw_ops);
+              return;
+            }
+
+          meta_draw_op_list_ref (op_list);
+          info->op_list = op_list;
+        }
+
+      push_state (info, STATE_PIECE);
+    }
+  else if (ELEMENT_IS ("button"))
+    {
+      const char *function = NULL;
+      const char *state = NULL;
+      const char *draw_ops = NULL;
+      gint required_version;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!function", &function,
+                              "!state", &state,
+                              "draw_ops", &draw_ops,
+                              NULL))
+        return;
+
+      info->button_type = meta_button_type_from_string (function, info->theme);
+      if (info->button_type == META_BUTTON_TYPE_LAST)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Unknown function \"%s\" for button"),
+                     function);
+          return;
+        }
+
+      required_version = peek_required_version (info);
+      if (meta_theme_earliest_version_with_button (info->button_type) >
+          (guint)required_version)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Button function \"%s\" does not exist in this version (%d, need %d)"),
+                     function,
+                     required_version,
+                     meta_theme_earliest_version_with_button (info->button_type)
+                     );
+          return;
+        }
+
+      info->button_state = meta_button_state_from_string (state);
+      if (info->button_state == META_BUTTON_STATE_LAST)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Unknown state \"%s\" for button"),
+                     state);
+          return;
+        }
+
+      if (info->style->buttons[info->button_type][info->button_state] != NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Frame style already has a button for function %s state %s"),
+                     function, state);
+          return;
+        }
+
+      g_assert (info->op_list == NULL);
+
+      if (draw_ops)
+        {
+          MetaDrawOpList *op_list;
+
+          op_list = meta_theme_lookup_draw_op_list (info->theme,
+                                                    draw_ops);
+
+          if (op_list == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("No <draw_ops> with the name \"%s\" has been defined"),
+                         draw_ops);
+              return;
+            }
+
+          meta_draw_op_list_ref (op_list);
+          info->op_list = op_list;
+        }
+
+      push_state (info, STATE_BUTTON);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "frame_style");
+    }
+}
+
+static void
+parse_style_set_element (GMarkupParseContext  *context,
+                         const gchar          *element_name,
+                         const gchar         **attribute_names,
+                         const gchar         **attribute_values,
+                         ParseInfo            *info,
+                         GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_FRAME_STYLE_SET);
+
+  if (ELEMENT_IS ("frame"))
+    {
+      const char *focus = NULL;
+      const char *state = NULL;
+      const char *resize = NULL;
+      const char *style = NULL;
+      MetaFrameFocus frame_focus;
+      MetaFrameState frame_state;
+      MetaFrameResize frame_resize;
+      MetaFrameStyle *frame_style;
+
+      if (!locate_attributes (context, element_name, attribute_names, attribute_values,
+                              error,
+                              "!focus", &focus,
+                              "!state", &state,
+                              "resize", &resize,
+                              "!style", &style,
+                              NULL))
+        return;
+
+      frame_focus = meta_frame_focus_from_string (focus);
+      if (frame_focus == META_FRAME_FOCUS_LAST)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("\"%s\" is not a valid value for focus attribute"),
+                     focus);
+          return;
+        }
+
+      frame_state = meta_frame_state_from_string (state);
+      if (frame_state == META_FRAME_STATE_LAST)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("\"%s\" is not a valid value for state attribute"),
+                     focus);
+          return;
+        }
+
+      frame_style = meta_theme_lookup_style (info->theme, style);
+
+      if (frame_style == NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("A style called \"%s\" has not been defined"),
+                     style);
+          return;
+        }
+
+      switch (frame_state)
+        {
+        case META_FRAME_STATE_NORMAL:
+          if (resize == NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         ATTRIBUTE_NOT_FOUND,
+                         "resize", element_name);
+              return;
+            }
+
+
+          frame_resize = meta_frame_resize_from_string (resize);
+          if (frame_resize == META_FRAME_RESIZE_LAST)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("\"%s\" is not a valid value for resize attribute"),
+                         focus);
+              return;
+            }
+
+          break;
+
+        case META_FRAME_STATE_SHADED:
+          if (META_THEME_ALLOWS (info->theme, META_THEME_UNRESIZABLE_SHADED_STYLES))
+            {
+              if (resize == NULL)
+                /* In state="normal" we would complain here. But instead we accept
+                 * not having a resize attribute and default to resize="both", since
+                 * that most closely mimics what we did in v1, and thus people can
+                 * upgrade a theme to v2 without as much hassle.
+                 */
+                frame_resize = META_FRAME_RESIZE_BOTH;
+              else
+                {
+                  frame_resize = meta_frame_resize_from_string (resize);
+                  if (frame_resize == META_FRAME_RESIZE_LAST)
+                    {
+                      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                                 _("\"%s\" is not a valid value for resize attribute"),
+                                 focus);
+                      return;
+                    }
+                }
+            }
+          else /* v1 theme */
+            {
+              if (resize != NULL)
+                {
+                  set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                       _("Should not have \"resize\" attribute on <%s> element for maximized/shaded states"),
+                      element_name);
+                  return;
+                }
+
+              /* resize="both" is equivalent to the old behaviour */
+              frame_resize = META_FRAME_RESIZE_BOTH;
+            }
+          break;
+
+        default:
+          if (resize != NULL)
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("Should not have \"resize\" attribute on <%s> element for maximized states"),
+                         element_name);
+              return;
+            }
+
+          frame_resize = META_FRAME_RESIZE_LAST;
+        }
+
+      switch (frame_state)
+        {
+        case META_FRAME_STATE_NORMAL:
+          if (info->style_set->normal_styles[frame_resize][frame_focus])
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("Style has already been specified for state %s resize %s focus %s"),
+                         state, resize, focus);
+              return;
+            }
+          meta_frame_style_ref (frame_style);
+          info->style_set->normal_styles[frame_resize][frame_focus] = frame_style;
+          break;
+        case META_FRAME_STATE_MAXIMIZED:
+          if (info->style_set->maximized_styles[frame_focus])
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("Style has already been specified for state %s focus %s"),
+                         state, focus);
+              return;
+            }
+          meta_frame_style_ref (frame_style);
+          info->style_set->maximized_styles[frame_focus] = frame_style;
+          break;
+        case META_FRAME_STATE_TILED_LEFT:
+          if (info->style_set->tiled_left_styles[frame_focus])
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("Style has already been specified for state %s focus %s"),
+                         state, focus);
+              return;
+            }
+          meta_frame_style_ref (frame_style);
+          info->style_set->tiled_left_styles[frame_focus] = frame_style;
+          break;
+        case META_FRAME_STATE_TILED_RIGHT:
+          if (info->style_set->tiled_right_styles[frame_focus])
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("Style has already been specified for state %s focus %s"),
+                         state, focus);
+              return;
+            }
+          meta_frame_style_ref (frame_style);
+          info->style_set->tiled_right_styles[frame_focus] = frame_style;
+          break;
+        case META_FRAME_STATE_SHADED:
+          if (info->style_set->shaded_styles[frame_resize][frame_focus])
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("Style has already been specified for state %s resize %s focus %s"),
+                         state, resize, focus);
+              return;
+            }
+          meta_frame_style_ref (frame_style);
+          info->style_set->shaded_styles[frame_resize][frame_focus] = frame_style;
+          break;
+        case META_FRAME_STATE_MAXIMIZED_AND_SHADED:
+          if (info->style_set->maximized_and_shaded_styles[frame_focus])
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("Style has already been specified for state %s focus %s"),
+                         state, focus);
+              return;
+            }
+          meta_frame_style_ref (frame_style);
+          info->style_set->maximized_and_shaded_styles[frame_focus] = frame_style;
+          break;
+        case META_FRAME_STATE_TILED_LEFT_AND_SHADED:
+          if (info->style_set->tiled_left_and_shaded_styles[frame_focus])
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("Style has already been specified for state %s focus %s"),
+                         state, focus);
+              return;
+            }
+          meta_frame_style_ref (frame_style);
+          info->style_set->tiled_left_and_shaded_styles[frame_focus] = frame_style;
+          break;
+        case META_FRAME_STATE_TILED_RIGHT_AND_SHADED:
+          if (info->style_set->tiled_right_and_shaded_styles[frame_focus])
+            {
+              set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                         _("Style has already been specified for state %s focus %s"),
+                         state, focus);
+              return;
+            }
+          meta_frame_style_ref (frame_style);
+          info->style_set->tiled_right_and_shaded_styles[frame_focus] = frame_style;
+          break;
+        case META_FRAME_STATE_LAST:
+          g_assert_not_reached ();
+          break;
+        }
+
+      push_state (info, STATE_FRAME);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "frame_style_set");
+    }
+}
+
+static void
+parse_piece_element (GMarkupParseContext  *context,
+                     const gchar          *element_name,
+                     const gchar         **attribute_names,
+                     const gchar         **attribute_values,
+                     ParseInfo            *info,
+                     GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_PIECE);
+
+  if (ELEMENT_IS ("draw_ops"))
+    {
+      if (info->op_list)
+        {
+          set_error (error, context,
+                     G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Can't have a two draw_ops for a <piece> element (theme specified a draw_ops attribute and also a <draw_ops> element, or specified two elements)"));
+          return;
+        }
+
+      if (!check_no_attributes (context, element_name, attribute_names, attribute_values,
+                                error))
+        return;
+
+      g_assert (info->op_list == NULL);
+      info->op_list = meta_draw_op_list_new (2);
+
+      push_state (info, STATE_DRAW_OPS);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "piece");
+    }
+}
+
+static void
+parse_button_element (GMarkupParseContext  *context,
+                      const gchar          *element_name,
+                      const gchar         **attribute_names,
+                      const gchar         **attribute_values,
+                      ParseInfo            *info,
+                      GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_BUTTON);
+
+  if (ELEMENT_IS ("draw_ops"))
+    {
+      if (info->op_list)
+        {
+          set_error (error, context,
+                     G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Can't have a two draw_ops for a <button> element (theme specified a draw_ops attribute and also a <draw_ops> element, or specified two elements)"));
+          return;
+        }
+
+      if (!check_no_attributes (context, element_name, attribute_names, attribute_values,
+                                error))
+        return;
+
+      g_assert (info->op_list == NULL);
+      info->op_list = meta_draw_op_list_new (2);
+
+      push_state (info, STATE_DRAW_OPS);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "button");
+    }
+}
+
+static void
+parse_menu_icon_element (GMarkupParseContext  *context,
+                         const gchar          *element_name,
+                         const gchar         **attribute_names,
+                         const gchar         **attribute_values,
+                         ParseInfo            *info,
+                         GError              **error)
+{
+  g_return_if_fail (peek_state (info) == STATE_MENU_ICON);
+
+  if (ELEMENT_IS ("draw_ops"))
+    {
+      if (info->op_list)
+        {
+          set_error (error, context,
+                     G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("Can't have a two draw_ops for a <menu_icon> element (theme specified a draw_ops attribute and also a <draw_ops> element, or specified two elements)"));
+          return;
+        }
+
+      if (!check_no_attributes (context, element_name, attribute_names, attribute_values,
+                                error))
+        return;
+
+      g_assert (info->op_list == NULL);
+      info->op_list = meta_draw_op_list_new (2);
+
+      push_state (info, STATE_DRAW_OPS);
+    }
+  else
+    {
+      set_error (error, context,
+                 G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed below <%s>"),
+                 element_name, "menu_icon");
+    }
+}
+
+static const char *
+find_version (const char **attribute_names,
+              const char **attribute_values)
+{
+  int i;
+
+  for (i = 0; attribute_names[i]; i++)
+    {
+      if (strcmp (attribute_names[i], "version") == 0)
+        return attribute_values[i];
+    }
+
+  return NULL;
+}
+
+/* Returns whether the version element was successfully parsed.
+ * If successfully parsed, then two additional items are returned:
+ *
+ *  satisfied:        whether this version of Mutter meets the version check
+ *  minimum_required: minimum version of theme format required by version check
+ */
+static gboolean
+check_version (GMarkupParseContext *context,
+               const char          *version_str,
+               gboolean            *satisfied,
+               guint               *minimum_required,
+               GError             **error)
+{
+  static GRegex *version_regex;
+  GMatchInfo *info;
+  char *comparison_str, *major_str, *minor_str;
+  guint version;
+
+  *minimum_required = 0;
+
+  if (!version_regex)
+    version_regex = g_regex_new ("^\\s*([<>]=?)\\s*(\\d+)(\\.\\d+)?\\s*$", 0, 0, NULL);
+
+  if (!g_regex_match (version_regex, version_str, 0, &info))
+    {
+      g_match_info_free (info);
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Bad version specification '%s'"), version_str);
+      return FALSE;
+    }
+
+  comparison_str = g_match_info_fetch (info, 1);
+  major_str = g_match_info_fetch (info, 2);
+  minor_str = g_match_info_fetch (info, 3);
+
+  version = 1000 * atoi (major_str);
+  /* might get NULL, see: https://bugzilla.gnome.org/review?bug=588217 */
+  if (minor_str && minor_str[0])
+    version += atoi (minor_str + 1);
+
+  if (comparison_str[0] == '<')
+    {
+      if (comparison_str[1] == '=')
+        *satisfied = THEME_VERSION <= version;
+      else
+        {
+          *satisfied = THEME_VERSION < version;
+        }
+    }
+  else
+    {
+      if (comparison_str[1] == '=')
+        {
+          *satisfied = THEME_VERSION >= version;
+          *minimum_required = version;
+        }
+      else
+        {
+          *satisfied = THEME_VERSION > version;
+          *minimum_required = version + 1;
+        }
+    }
+
+  g_free (comparison_str);
+  g_free (major_str);
+  g_free (minor_str);
+  g_match_info_free (info);
+
+  return TRUE;
+}
+
+static void
+start_element_handler (GMarkupParseContext *context,
+                       const gchar         *element_name,
+                       const gchar        **attribute_names,
+                       const gchar        **attribute_values,
+                       gpointer             user_data,
+                       GError             **error)
+{
+  ParseInfo *info = user_data;
+  const char *version;
+  guint required_version = 0;
+
+  if (info->skip_level > 0)
+    {
+      info->skip_level++;
+      return;
+    }
+
+  required_version = peek_required_version (info);
+
+  version = find_version (attribute_names, attribute_values);
+  if (version != NULL)
+    {
+      gboolean satisfied;
+      guint element_required;
+
+      if (required_version < 3000)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("\"version\" attribute cannot be used in metacity-theme-1.xml or metacity-theme-2.xml"));
+          return;
+        }
+
+      if (!check_version (context, version, &satisfied, &element_required, error))
+        return;
+
+      /* Two different ways of handling an unsatisfied version check:
+       * for the toplevel element of a file, we throw an error back so
+       * that the controlling code can go ahead and look for an
+       * alternate metacity-theme-1.xml or metacity-theme-2.xml; for
+       * other elements we just silently skip the element and children.
+       */
+      if (peek_state (info) == STATE_START)
+        {
+          if (satisfied)
+            {
+              if (element_required > info->format_version)
+                info->format_version = element_required;
+            }
+          else
+            {
+              set_error (error, context, THEME_PARSE_ERROR, THEME_PARSE_ERROR_TOO_OLD,
+                         _("Theme requires version %s but latest supported theme version is %d.%d"),
+                         version, THEME_VERSION, THEME_MINOR_VERSION);
+              return;
+            }
+        }
+      else if (!satisfied)
+        {
+          info->skip_level = 1;
+          return;
+        }
+
+      if (element_required > required_version)
+        required_version = element_required;
+    }
+
+  push_required_version (info, required_version);
+
+  switch (peek_state (info))
+    {
+    case STATE_START:
+      if (strcmp (element_name, "metacity_theme") == 0)
+        {
+          info->theme = meta_theme_new ();
+          info->theme->name = g_strdup (info->theme_name);
+          info->theme->filename = g_strdup (info->theme_file);
+          info->theme->dirname = g_strdup (info->theme_dir);
+          info->theme->format_version = info->format_version;
+
+          push_state (info, STATE_THEME);
+        }
+      else
+        set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                   _("Outermost element in theme must be <metacity_theme> not <%s>"),
+                   element_name);
+      break;
+
+    case STATE_THEME:
+      parse_toplevel_element (context, element_name,
+                              attribute_names, attribute_values,
+                              info, error);
+      break;
+    case STATE_INFO:
+      parse_info_element (context, element_name,
+                          attribute_names, attribute_values,
+                          info, error);
+      break;
+    case STATE_NAME:
+    case STATE_AUTHOR:
+    case STATE_COPYRIGHT:
+    case STATE_DATE:
+    case STATE_DESCRIPTION:
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed inside a name/author/date/description element"),
+                 element_name);
+      break;
+    case STATE_CONSTANT:
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed inside a <constant> element"),
+                 element_name);
+      break;
+    case STATE_FRAME_GEOMETRY:
+      parse_geometry_element (context, element_name,
+                              attribute_names, attribute_values,
+                              info, error);
+      break;
+    case STATE_DISTANCE:
+    case STATE_BORDER:
+    case STATE_ASPECT_RATIO:
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed inside a distance/border/aspect_ratio element"),
+                 element_name);
+      break;
+    case STATE_DRAW_OPS:
+      parse_draw_op_element (context, element_name,
+                             attribute_names, attribute_values,
+                             info, error);
+      break;
+    case STATE_LINE:
+    case STATE_RECTANGLE:
+    case STATE_ARC:
+    case STATE_CLIP:
+    case STATE_TINT:
+    case STATE_IMAGE:
+    case STATE_GTK_ARROW:
+    case STATE_GTK_BOX:
+    case STATE_GTK_VLINE:
+    case STATE_ICON:
+    case STATE_TITLE:
+    case STATE_INCLUDE:
+    case STATE_TILE:
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed inside a draw operation element"),
+                 element_name);
+      break;
+    case STATE_GRADIENT:
+      parse_gradient_element (context, element_name,
+                              attribute_names, attribute_values,
+                              info, error);
+      break;
+    case STATE_COLOR:
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed inside a <%s> element"),
+                 element_name, "color");
+      break;
+    case STATE_FRAME_STYLE:
+      parse_style_element (context, element_name,
+                           attribute_names, attribute_values,
+                           info, error);
+      break;
+    case STATE_PIECE:
+      parse_piece_element (context, element_name,
+                           attribute_names, attribute_values,
+                           info, error);
+      break;
+    case STATE_BUTTON:
+      parse_button_element (context, element_name,
+                            attribute_names, attribute_values,
+                            info, error);
+      break;
+    case STATE_MENU_ICON:
+      parse_menu_icon_element (context, element_name,
+                               attribute_names, attribute_values,
+                               info, error);
+      break;
+    case STATE_FRAME_STYLE_SET:
+      parse_style_set_element (context, element_name,
+                               attribute_names, attribute_values,
+                               info, error);
+      break;
+    case STATE_FRAME:
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed inside a <%s> element"),
+                 element_name, "frame");
+      break;
+    case STATE_WINDOW:
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed inside a <%s> element"),
+                 element_name, "window");
+      break;
+    case STATE_FALLBACK:
+      set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                 _("Element <%s> is not allowed inside a <%s> element"),
+                 element_name, "fallback");
+      break;
+    }
+}
+
+static void
+end_element_handler (GMarkupParseContext *context,
+                     const gchar         *element_name,
+                     gpointer             user_data,
+                     GError             **error)
+{
+  ParseInfo *info = user_data;
+
+  if (info->skip_level > 0)
+    {
+      info->skip_level--;
+      return;
+    }
+
+  switch (peek_state (info))
+    {
+    case STATE_START:
+      break;
+    case STATE_THEME:
+      g_assert (info->theme);
+
+      if (!meta_theme_validate (info->theme, error))
+        {
+          add_context_to_error (error, context);
+          meta_theme_free (info->theme);
+          info->theme = NULL;
+        }
+
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_START);
+      break;
+    case STATE_INFO:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_THEME);
+      break;
+    case STATE_NAME:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_INFO);
+      break;
+    case STATE_AUTHOR:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_INFO);
+      break;
+    case STATE_COPYRIGHT:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_INFO);
+      break;
+    case STATE_DATE:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_INFO);
+      break;
+    case STATE_DESCRIPTION:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_INFO);
+      break;
+    case STATE_CONSTANT:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_THEME);
+      break;
+    case STATE_FRAME_GEOMETRY:
+      g_assert (info->layout);
+
+      if (!meta_frame_layout_validate (info->layout,
+                                       error))
+        {
+          add_context_to_error (error, context);
+        }
+
+      /* layout will already be stored in the theme under
+       * its name
+       */
+      meta_frame_layout_unref (info->layout);
+      info->layout = NULL;
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_THEME);
+      break;
+    case STATE_DISTANCE:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_FRAME_GEOMETRY);
+      break;
+    case STATE_BORDER:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_FRAME_GEOMETRY);
+      break;
+    case STATE_ASPECT_RATIO:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_FRAME_GEOMETRY);
+      break;
+    case STATE_DRAW_OPS:
+      {
+        g_assert (info->op_list);
+
+        if (!meta_draw_op_list_validate (info->op_list,
+                                         error))
+          {
+            add_context_to_error (error, context);
+            meta_draw_op_list_unref (info->op_list);
+            info->op_list = NULL;
+          }
+
+        pop_state (info);
+
+        switch (peek_state (info))
+          {
+          case STATE_BUTTON:
+          case STATE_PIECE:
+          case STATE_MENU_ICON:
+            /* Leave info->op_list to be picked up
+             * when these elements are closed
+             */
+            g_assert (info->op_list);
+            break;
+          case STATE_THEME:
+            g_assert (info->op_list);
+            meta_draw_op_list_unref (info->op_list);
+            info->op_list = NULL;
+            break;
+          default:
+            /* Op list can't occur in other contexts */
+            g_assert_not_reached ();
+            break;
+          }
+      }
+      break;
+    case STATE_LINE:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_RECTANGLE:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_ARC:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_CLIP:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_TINT:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_GRADIENT:
+      g_assert (info->op);
+      g_assert (info->op->type == META_DRAW_GRADIENT);
+      if (!meta_gradient_spec_validate (info->op->data.gradient.gradient_spec,
+                                        error))
+        {
+          add_context_to_error (error, context);
+          meta_draw_op_free (info->op);
+          info->op = NULL;
+        }
+      else
+        {
+          g_assert (info->op_list);
+          meta_draw_op_list_append (info->op_list, info->op);
+          info->op = NULL;
+        }
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_IMAGE:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_GTK_ARROW:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_GTK_BOX:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_GTK_VLINE:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_ICON:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_TITLE:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_INCLUDE:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_TILE:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_DRAW_OPS);
+      break;
+    case STATE_COLOR:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_GRADIENT);
+      break;
+    case STATE_FRAME_STYLE:
+      g_assert (info->style);
+
+      if (!meta_frame_style_validate (info->style,
+                                      peek_required_version (info),
+                                      error))
+        {
+          add_context_to_error (error, context);
+        }
+
+      /* Frame style is in the theme hash table and a ref
+       * is held there
+       */
+      meta_frame_style_unref (info->style);
+      info->style = NULL;
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_THEME);
+      break;
+    case STATE_PIECE:
+      g_assert (info->style);
+      if (info->op_list == NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("No draw_ops provided for frame piece"));
+        }
+      else
+        {
+          info->style->pieces[info->piece] = info->op_list;
+          info->op_list = NULL;
+        }
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_FRAME_STYLE);
+      break;
+    case STATE_BUTTON:
+      g_assert (info->style);
+      if (info->op_list == NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE,
+                     _("No draw_ops provided for button"));
+        }
+      else
+        {
+          info->style->buttons[info->button_type][info->button_state] =
+            info->op_list;
+          info->op_list = NULL;
+        }
+      pop_state (info);
+      break;
+    case STATE_MENU_ICON:
+      g_assert (info->theme);
+      if (info->op_list != NULL)
+        {
+          meta_draw_op_list_unref (info->op_list);
+          info->op_list = NULL;
+        }
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_THEME);
+      break;
+    case STATE_FRAME_STYLE_SET:
+      g_assert (info->style_set);
+
+      if (!meta_frame_style_set_validate (info->style_set,
+                                          error))
+        {
+          add_context_to_error (error, context);
+        }
+
+      /* Style set is in the theme hash table and a reference
+       * is held there.
+       */
+      meta_frame_style_set_unref (info->style_set);
+      info->style_set = NULL;
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_THEME);
+      break;
+    case STATE_FRAME:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_FRAME_STYLE_SET);
+      break;
+    case STATE_WINDOW:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_THEME);
+      break;
+    case STATE_FALLBACK:
+      pop_state (info);
+      g_assert (peek_state (info) == STATE_THEME);
+      break;
+    }
+
+  pop_required_version (info);
+}
+
+#define NO_TEXT(element_name) set_error (error, context, G_MARKUP_ERROR, G_MARKUP_ERROR_PARSE, _("No text is allowed inside element <%s>"), element_name)
+
+static gboolean
+all_whitespace (const char *text,
+                int         text_len)
+{
+  const char *p;
+  const char *end;
+
+  p = text;
+  end = text + text_len;
+
+  while (p != end)
+    {
+      if (!g_ascii_isspace (*p))
+        return FALSE;
+
+      p = g_utf8_next_char (p);
+    }
+
+  return TRUE;
+}
+
+static void
+text_handler (GMarkupParseContext *context,
+              const gchar         *text,
+              gsize                text_len,
+              gpointer             user_data,
+              GError             **error)
+{
+  ParseInfo *info = user_data;
+
+  if (info->skip_level > 0)
+    return;
+
+  if (all_whitespace (text, text_len))
+    return;
+
+  /* FIXME http://bugzilla.gnome.org/show_bug.cgi?id=70448 would
+   * allow a nice cleanup here.
+   */
+
+  switch (peek_state (info))
+    {
+    case STATE_START:
+      g_assert_not_reached (); /* gmarkup shouldn't do this */
+      break;
+    case STATE_THEME:
+      NO_TEXT ("metacity_theme");
+      break;
+    case STATE_INFO:
+      NO_TEXT ("info");
+      break;
+    case STATE_NAME:
+      if (info->theme->readable_name != NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("<%s> specified twice for this theme"),
+                     "name");
+          return;
+        }
+
+      info->theme->readable_name = g_strndup (text, text_len);
+      break;
+    case STATE_AUTHOR:
+      if (info->theme->author != NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("<%s> specified twice for this theme"),
+                     "author");
+          return;
+        }
+
+      info->theme->author = g_strndup (text, text_len);
+      break;
+    case STATE_COPYRIGHT:
+      if (info->theme->copyright != NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("<%s> specified twice for this theme"),
+                     "copyright");
+          return;
+        }
+
+      info->theme->copyright = g_strndup (text, text_len);
+      break;
+    case STATE_DATE:
+      if (info->theme->date != NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("<%s> specified twice for this theme"),
+                     "date");
+          return;
+        }
+
+      info->theme->date = g_strndup (text, text_len);
+      break;
+    case STATE_DESCRIPTION:
+      if (info->theme->description != NULL)
+        {
+          set_error (error, context, G_MARKUP_ERROR,
+                     G_MARKUP_ERROR_PARSE,
+                     _("<%s> specified twice for this theme"),
+                     "description");
+          return;
+        }
+
+      info->theme->description = g_strndup (text, text_len);
+      break;
+    case STATE_CONSTANT:
+      NO_TEXT ("constant");
+      break;
+    case STATE_FRAME_GEOMETRY:
+      NO_TEXT ("frame_geometry");
+      break;
+    case STATE_DISTANCE:
+      NO_TEXT ("distance");
+      break;
+    case STATE_BORDER:
+      NO_TEXT ("border");
+      break;
+    case STATE_ASPECT_RATIO:
+      NO_TEXT ("aspect_ratio");
+      break;
+    case STATE_DRAW_OPS:
+      NO_TEXT ("draw_ops");
+      break;
+    case STATE_LINE:
+      NO_TEXT ("line");
+      break;
+    case STATE_RECTANGLE:
+      NO_TEXT ("rectangle");
+      break;
+    case STATE_ARC:
+      NO_TEXT ("arc");
+      break;
+    case STATE_CLIP:
+      NO_TEXT ("clip");
+      break;
+    case STATE_TINT:
+      NO_TEXT ("tint");
+      break;
+    case STATE_GRADIENT:
+      NO_TEXT ("gradient");
+      break;
+    case STATE_IMAGE:
+      NO_TEXT ("image");
+      break;
+    case STATE_GTK_ARROW:
+      NO_TEXT ("gtk_arrow");
+      break;
+    case STATE_GTK_BOX:
+      NO_TEXT ("gtk_box");
+      break;
+    case STATE_GTK_VLINE:
+      NO_TEXT ("gtk_vline");
+      break;
+    case STATE_ICON:
+      NO_TEXT ("icon");
+      break;
+    case STATE_TITLE:
+      NO_TEXT ("title");
+      break;
+    case STATE_INCLUDE:
+      NO_TEXT ("include");
+      break;
+    case STATE_TILE:
+      NO_TEXT ("tile");
+      break;
+    case STATE_COLOR:
+      NO_TEXT ("color");
+      break;
+    case STATE_FRAME_STYLE:
+      NO_TEXT ("frame_style");
+      break;
+    case STATE_PIECE:
+      NO_TEXT ("piece");
+      break;
+    case STATE_BUTTON:
+      NO_TEXT ("button");
+      break;
+    case STATE_MENU_ICON:
+      NO_TEXT ("menu_icon");
+      break;
+    case STATE_FRAME_STYLE_SET:
+      NO_TEXT ("frame_style_set");
+      break;
+    case STATE_FRAME:
+      NO_TEXT ("frame");
+      break;
+    case STATE_WINDOW:
+      NO_TEXT ("window");
+      break;
+    case STATE_FALLBACK:
+      NO_TEXT ("fallback");
+      break;
+    }
+}
+
+/* If the theme is not-corrupt, keep looking for alternate versions
+ * in other locations we might be compatible with
+ */
+static gboolean
+theme_error_is_fatal (GError *error)
+{
+  return !(error->domain == G_FILE_ERROR ||
+          (error->domain == THEME_PARSE_ERROR &&
+           error->code == THEME_PARSE_ERROR_TOO_OLD));
+}
+
+static MetaTheme *
+load_theme (const char *theme_dir,
+            const char *theme_name,
+            guint       major_version,
+            GError    **error)
+{
+  GMarkupParseContext *context;
+  ParseInfo info;
+  char *text;
+  gsize length;
+  char *theme_filename;
+  char *theme_file;
+  MetaTheme *retval;
+
+  g_return_val_if_fail (error && *error == NULL, NULL);
+
+  text = NULL;
+  retval = NULL;
+  context = NULL;
+
+  theme_filename = g_strdup_printf (METACITY_THEME_FILENAME_FORMAT, major_version);
+  theme_file = g_build_filename (theme_dir, theme_filename, NULL);
+
+  if (!g_file_get_contents (theme_file,
+                            &text,
+                            &length,
+                            error))
+    goto out;
+
+  meta_topic (META_DEBUG_THEMES, "Parsing theme file %s\n", theme_file);
+
+  parse_info_init (&info);
+
+  info.theme_name = theme_name;
+  info.theme_file = theme_file;
+  info.theme_dir = theme_dir;
+
+  info.format_version = 1000 * major_version;
+
+  context = g_markup_parse_context_new (&metacity_theme_parser,
+                                        0, &info, NULL);
+
+  if (!g_markup_parse_context_parse (context,
+                                     text,
+                                     length,
+                                     error))
+    goto out;
+
+  if (!g_markup_parse_context_end_parse (context, error))
+    goto out;
+
+  retval = info.theme;
+  info.theme = NULL;
+
+ out:
+  if (*error && !theme_error_is_fatal (*error))
+    {
+      meta_topic (META_DEBUG_THEMES, "Failed to read theme from file %s: %s\n",
+                  theme_file, (*error)->message);
+    }
+
+  g_free (theme_filename);
+  g_free (theme_file);
+  g_free (text);
+
+  if (context)
+    {
+      g_markup_parse_context_free (context);
+      parse_info_free (&info);
+    }
+
+  return retval;
+}
+
+static gboolean
+keep_trying (GError **error)
+{
+  if (*error && !theme_error_is_fatal (*error))
+    {
+      g_clear_error (error);
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+/**
+ * meta_theme_load: (skip)
+ * @theme_name:
+ * @err:
+ *
+ */
+MetaTheme*
+meta_theme_load (const char *theme_name,
+                 GError    **err)
+{
+  GError *error = NULL;
+  char *theme_dir;
+  MetaTheme *retval;
+  const gchar* const* xdg_data_dirs;
+  int major_version;
+  int i;
+
+  retval = NULL;
+
+  /* We try all supported major versions from current to oldest */
+  for (major_version = THEME_MAJOR_VERSION; (major_version > 0); major_version--)
+    {
+      /* We try first in XDG_USER_DATA_DIR, XDG_DATA_DIRS, then system dir for themes */
+
+      /* Try XDG_USER_DATA_DIR first */
+      theme_dir = g_build_filename (g_get_user_data_dir(),
+                                    "themes",
+                                    theme_name,
+                                    THEME_SUBDIR,
+                                    NULL);
+
+      retval = load_theme (theme_dir, theme_name, major_version, &error);
+      g_free (theme_dir);
+      if (!keep_trying (&error))
+        goto out;
+
+      /* Try each XDG_DATA_DIRS for theme */
+      xdg_data_dirs = g_get_system_data_dirs();
+      for(i = 0; xdg_data_dirs[i] != NULL; i++)
+        {
+          theme_dir = g_build_filename (xdg_data_dirs[i],
+                                        "themes",
+                                        theme_name,
+                                        THEME_SUBDIR,
+                                        NULL);
+
+          retval = load_theme (theme_dir, theme_name, major_version, &error);
+          g_free (theme_dir);
+          if (!keep_trying (&error))
+            goto out;
+        }
+
+      /* Look for themes in MUTTER_DATADIR */
+      theme_dir = g_build_filename (MUTTER_DATADIR,
+                                    "themes",
+                                    theme_name,
+                                    THEME_SUBDIR,
+                                    NULL);
+
+      retval = load_theme (theme_dir, theme_name, major_version, &error);
+      g_free (theme_dir);
+      if (!keep_trying (&error))
+        goto out;
+    }
+
+ out:
+  if (!error && !retval)
+    g_set_error (&error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                 _("Failed to find a valid file for theme %s\n"),
+                 theme_name);
+
+  if (error)
+    {
+      g_propagate_error (err, error);
+    }
+
+  return retval;
+}
diff '--exclude=.git' -urN a/src/ui/theme-private.h b/src/ui/theme-private.h
--- a/src/ui/theme-private.h	2015-10-30 16:39:40.975006658 -0400
+++ b/src/ui/theme-private.h	2015-10-31 13:33:56.677252031 -0400
@@ -23,6 +23,7 @@
 #define META_THEME_PRIVATE_H
 
 #include <meta/boxes.h>
+#include <meta/gradient.h>
 #include <meta/theme.h>
 #include <meta/common.h>
 #include <gtk/gtk.h>
@@ -33,6 +34,41 @@
  */
 typedef struct _MetaStyleInfo MetaStyleInfo;
 /**
+ * MetaFrameStyle: (skip)
+ *
+ */
+typedef struct _MetaFrameStyle MetaFrameStyle;
+/**
+ * MetaFrameStyleSet: (skip)
+ *
+ */
+typedef struct _MetaFrameStyleSet MetaFrameStyleSet;
+/**
+ * MetaDrawOp: (skip)
+ *
+ */
+typedef struct _MetaDrawOp MetaDrawOp;
+/**
+ * MetaDrawOpList: (skip)
+ *
+ */
+typedef struct _MetaDrawOpList MetaDrawOpList;
+/**
+ * MetaGradientSpec: (skip)
+ *
+ */
+typedef struct _MetaGradientSpec MetaGradientSpec;
+/**
+ * MetaAlphaGradientSpec: (skip)
+ *
+ */
+typedef struct _MetaAlphaGradientSpec MetaAlphaGradientSpec;
+/**
+ * MetaColorSpec: (skip)
+ *
+ */
+typedef struct _MetaColorSpec MetaColorSpec;
+/**
  * MetaFrameLayout: (skip)
  *
  */
@@ -49,15 +85,101 @@
 typedef struct _MetaFrameGeometry MetaFrameGeometry;
 
 /**
+ * MetaPositionExprEnv: (skip)
+ *
+ */
+typedef struct _MetaPositionExprEnv MetaPositionExprEnv;
+/**
+ * MetaDrawInfo: (skip)
+ *
+ */
+typedef struct _MetaDrawInfo MetaDrawInfo;
+
+#define META_THEME_ERROR (g_quark_from_static_string ("meta-theme-error"))
+
+typedef enum
+{
+  META_THEME_ERROR_FRAME_GEOMETRY,
+  META_THEME_ERROR_BAD_CHARACTER,
+  META_THEME_ERROR_BAD_PARENS,
+  META_THEME_ERROR_UNKNOWN_VARIABLE,
+  META_THEME_ERROR_DIVIDE_BY_ZERO,
+  META_THEME_ERROR_MOD_ON_FLOAT,
+  META_THEME_ERROR_FAILED
+} MetaThemeError;
+
+/**
+ * Whether a button's size is calculated from the area around it (aspect
+ * sizing) or is given as a fixed height and width in pixels (fixed sizing).
+ *
+ * \bug This could be done away with; see the comment at the top of
+ * MetaFrameLayout.
+ */
+typedef enum
+{
+  META_BUTTON_SIZING_ASPECT,
+  META_BUTTON_SIZING_FIXED,
+  META_BUTTON_SIZING_LAST
+} MetaButtonSizing;
+
+/**
  * Various parameters used to calculate the geometry of a frame.
+ * They are used inside a MetaFrameStyle.
+ * This corresponds closely to the <frame_geometry> tag in a theme file.
+ *
+ * \bug button_sizing isn't really necessary, because we could easily say
+ * that if button_aspect is zero, the height and width are fixed values.
+ * This would also mean that MetaButtonSizing didn't need to exist, and
+ * save code.
  **/
 struct _MetaFrameLayout
 {
-  /** Border/padding of the entire frame */
-  GtkBorder frame_border;
-  /** Border/padding of the titlebar region */
-  GtkBorder titlebar_border;
-  /** Border/padding of titlebar buttons */
+  /** Reference count. */
+  int refcount;
+
+  /** Size of left side */
+  int left_width;
+  /** Size of right side */
+  int right_width;
+  /** Size of bottom side */
+  int bottom_height;
+
+  /** Border of blue title region
+   * \bug (blue?!)
+   **/
+  GtkBorder title_border;
+
+  /** Extra height for inside of title region, above the font height */
+  int title_vertical_pad;
+
+  /** Right indent of buttons from edges of frame */
+  int right_titlebar_edge;
+  /** Left indent of buttons from edges of frame */
+  int left_titlebar_edge;
+
+  /**
+   * Sizing rule of buttons, either META_BUTTON_SIZING_ASPECT
+   * (in which case button_aspect will be honoured, and
+   * button_width and button_height set from it), or
+   * META_BUTTON_SIZING_FIXED (in which case we read the width
+   * and height directly).
+   */
+  MetaButtonSizing button_sizing;
+
+  /**
+   * Ratio of height/width. Honoured only if
+   * button_sizing==META_BUTTON_SIZING_ASPECT.
+   * Otherwise we figure out the height from the button_border.
+   */
+  double button_aspect;
+
+  /** Width of a button; set even when we are using aspect sizing */
+  int button_width;
+
+  /** Height of a button; set even when we are using aspect sizing */
+  int button_height;
+
+  /** Space around buttons */
   GtkBorder button_border;
 
   /** Size of images in buttons */
@@ -111,11 +233,14 @@
 
   GdkRectangle title_rect;
 
-  GtkBorder content_border;
+  int left_titlebar_edge;
+  int right_titlebar_edge;
+  int top_titlebar_edge;
+  int bottom_titlebar_edge;
 
   /* used for a memset hack */
 #define ADDRESS_OF_BUTTON_RECTS(fgeom) (((char*)(fgeom)) + G_STRUCT_OFFSET (MetaFrameGeometry, close_rect))
-#define LENGTH_OF_BUTTON_RECTS (G_STRUCT_OFFSET (MetaFrameGeometry, unstick_rect) + sizeof (MetaButtonSpace) - G_STRUCT_OFFSET (MetaFrameGeometry, close_rect))
+#define LENGTH_OF_BUTTON_RECTS (G_STRUCT_OFFSET (MetaFrameGeometry, right_single_background) + sizeof (GdkRectangle) - G_STRUCT_OFFSET (MetaFrameGeometry, close_rect))
 
   /* The button rects (if changed adjust memset hack) */
   MetaButtonSpace close_rect;
@@ -129,6 +254,16 @@
   MetaButtonSpace unshade_rect;
   MetaButtonSpace unabove_rect;
   MetaButtonSpace unstick_rect;
+
+#define MAX_MIDDLE_BACKGROUNDS (MAX_BUTTONS_PER_CORNER - 2)
+  GdkRectangle left_left_background;
+  GdkRectangle left_middle_backgrounds[MAX_MIDDLE_BACKGROUNDS];
+  GdkRectangle left_right_background;
+  GdkRectangle left_single_background;
+  GdkRectangle right_left_background;
+  GdkRectangle right_middle_backgrounds[MAX_MIDDLE_BACKGROUNDS];
+  GdkRectangle right_right_background;
+  GdkRectangle right_single_background;
   /* End of button rects (if changed adjust memset hack) */
 
   /* Saved button layout */
@@ -145,6 +280,375 @@
 
 typedef enum
 {
+  META_IMAGE_FILL_SCALE, /* default, needs to be all-bits-zero for g_new0 */
+  META_IMAGE_FILL_TILE
+} MetaImageFillType;
+
+typedef enum
+{
+  META_COLOR_SPEC_BASIC,
+  META_COLOR_SPEC_GTK,
+  META_COLOR_SPEC_GTK_CUSTOM,
+  META_COLOR_SPEC_BLEND,
+  META_COLOR_SPEC_SHADE
+} MetaColorSpecType;
+
+typedef enum
+{
+  META_GTK_COLOR_FG,
+  META_GTK_COLOR_BG,
+  META_GTK_COLOR_LIGHT,
+  META_GTK_COLOR_DARK,
+  META_GTK_COLOR_MID,
+  META_GTK_COLOR_TEXT,
+  META_GTK_COLOR_BASE,
+  META_GTK_COLOR_TEXT_AA,
+  META_GTK_COLOR_LAST
+} MetaGtkColorComponent;
+
+struct _MetaColorSpec
+{
+  MetaColorSpecType type;
+  union
+  {
+    struct {
+      GdkRGBA color;
+    } basic;
+    struct {
+      MetaGtkColorComponent component;
+      GtkStateFlags state;
+    } gtk;
+    struct {
+      char *color_name;
+      MetaColorSpec *fallback;
+    } gtkcustom;
+    struct {
+      MetaColorSpec *foreground;
+      MetaColorSpec *background;
+      double alpha;
+
+      GdkRGBA color;
+    } blend;
+    struct {
+      MetaColorSpec *base;
+      double factor;
+
+      GdkRGBA color;
+    } shade;
+  } data;
+};
+
+struct _MetaGradientSpec
+{
+  MetaGradientType type;
+  GSList *color_specs;
+};
+
+struct _MetaAlphaGradientSpec
+{
+  MetaGradientType type;
+  unsigned char *alphas;
+  int n_alphas;
+};
+
+struct _MetaDrawInfo
+{
+  GdkPixbuf   *mini_icon;
+  GdkPixbuf   *icon;
+  PangoLayout *title_layout;
+  int title_layout_width;
+  int title_layout_height;
+  const MetaFrameGeometry *fgeom;
+};
+
+/**
+ * A drawing operation in our simple vector drawing language.
+ */
+typedef enum
+{
+  /** Basic drawing-- line */
+  META_DRAW_LINE,
+  /** Basic drawing-- rectangle */
+  META_DRAW_RECTANGLE,
+  /** Basic drawing-- arc */
+  META_DRAW_ARC,
+
+  /** Clip to a rectangle */
+  META_DRAW_CLIP,
+
+  /* Texture thingies */
+
+  /** Just a filled rectangle with alpha */
+  META_DRAW_TINT,
+  META_DRAW_GRADIENT,
+  META_DRAW_IMAGE,
+
+  /** GTK theme engine stuff */
+  META_DRAW_GTK_ARROW,
+  META_DRAW_GTK_BOX,
+  META_DRAW_GTK_VLINE,
+
+  /** App's window icon */
+  META_DRAW_ICON,
+  /** App's window title */
+  META_DRAW_TITLE,
+  /** a draw op list */
+  META_DRAW_OP_LIST,
+  /** tiled draw op list */
+  META_DRAW_TILE
+} MetaDrawType;
+
+typedef enum
+{
+  POS_TOKEN_INT,
+  POS_TOKEN_DOUBLE,
+  POS_TOKEN_OPERATOR,
+  POS_TOKEN_VARIABLE,
+  POS_TOKEN_OPEN_PAREN,
+  POS_TOKEN_CLOSE_PAREN
+} PosTokenType;
+
+typedef enum
+{
+  POS_OP_NONE,
+  POS_OP_ADD,
+  POS_OP_SUBTRACT,
+  POS_OP_MULTIPLY,
+  POS_OP_DIVIDE,
+  POS_OP_MOD,
+  POS_OP_MAX,
+  POS_OP_MIN
+} PosOperatorType;
+
+/**
+ * A token, as output by the tokeniser.
+ *
+ * \ingroup tokenizer
+ */
+typedef struct
+{
+  PosTokenType type;
+
+  union
+  {
+    struct {
+      int val;
+    } i;
+
+    struct {
+      double val;
+    } d;
+
+    struct {
+      PosOperatorType op;
+    } o;
+
+    struct {
+      char *name;
+      GQuark name_quark;
+    } v;
+
+  } d;
+} PosToken;
+
+/**
+ * MetaDrawSpec: (skip)
+ *
+ * A computed expression in our simple vector drawing language.
+ * While it appears to take the form of a tree, this is actually
+ * merely a list; concerns such as precedence of operators are
+ * currently recomputed on every recalculation.
+ *
+ * Created by meta_draw_spec_new(), destroyed by meta_draw_spec_free().
+ * pos_eval() fills this with ...FIXME. Are tokens a tree or a list?
+ * \ingroup parser
+ */
+typedef struct _MetaDrawSpec MetaDrawSpec;
+struct _MetaDrawSpec
+{
+  /**
+   * If this spec is constant, this is the value of the constant;
+   * otherwise it is zero.
+   */
+  int value;
+
+  /** A list of tokens in the expression. */
+  PosToken *tokens;
+
+  /** How many tokens are in the tokens list. */
+  int n_tokens;
+
+  /** Does the expression contain any variables? */
+  gboolean constant : 1;
+};
+
+/**
+ * A single drawing operation in our simple vector drawing language.
+ */
+struct _MetaDrawOp
+{
+  MetaDrawType type;
+
+  /* Positions are strings because they can be expressions */
+  union
+  {
+    struct {
+      MetaColorSpec *color_spec;
+      int dash_on_length;
+      int dash_off_length;
+      int width;
+      MetaDrawSpec *x1;
+      MetaDrawSpec *y1;
+      MetaDrawSpec *x2;
+      MetaDrawSpec *y2;
+    } line;
+
+    struct {
+      MetaColorSpec *color_spec;
+      gboolean filled;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+    } rectangle;
+
+    struct {
+      MetaColorSpec *color_spec;
+      gboolean filled;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+      double start_angle;
+      double extent_angle;
+    } arc;
+
+    struct {
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+    } clip;
+
+    struct {
+      MetaColorSpec *color_spec;
+      MetaAlphaGradientSpec *alpha_spec;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+    } tint;
+
+    struct {
+      MetaGradientSpec *gradient_spec;
+      MetaAlphaGradientSpec *alpha_spec;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+    } gradient;
+
+    struct {
+      MetaColorSpec *colorize_spec;
+      MetaAlphaGradientSpec *alpha_spec;
+      GdkPixbuf *pixbuf;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+
+      guint32 colorize_cache_pixel;
+      GdkPixbuf *colorize_cache_pixbuf;
+      MetaImageFillType fill_type;
+      unsigned int vertical_stripes : 1;
+      unsigned int horizontal_stripes : 1;
+    } image;
+
+    struct {
+      GtkStateFlags state;
+      GtkShadowType shadow;
+      GtkArrowType arrow;
+      gboolean filled;
+
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+    } gtk_arrow;
+
+    struct {
+      GtkStateFlags state;
+      GtkShadowType shadow;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+    } gtk_box;
+
+    struct {
+      GtkStateFlags state;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y1;
+      MetaDrawSpec *y2;
+    } gtk_vline;
+
+    struct {
+      MetaAlphaGradientSpec *alpha_spec;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+      MetaImageFillType fill_type;
+    } icon;
+
+    struct {
+      MetaColorSpec *color_spec;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *ellipsize_width;
+    } title;
+
+    struct {
+      MetaDrawOpList *op_list;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+    } op_list;
+
+    struct {
+      MetaDrawOpList *op_list;
+      MetaDrawSpec *x;
+      MetaDrawSpec *y;
+      MetaDrawSpec *width;
+      MetaDrawSpec *height;
+      MetaDrawSpec *tile_xoffset;
+      MetaDrawSpec *tile_yoffset;
+      MetaDrawSpec *tile_width;
+      MetaDrawSpec *tile_height;
+    } tile;
+
+  } data;
+};
+
+/**
+ * A list of MetaDrawOp objects. Maintains a reference count.
+ * Grows as necessary and allows the allocation of unused spaces
+ * to keep reallocations to a minimum.
+ *
+ * \bug Do we really win anything from not using the equivalent
+ * GLib structures?
+ */
+struct _MetaDrawOpList
+{
+  int refcount;
+  MetaDrawOp **ops;
+  int n_ops;
+  int n_allocated;
+};
+
+typedef enum
+{
   META_BUTTON_STATE_NORMAL,
   META_BUTTON_STATE_PRESSED,
   META_BUTTON_STATE_PRELIGHT,
@@ -153,6 +657,15 @@
 
 typedef enum
 {
+  /* Ordered so that background is drawn first */
+  META_BUTTON_TYPE_LEFT_LEFT_BACKGROUND,
+  META_BUTTON_TYPE_LEFT_MIDDLE_BACKGROUND,
+  META_BUTTON_TYPE_LEFT_RIGHT_BACKGROUND,
+  META_BUTTON_TYPE_LEFT_SINGLE_BACKGROUND,
+  META_BUTTON_TYPE_RIGHT_LEFT_BACKGROUND,
+  META_BUTTON_TYPE_RIGHT_MIDDLE_BACKGROUND,
+  META_BUTTON_TYPE_RIGHT_RIGHT_BACKGROUND,
+  META_BUTTON_TYPE_RIGHT_SINGLE_BACKGROUND,
   META_BUTTON_TYPE_CLOSE,
   META_BUTTON_TYPE_MAXIMIZE,
   META_BUTTON_TYPE_MINIMIZE,
@@ -184,16 +697,97 @@
   GtkStyleContext *styles[META_STYLE_ELEMENT_LAST];
 };
 
+typedef enum
+{
+  /* Listed in the order in which the textures are drawn.
+   * (though this only matters for overlaps of course.)
+   * Buttons are drawn after the frame textures.
+   *
+   * On the corners, horizontal pieces are arbitrarily given the
+   * corner area:
+   *
+   *   =====                 |====
+   *   |                     |
+   *   |       rather than   |
+   *
+   */
+
+  /* entire frame */
+  META_FRAME_PIECE_ENTIRE_BACKGROUND,
+  /* entire titlebar background */
+  META_FRAME_PIECE_TITLEBAR,
+  /* portion of the titlebar background inside the titlebar
+   * background edges
+   */
+  META_FRAME_PIECE_TITLEBAR_MIDDLE,
+  /* left end of titlebar */
+  META_FRAME_PIECE_LEFT_TITLEBAR_EDGE,
+  /* right end of titlebar */
+  META_FRAME_PIECE_RIGHT_TITLEBAR_EDGE,
+  /* top edge of titlebar */
+  META_FRAME_PIECE_TOP_TITLEBAR_EDGE,
+  /* bottom edge of titlebar */
+  META_FRAME_PIECE_BOTTOM_TITLEBAR_EDGE,
+  /* render over title background (text area) */
+  META_FRAME_PIECE_TITLE,
+  /* left edge of the frame */
+  META_FRAME_PIECE_LEFT_EDGE,
+  /* right edge of the frame */
+  META_FRAME_PIECE_RIGHT_EDGE,
+  /* bottom edge of the frame */
+  META_FRAME_PIECE_BOTTOM_EDGE,
+  /* place over entire frame, after drawing everything else */
+  META_FRAME_PIECE_OVERLAY,
+  /* Used to get size of the enum */
+  META_FRAME_PIECE_LAST
+} MetaFramePiece;
+
+/**
+ * How to draw a frame in a particular state (say, a focussed, non-maximised,
+ * resizable frame). This corresponds closely to the <frame_style> tag
+ * in a theme file.
+ */
+struct _MetaFrameStyle
+{
+  /** Reference count. */
+  int refcount;
+  /**
+   * Parent style.
+   * Settings which are unspecified here will be taken from there.
+   */
+  MetaFrameStyle *parent;
+  /** Operations for drawing each kind of button in each state. */
+  MetaDrawOpList *buttons[META_BUTTON_TYPE_LAST][META_BUTTON_STATE_LAST];
+  /** Operations for drawing each piece of the frame. */
+  MetaDrawOpList *pieces[META_FRAME_PIECE_LAST];
+  /**
+   * Details such as the height and width of each edge, the corner rounding,
+   * and the aspect ratio of the buttons.
+   */
+  MetaFrameLayout *layout;
+  /**
+   * Background colour of the window. Only present in theme formats
+   * 2 and above. Can be NULL to use the standard GTK theme engine.
+   */
+  MetaColorSpec *window_background_color;
+  /**
+   * Transparency of the window background. 0=transparent; 255=opaque.
+   */
+  guint8 window_background_alpha;
+};
+
 /* Kinds of frame...
  *
- *  normal ->   focused / unfocused
+ *  normal ->   noresize / vert only / horz only / both
+ *              focused / unfocused
  *  max    ->   focused / unfocused
  *  shaded ->   focused / unfocused
  *  max/shaded -> focused / unfocused
  *
- *  so 4 states with 2 sub-states each, meaning 8 total
+ *  so 4 states with 8 sub-states in one, 2 sub-states in the other 3,
+ *  meaning 14 total
  *
- * 8 window states times 7 or 8 window types. Except some
+ * 14 window states times 7 or 8 window types. Except some
  * window types never get a frame so that narrows it down a bit.
  *
  */
@@ -212,25 +806,238 @@
 
 typedef enum
 {
+  META_FRAME_RESIZE_NONE,
+  META_FRAME_RESIZE_VERTICAL,
+  META_FRAME_RESIZE_HORIZONTAL,
+  META_FRAME_RESIZE_BOTH,
+  META_FRAME_RESIZE_LAST
+} MetaFrameResize;
+
+typedef enum
+{
   META_FRAME_FOCUS_NO,
   META_FRAME_FOCUS_YES,
   META_FRAME_FOCUS_LAST
 } MetaFrameFocus;
 
 /**
+ * How to draw frames at different times: when it's maximised or not, shaded
+ * or not, when it's focussed or not, and (for non-maximised windows), when
+ * it can be horizontally or vertically resized, both, or neither.
+ * Not all window types actually get a frame.
+ *
+ * A theme contains one of these objects for each type of window (each
+ * MetaFrameType), that is, normal, dialogue (modal and non-modal), etc.
+ *
+ * This corresponds closely to the <frame_style_set> tag in a theme file.
+ */
+struct _MetaFrameStyleSet
+{
+  int refcount;
+  MetaFrameStyleSet *parent;
+  MetaFrameStyle *normal_styles[META_FRAME_RESIZE_LAST][META_FRAME_FOCUS_LAST];
+  MetaFrameStyle *maximized_styles[META_FRAME_FOCUS_LAST];
+  MetaFrameStyle *tiled_left_styles[META_FRAME_FOCUS_LAST];
+  MetaFrameStyle *tiled_right_styles[META_FRAME_FOCUS_LAST];
+  MetaFrameStyle *shaded_styles[META_FRAME_RESIZE_LAST][META_FRAME_FOCUS_LAST];
+  MetaFrameStyle *maximized_and_shaded_styles[META_FRAME_FOCUS_LAST];
+  MetaFrameStyle *tiled_left_and_shaded_styles[META_FRAME_FOCUS_LAST];
+  MetaFrameStyle *tiled_right_and_shaded_styles[META_FRAME_FOCUS_LAST];
+};
+
+/**
  * A theme. This is a singleton class which groups all settings from a theme
- * together.
+ * on disk together.
+ *
+ * \bug It is rather useless to keep the metadata fields in core, I think.
  */
 struct _MetaTheme
 {
-  MetaFrameLayout *layouts[META_FRAME_TYPE_LAST];
+  /** Name of the theme (on disk), e.g. "Crux" */
+  char *name;
+  /** Path to the files associated with the theme */
+  char *dirname;
+  /**
+   * Filename of the XML theme file.
+   * \bug Kept lying around for no discernable reason.
+   */
+  char *filename;
+  /** Metadata: Human-readable name of the theme. */
+  char *readable_name;
+  /** Metadata: Author of the theme. */
+  char *author;
+  /** Metadata: Copyright holder. */
+  char *copyright;
+  /** Metadata: Date of the theme. */
+  char *date;
+  /** Metadata: Description of the theme. */
+  char *description;
+  /** Version of the theme format. Older versions cannot use the features
+   * of newer versions even if they think they can (this is to allow forward
+   * and backward compatibility.
+   */
+  guint format_version;
+
+  /** Symbol table of integer constants. */
+  GHashTable *integer_constants;
+  /** Symbol table of float constants. */
+  GHashTable *float_constants;
+  /**
+   * Symbol table of colour constants (hex triples, and triples
+   * plus alpha).
+   * */
+  GHashTable *color_constants;
+  GHashTable *images_by_filename;
+  GHashTable *layouts_by_name;
+  GHashTable *draw_op_lists_by_name;
+  GHashTable *styles_by_name;
+  GHashTable *style_sets_by_name;
+  MetaFrameStyleSet *style_sets_by_type[META_FRAME_TYPE_LAST];
+
+  GQuark quark_width;
+  GQuark quark_height;
+  GQuark quark_object_width;
+  GQuark quark_object_height;
+  GQuark quark_left_width;
+  GQuark quark_right_width;
+  GQuark quark_top_height;
+  GQuark quark_bottom_height;
+  GQuark quark_mini_icon_width;
+  GQuark quark_mini_icon_height;
+  GQuark quark_icon_width;
+  GQuark quark_icon_height;
+  GQuark quark_title_width;
+  GQuark quark_title_height;
+  GQuark quark_frame_x_center;
+  GQuark quark_frame_y_center;
 };
 
-void               meta_frame_layout_apply_scale (const MetaFrameLayout *layout,
-                                                  PangoFontDescription  *font_desc);
+struct _MetaPositionExprEnv
+{
+  MetaRectangle rect;
+  /* size of an object being drawn, if it has a natural size */
+  int object_width;
+  int object_height;
+  /* global object sizes, always available */
+  int left_width;
+  int right_width;
+  int top_height;
+  int bottom_height;
+  int title_width;
+  int title_height;
+  int frame_x_center;
+  int frame_y_center;
+  int mini_icon_width;
+  int mini_icon_height;
+  int icon_width;
+  int icon_height;
+  /* Theme so we can look up constants */
+  MetaTheme *theme;
+};
 
-MetaFrameLayout* meta_theme_get_frame_layout (MetaTheme     *theme,
-                                              MetaFrameType  type);
+MetaFrameLayout* meta_frame_layout_new           (void);
+MetaFrameLayout* meta_frame_layout_copy          (const MetaFrameLayout *src);
+void             meta_frame_layout_ref           (MetaFrameLayout       *layout);
+void             meta_frame_layout_unref         (MetaFrameLayout       *layout);
+void             meta_frame_layout_get_borders   (const MetaFrameLayout *layout,
+                                                  int                    text_height,
+                                                  MetaFrameFlags         flags,
+                                                  MetaFrameType          type,
+                                                  MetaFrameBorders      *borders);
+gboolean         meta_frame_layout_validate      (const MetaFrameLayout *layout,
+                                                  GError               **error);
+
+gboolean meta_parse_position_expression (MetaDrawSpec               *spec,
+                                         const MetaPositionExprEnv  *env,
+                                         int                        *x_return,
+                                         int                        *y_return,
+                                         GError                    **err);
+gboolean meta_parse_size_expression     (MetaDrawSpec               *spec,
+                                         const MetaPositionExprEnv  *env,
+                                         int                        *val_return,
+                                         GError                    **err);
+
+MetaDrawSpec* meta_draw_spec_new (MetaTheme  *theme,
+                                  const char *expr,
+                                  GError    **error);
+void          meta_draw_spec_free (MetaDrawSpec *spec);
+
+MetaColorSpec* meta_color_spec_new             (MetaColorSpecType  type);
+MetaColorSpec* meta_color_spec_new_from_string (const char        *str,
+                                                GError           **err);
+MetaColorSpec* meta_color_spec_new_gtk         (MetaGtkColorComponent component,
+                                                GtkStateFlags         state);
+void           meta_color_spec_free            (MetaColorSpec     *spec);
+void           meta_color_spec_render          (MetaColorSpec     *spec,
+                                                GtkStyleContext   *style_gtk,
+                                                GdkRGBA           *color);
+
+
+MetaDrawOp*    meta_draw_op_new  (MetaDrawType        type);
+void           meta_draw_op_free (MetaDrawOp          *op);
+
+void           meta_draw_op_draw_with_style (const MetaDrawOp    *op,
+                                             GtkStyleContext     *style_gtk,
+                                             cairo_t             *cr,
+                                             const MetaDrawInfo  *info,
+                                             /* logical region being drawn */
+                                             MetaRectangle        logical_region);
+
+MetaDrawOpList* meta_draw_op_list_new   (int                   n_preallocs);
+void            meta_draw_op_list_ref   (MetaDrawOpList       *op_list);
+void            meta_draw_op_list_unref (MetaDrawOpList       *op_list);
+void            meta_draw_op_list_draw_with_style  (const MetaDrawOpList *op_list,
+                                                    GtkStyleContext      *style_gtk,
+                                                    cairo_t              *cr,
+                                                    const MetaDrawInfo   *info,
+                                                    MetaRectangle         rect);
+void           meta_draw_op_list_append (MetaDrawOpList       *op_list,
+                                         MetaDrawOp           *op);
+gboolean       meta_draw_op_list_validate (MetaDrawOpList    *op_list,
+                                           GError           **error);
+gboolean       meta_draw_op_list_contains (MetaDrawOpList    *op_list,
+                                           MetaDrawOpList    *child);
+
+MetaGradientSpec* meta_gradient_spec_new    (MetaGradientType        type);
+void              meta_gradient_spec_free   (MetaGradientSpec       *desc);
+GdkPixbuf*        meta_gradient_spec_render (const MetaGradientSpec *desc,
+                                             GtkStyleContext        *gtk_style,
+                                             int                     width,
+                                             int                     height);
+gboolean          meta_gradient_spec_validate (MetaGradientSpec     *spec,
+                                               GError              **error);
+
+MetaAlphaGradientSpec* meta_alpha_gradient_spec_new  (MetaGradientType       type,
+                                                      int                    n_alphas);
+void                   meta_alpha_gradient_spec_free (MetaAlphaGradientSpec *spec);
+
+
+MetaFrameStyle* meta_frame_style_new   (MetaFrameStyle *parent);
+void            meta_frame_style_ref   (MetaFrameStyle *style);
+void            meta_frame_style_unref (MetaFrameStyle *style);
+
+void            meta_frame_style_apply_scale (const MetaFrameStyle *style,
+                                              PangoFontDescription *font_desc);
+
+gboolean       meta_frame_style_validate (MetaFrameStyle    *style,
+                                          guint              current_theme_version,
+                                          GError           **error);
+
+MetaFrameStyleSet* meta_frame_style_set_new   (MetaFrameStyleSet *parent);
+void               meta_frame_style_set_ref   (MetaFrameStyleSet *style_set);
+void               meta_frame_style_set_unref (MetaFrameStyleSet *style_set);
+
+gboolean       meta_frame_style_set_validate  (MetaFrameStyleSet *style_set,
+                                               GError           **error);
+
+GdkPixbuf* meta_theme_load_image (MetaTheme  *theme,
+                                  const char *filename,
+                                  guint       size_of_theme_icons,
+                                  GError    **error);
+
+MetaFrameStyle* meta_theme_get_frame_style (MetaTheme     *theme,
+                                            MetaFrameType  type,
+                                            MetaFrameFlags flags);
 
 MetaStyleInfo * meta_theme_create_style_info (GdkScreen   *screen,
                                               const gchar *variant);
@@ -253,7 +1060,7 @@
                             int                     text_height,
                             const MetaButtonLayout *button_layout,
                             MetaButtonState         button_states[META_BUTTON_TYPE_LAST],
-                            cairo_surface_t        *mini_icon);
+                            GdkPixbuf              *mini_icon);
 
 void meta_theme_get_frame_borders (MetaTheme         *theme,
                                    MetaStyleInfo     *style_info,
@@ -272,10 +1079,102 @@
                                const MetaButtonLayout *button_layout,
                                MetaFrameGeometry      *fgeom);
 
+MetaFrameLayout*   meta_theme_lookup_layout       (MetaTheme         *theme,
+                                                   const char        *name);
+void               meta_theme_insert_layout       (MetaTheme         *theme,
+                                                   const char        *name,
+                                                   MetaFrameLayout   *layout);
+MetaDrawOpList*    meta_theme_lookup_draw_op_list (MetaTheme         *theme,
+                                                   const char        *name);
+void               meta_theme_insert_draw_op_list (MetaTheme         *theme,
+                                                   const char        *name,
+                                                   MetaDrawOpList    *op_list);
+MetaFrameStyle*    meta_theme_lookup_style        (MetaTheme         *theme,
+                                                   const char        *name);
+void               meta_theme_insert_style        (MetaTheme         *theme,
+                                                   const char        *name,
+                                                   MetaFrameStyle    *style);
+MetaFrameStyleSet* meta_theme_lookup_style_set    (MetaTheme         *theme,
+                                                   const char        *name);
+void               meta_theme_insert_style_set    (MetaTheme         *theme,
+                                                   const char        *name,
+                                                   MetaFrameStyleSet *style_set);
+gboolean meta_theme_define_int_constant   (MetaTheme   *theme,
+                                           const char  *name,
+                                           int          value,
+                                           GError     **error);
+gboolean meta_theme_lookup_int_constant   (MetaTheme   *theme,
+                                           const char  *name,
+                                           int         *value);
+gboolean meta_theme_define_float_constant (MetaTheme   *theme,
+                                           const char  *name,
+                                           double       value,
+                                           GError     **error);
+gboolean meta_theme_lookup_float_constant (MetaTheme   *theme,
+                                           const char  *name,
+                                           double      *value);
+
+gboolean meta_theme_define_color_constant (MetaTheme   *theme,
+                                           const char  *name,
+                                           const char  *value,
+                                           GError     **error);
+gboolean meta_theme_lookup_color_constant (MetaTheme   *theme,
+                                           const char  *name,
+                                           char       **value);
+
+gboolean     meta_theme_replace_constants     (MetaTheme    *theme,
+                                               PosToken     *tokens,
+                                               int           n_tokens,
+                                               GError      **err);
+
 /* random stuff */
 
 int                   meta_pango_font_desc_get_text_height (const PangoFontDescription *font_desc,
                                                             PangoContext         *context);
-int                   meta_theme_get_window_scaling_factor (void);
+
+
+/* Enum converters */
+MetaGtkColorComponent meta_color_component_from_string (const char            *str);
+MetaButtonState       meta_button_state_from_string    (const char            *str);
+const char*           meta_button_state_to_string      (MetaButtonState        state);
+MetaButtonType        meta_button_type_from_string     (const char            *str,
+                                                        MetaTheme             *theme);
+const char*           meta_button_type_to_string       (MetaButtonType         type);
+MetaFramePiece        meta_frame_piece_from_string     (const char            *str);
+MetaFrameState        meta_frame_state_from_string     (const char            *str);
+const char*           meta_frame_state_to_string       (MetaFrameState         state);
+MetaFrameResize       meta_frame_resize_from_string    (const char            *str);
+const char*           meta_frame_resize_to_string      (MetaFrameResize        resize);
+MetaFrameFocus        meta_frame_focus_from_string     (const char            *str);
+const char*           meta_frame_focus_to_string       (MetaFrameFocus         focus);
+MetaFrameType         meta_frame_type_from_string      (const char            *str);
+MetaGradientType      meta_gradient_type_from_string   (const char            *str);
+GtkStateFlags         meta_gtk_state_from_string       (const char            *str);
+GtkShadowType         meta_gtk_shadow_from_string      (const char            *str);
+GtkArrowType          meta_gtk_arrow_from_string       (const char            *str);
+MetaImageFillType     meta_image_fill_type_from_string (const char            *str);
+
+void                  meta_gtk_style_get_light_color   (GtkStyleContext      *style,
+                                                        GtkStateFlags         state,
+                                                        GdkRGBA              *color);
+void                  meta_gtk_style_get_dark_color    (GtkStyleContext      *style,
+                                                        GtkStateFlags         state,
+                                                        GdkRGBA              *color);
+
+guint meta_theme_earliest_version_with_button (MetaButtonType type);
+
+
+#define META_THEME_ALLOWS(theme, feature) (theme->format_version >= feature)
+
+/* What version of the theme file format were various features introduced in? */
+#define META_THEME_SHADE_STICK_ABOVE_BUTTONS 2
+#define META_THEME_UBIQUITOUS_CONSTANTS 2
+#define META_THEME_VARIED_ROUND_CORNERS 2
+#define META_THEME_IMAGES_FROM_ICON_THEMES 2
+#define META_THEME_UNRESIZABLE_SHADED_STYLES 2
+#define META_THEME_DEGREES_IN_ARCS 2
+#define META_THEME_HIDDEN_BUTTONS 2
+#define META_THEME_COLOR_CONSTANTS 2
+#define META_THEME_FRAME_BACKGROUNDS 2
 
 #endif /* META_THEME_PRIVATE_H */
diff '--exclude=.git' -urN a/src/ui/theme.c b/src/ui/theme.c
--- a/src/ui/theme.c	2015-10-30 16:39:40.975006658 -0400
+++ b/src/ui/theme.c	2015-10-31 13:33:56.676252037 -0400
@@ -21,6 +21,7 @@
 #include "theme-private.h"
 #include "frames.h" /* for META_TYPE_FRAMES */
 #include "util-private.h"
+#include <meta/gradient.h>
 #include <meta/prefs.h>
 #include <gtk/gtk.h>
 #include <string.h>
@@ -28,46 +29,318 @@
 #include <stdarg.h>
 #include <math.h>
 
+#define GDK_COLOR_RGBA(color)                                           \
+                         ((guint32) (0xff                         |     \
+                                     ((int)((color).red * 255) << 24)   |    \
+                                     ((int)((color).green * 255) << 16) |    \
+                                     ((int)((color).blue * 255) << 8)))
+
+#define GDK_COLOR_RGB(color)                                            \
+                         ((guint32) (((int)((color).red * 255) << 16)   |    \
+                                     ((int)((color).green * 255) << 8)  |    \
+                                     ((int)((color).blue * 255))))
+
 #define DEBUG_FILL_STRUCT(s) memset ((s), 0xef, sizeof (*(s)))
+#define CLAMP_UCHAR(v) ((guchar) (CLAMP (((int)v), (int)0, (int)255)))
+#define INTENSITY(r, g, b) ((r) * 0.30 + (g) * 0.59 + (b) * 0.11)
+
+static void gtk_style_shade		(GdkRGBA	 *a,
+					 GdkRGBA	 *b,
+					 gdouble	  k);
+static void rgb_to_hls			(gdouble	 *r,
+					 gdouble	 *g,
+					 gdouble	 *b);
+static void hls_to_rgb			(gdouble	 *h,
+					 gdouble	 *l,
+					 gdouble	 *s);
+
+/*
+ * The current theme. (Themes are singleton.)
+ */
+static MetaTheme *meta_current_theme = NULL;
+
+static GdkPixbuf *
+colorize_pixbuf (GdkPixbuf *orig,
+                 GdkRGBA   *new_color)
+{
+  GdkPixbuf *pixbuf;
+  double intensity;
+  int x, y;
+  const guchar *src;
+  guchar *dest;
+  int orig_rowstride;
+  int dest_rowstride;
+  int width, height;
+  gboolean has_alpha;
+  const guchar *src_pixels;
+  guchar *dest_pixels;
+
+  pixbuf = gdk_pixbuf_new (gdk_pixbuf_get_colorspace (orig), gdk_pixbuf_get_has_alpha (orig),
+                           gdk_pixbuf_get_bits_per_sample (orig),
+                           gdk_pixbuf_get_width (orig), gdk_pixbuf_get_height (orig));
+
+  if (pixbuf == NULL)
+    return NULL;
+
+  orig_rowstride = gdk_pixbuf_get_rowstride (orig);
+  dest_rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  has_alpha = gdk_pixbuf_get_has_alpha (orig);
+  src_pixels = gdk_pixbuf_get_pixels (orig);
+  dest_pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+  for (y = 0; y < height; y++)
+    {
+      src = src_pixels + y * orig_rowstride;
+      dest = dest_pixels + y * dest_rowstride;
+
+      for (x = 0; x < width; x++)
+        {
+          double dr, dg, db;
+
+          intensity = INTENSITY (src[0], src[1], src[2]) / 255.0;
+
+          if (intensity <= 0.5)
+            {
+              /* Go from black at intensity = 0.0 to new_color at intensity = 0.5 */
+              dr = new_color->red * intensity * 2.0;
+              dg = new_color->green * intensity * 2.0;
+              db = new_color->blue * intensity * 2.0;
+            }
+          else
+            {
+              /* Go from new_color at intensity = 0.5 to white at intensity = 1.0 */
+              dr = new_color->red + (1.0 - new_color->red) * (intensity - 0.5) * 2.0;
+              dg = new_color->green + (1.0 - new_color->green) * (intensity - 0.5) * 2.0;
+              db = new_color->blue + (1.0 - new_color->blue) * (intensity - 0.5) * 2.0;
+            }
+
+          dest[0] = CLAMP_UCHAR (255 * dr);
+          dest[1] = CLAMP_UCHAR (255 * dg);
+          dest[2] = CLAMP_UCHAR (255 * db);
+
+          if (has_alpha)
+            {
+              dest[3] = src[3];
+              src += 4;
+              dest += 4;
+            }
+          else
+            {
+              src += 3;
+              dest += 3;
+            }
+        }
+    }
+
+  return pixbuf;
+}
 
-static void scale_border (GtkBorder *border, double factor);
+static void
+color_composite (const GdkRGBA *bg,
+                 const GdkRGBA *fg,
+                 double         alpha,
+                 GdkRGBA       *color)
+{
+  *color = *bg;
+  color->red = color->red + (fg->red - color->red) * alpha;
+  color->green = color->green + (fg->green - color->green) * alpha;
+  color->blue = color->blue + (fg->blue - color->blue) * alpha;
+  color->alpha = color->alpha + (fg->alpha - color->alpha) * alpha;
+}
 
-static MetaFrameLayout *
+/**
+ * meta_frame_layout_new: (skip)
+ *
+ * Creates a new, empty MetaFrameLayout. The fields will be set to dummy
+ * values.
+ *
+ * Returns: The newly created MetaFrameLayout.
+ */
+MetaFrameLayout*
 meta_frame_layout_new  (void)
 {
   MetaFrameLayout *layout;
 
   layout = g_new0 (MetaFrameLayout, 1);
 
+  layout->refcount = 1;
+
   /* Spacing as hardcoded in GTK+:
    * https://git.gnome.org/browse/gtk+/tree/gtk/gtkheaderbar.c?h=gtk-3-14#n53
    */
   layout->titlebar_spacing = 6;
   layout->has_title = TRUE;
-  layout->title_scale = PANGO_SCALE_MEDIUM;
+  layout->title_scale = 1.0;
   layout->icon_size = META_MINI_ICON_WIDTH;
 
   return layout;
 }
 
-static void
-meta_frame_layout_free (MetaFrameLayout *layout)
+static gboolean
+validate_border (const GtkBorder *border,
+                 const char     **bad)
+{
+  *bad = NULL;
+
+  if (border->top < 0)
+    *bad = _("top");
+  else if (border->bottom < 0)
+    *bad = _("bottom");
+  else if (border->left < 0)
+    *bad = _("left");
+  else if (border->right < 0)
+    *bad = _("right");
+
+  return *bad == NULL;
+}
+
+/**
+ * validate_geometry_value:
+ * @val: The value to check
+ * @name: The name to use in the error message
+ * @error: (out): Set to an error if val was not initialised
+ *
+ * Ensures that the theme supplied a particular dimension. When a
+ * #MetaFrameLayout is created, all its integer fields are set to -1
+ * by meta_frame_layout_new(). After an instance of this type
+ * should have been initialised, this function checks that
+ * a given field is not still at -1. It is never called directly, but
+ * rather via the %CHECK_GEOMETRY_VALUE and %CHECK_GEOMETRY_BORDER
+ * macros.
+ */
+static gboolean
+validate_geometry_value (int         val,
+                         const char *name,
+                         GError    **error)
+{
+  if (val < 0)
+    {
+      g_set_error (error, META_THEME_ERROR,
+                   META_THEME_ERROR_FRAME_GEOMETRY,
+                   _("frame geometry does not specify \"%s\" dimension"),
+                   name);
+      return FALSE;
+    }
+  else
+    return TRUE;
+}
+
+static gboolean
+validate_geometry_border (const GtkBorder *border,
+                          const char      *name,
+                          GError         **error)
+{
+  const char *bad;
+
+  if (!validate_border (border, &bad))
+    {
+      g_set_error (error, META_THEME_ERROR,
+                   META_THEME_ERROR_FRAME_GEOMETRY,
+                   _("frame geometry does not specify dimension \"%s\" for border \"%s\""),
+                   bad, name);
+      return FALSE;
+    }
+  else
+    return TRUE;
+}
+
+gboolean
+meta_frame_layout_validate (const MetaFrameLayout *layout,
+                            GError               **error)
+{
+  g_return_val_if_fail (layout != NULL, FALSE);
+
+#define CHECK_GEOMETRY_VALUE(vname) if (!validate_geometry_value (layout->vname, #vname, error)) return FALSE
+
+#define CHECK_GEOMETRY_BORDER(bname) if (!validate_geometry_border (&layout->bname, #bname, error)) return FALSE
+
+  CHECK_GEOMETRY_VALUE (left_width);
+  CHECK_GEOMETRY_VALUE (right_width);
+  CHECK_GEOMETRY_VALUE (bottom_height);
+
+  CHECK_GEOMETRY_BORDER (title_border);
+
+  CHECK_GEOMETRY_VALUE (title_vertical_pad);
+
+  CHECK_GEOMETRY_VALUE (right_titlebar_edge);
+  CHECK_GEOMETRY_VALUE (left_titlebar_edge);
+
+  switch (layout->button_sizing)
+    {
+    case META_BUTTON_SIZING_ASPECT:
+      if (layout->button_aspect < (0.1) ||
+          layout->button_aspect > (15.0))
+        {
+          g_set_error (error, META_THEME_ERROR,
+                       META_THEME_ERROR_FRAME_GEOMETRY,
+                       _("Button aspect ratio %g is not reasonable"),
+                       layout->button_aspect);
+          return FALSE;
+        }
+      break;
+    case META_BUTTON_SIZING_FIXED:
+      CHECK_GEOMETRY_VALUE (button_width);
+      CHECK_GEOMETRY_VALUE (button_height);
+      break;
+    case META_BUTTON_SIZING_LAST:
+      g_set_error (error, META_THEME_ERROR,
+                   META_THEME_ERROR_FRAME_GEOMETRY,
+                   _("Frame geometry does not specify size of buttons"));
+      return FALSE;
+    }
+
+  CHECK_GEOMETRY_BORDER (button_border);
+
+  return TRUE;
+}
+
+MetaFrameLayout*
+meta_frame_layout_copy (const MetaFrameLayout *src)
+{
+  MetaFrameLayout *layout;
+
+  layout = g_new0 (MetaFrameLayout, 1);
+
+  *layout = *src;
+
+  layout->refcount = 1;
+
+  return layout;
+}
+
+void
+meta_frame_layout_ref (MetaFrameLayout *layout)
 {
   g_return_if_fail (layout != NULL);
 
-  DEBUG_FILL_STRUCT (layout);
-  g_free (layout);
+  layout->refcount += 1;
 }
 
-static void
+void
+meta_frame_layout_unref (MetaFrameLayout *layout)
+{
+  g_return_if_fail (layout != NULL);
+  g_return_if_fail (layout->refcount > 0);
+
+  layout->refcount -= 1;
+
+  if (layout->refcount == 0)
+    {
+      DEBUG_FILL_STRUCT (layout);
+      g_free (layout);
+    }
+}
+
+void
 meta_frame_layout_get_borders (const MetaFrameLayout *layout,
                                int                    text_height,
                                MetaFrameFlags         flags,
                                MetaFrameType          type,
                                MetaFrameBorders      *borders)
 {
-  int buttons_height, content_height, draggable_borders;
-  int scale = meta_theme_get_window_scaling_factor ();
+  int buttons_height, title_height, draggable_borders;
 
   meta_frame_borders_clear (borders);
 
@@ -80,15 +353,16 @@
   if (!layout->has_title)
     text_height = 0;
 
-  buttons_height = layout->icon_size +
+  buttons_height = layout->button_height +
     layout->button_border.top + layout->button_border.bottom;
-  content_height = MAX (buttons_height, text_height) +
-                   layout->titlebar_border.top + layout->titlebar_border.bottom;
-
-  borders->visible.top    = layout->frame_border.top + content_height;
-  borders->visible.left   = layout->frame_border.left;
-  borders->visible.right  = layout->frame_border.right;
-  borders->visible.bottom = layout->frame_border.bottom;
+  title_height = text_height +
+    layout->title_vertical_pad +
+    layout->title_border.top + layout->title_border.bottom;
+
+  borders->visible.top    = MAX (buttons_height, title_height);
+  borders->visible.left   = layout->left_width;
+  borders->visible.right  = layout->right_width;
+  borders->visible.bottom = layout->bottom_height;
 
   draggable_borders = meta_prefs_get_draggable_border_width ();
 
@@ -113,35 +387,40 @@
   borders->total.right  = borders->invisible.right  + borders->visible.right;
   borders->total.bottom = borders->invisible.bottom + borders->visible.bottom;
   borders->total.top    = borders->invisible.top    + borders->visible.top;
-
-  /* Scale geometry for HiDPI, see comment in meta_frame_layout_draw_with_style() */
-  scale_border (&borders->visible, scale);
-  scale_border (&borders->invisible, scale);
-  scale_border (&borders->total, scale);
 }
 
-int
-meta_theme_get_window_scaling_factor ()
+static MetaButtonType
+map_button_function_to_type (MetaButtonFunction  function)
 {
-  GdkScreen *screen;
-  GValue value = G_VALUE_INIT;
-
-  g_value_init (&value, G_TYPE_INT);
-
-  screen = gdk_screen_get_default ();
-  if (gdk_screen_get_setting (screen, "gdk-window-scaling-factor", &value))
-    return g_value_get_int (&value);
-  else
-    return 1;
-}
+  switch (function)
+    {
+    case META_BUTTON_FUNCTION_SHADE:
+      return META_BUTTON_TYPE_SHADE;
+    case META_BUTTON_FUNCTION_ABOVE:
+      return META_BUTTON_TYPE_ABOVE;
+    case META_BUTTON_FUNCTION_STICK:
+      return META_BUTTON_TYPE_STICK;
+    case META_BUTTON_FUNCTION_UNSHADE:
+      return META_BUTTON_TYPE_UNSHADE;
+    case META_BUTTON_FUNCTION_UNABOVE:
+      return META_BUTTON_TYPE_UNABOVE;
+    case META_BUTTON_FUNCTION_UNSTICK:
+      return META_BUTTON_TYPE_UNSTICK;
+    case META_BUTTON_FUNCTION_MENU:
+      return META_BUTTON_TYPE_MENU;
+    case META_BUTTON_FUNCTION_APPMENU:
+      return META_BUTTON_TYPE_APPMENU;
+    case META_BUTTON_FUNCTION_MINIMIZE:
+      return META_BUTTON_TYPE_MINIMIZE;
+    case META_BUTTON_FUNCTION_MAXIMIZE:
+      return META_BUTTON_TYPE_MAXIMIZE;
+    case META_BUTTON_FUNCTION_CLOSE:
+      return META_BUTTON_TYPE_CLOSE;
+    case META_BUTTON_FUNCTION_LAST:
+      return META_BUTTON_TYPE_LAST;
+    }
 
-void
-meta_frame_layout_apply_scale (const MetaFrameLayout *layout,
-                               PangoFontDescription  *font_desc)
-{
-  int size = pango_font_description_get_size (font_desc);
-  double scale = layout->title_scale / meta_theme_get_window_scaling_factor ();
-  pango_font_description_set_size (font_desc, MAX (size * scale, 1));
+  return META_BUTTON_TYPE_LAST;
 }
 
 static MetaButtonSpace*
@@ -198,6 +477,7 @@
 
 static gboolean
 strip_button (MetaButtonSpace *func_rects[MAX_BUTTONS_PER_CORNER],
+              GdkRectangle    *bg_rects[MAX_BUTTONS_PER_CORNER],
               int             *n_rects,
               MetaButtonSpace *to_strip)
 {
@@ -214,11 +494,13 @@
           while (i < *n_rects)
             {
               func_rects[i] = func_rects[i+1];
+              bg_rects[i] = bg_rects[i+1];
 
               ++i;
             }
 
           func_rects[i] = NULL;
+          bg_rects[i] = NULL;
 
           return TRUE;
         }
@@ -266,9 +548,15 @@
 
   meta_style_info_set_flags (style_info, flags);
 
+  layout->button_sizing = META_BUTTON_SIZING_FIXED;
+
   style = style_info->styles[META_STYLE_ELEMENT_FRAME];
-  get_padding_and_border (style, &layout->frame_border);
-  scale_border (&layout->frame_border, layout->title_scale);
+  get_padding_and_border (style, &border);
+  scale_border (&border, layout->title_scale);
+
+  layout->left_width = border.left;
+  layout->right_width = border.right;
+  layout->bottom_height = border.bottom;
 
   if (layout->hide_buttons)
     layout->icon_size = 0;
@@ -287,26 +575,36 @@
    */
   layout->top_left_corner_rounded_radius = border_radius;
   layout->top_right_corner_rounded_radius = border_radius;
-  max_radius = MIN (layout->frame_border.bottom, layout->frame_border.left);
+  max_radius = MIN (layout->bottom_height, layout->left_width);
   layout->bottom_left_corner_rounded_radius = MAX (border_radius, max_radius);
-  max_radius = MIN (layout->frame_border.bottom, layout->frame_border.right);
+  max_radius = MIN (layout->bottom_height, layout->right_width);
   layout->bottom_right_corner_rounded_radius = MAX (border_radius, max_radius);
 
-  get_padding_and_border (style, &layout->titlebar_border);
-  scale_border (&layout->titlebar_border, layout->title_scale);
+  get_padding_and_border (style, &border);
+  scale_border (&border, layout->title_scale);
+  layout->left_titlebar_edge = border.left;
+  layout->right_titlebar_edge = border.right;
+  layout->title_vertical_pad = border.top;
+
+  layout->button_border.top = border.top;
+  layout->button_border.bottom = border.bottom;
+  layout->button_border.left = 0;
+  layout->button_border.right = 0;
+
+  layout->button_width = layout->icon_size;
+  layout->button_height = layout->icon_size;
 
   style = style_info->styles[META_STYLE_ELEMENT_BUTTON];
-  get_padding_and_border (style, &layout->button_border);
-  scale_border (&layout->button_border, layout->title_scale);
+  get_padding_and_border (style, &border);
+  scale_border (&border, layout->title_scale);
+  layout->button_width += border.left + border.right;
+  layout->button_height += border.top + border.bottom;
 
   style = style_info->styles[META_STYLE_ELEMENT_IMAGE];
   get_padding_and_border (style, &border);
   scale_border (&border, layout->title_scale);
-
-  layout->button_border.left += border.left;
-  layout->button_border.right += border.right;
-  layout->button_border.top += border.top;
-  layout->button_border.bottom += border.bottom;
+  layout->button_width += border.left + border.right;
+  layout->button_height += border.top + border.bottom;
 }
 
 static void
@@ -326,17 +624,17 @@
   int button_y;
   int title_right_edge;
   int width, height;
-  int content_width, content_height;
   int button_width, button_height;
   int min_size_for_rounding;
-  int scale = meta_theme_get_window_scaling_factor ();
 
   /* the left/right rects in order; the max # of rects
    * is the number of button functions
    */
   MetaButtonSpace *left_func_rects[MAX_BUTTONS_PER_CORNER];
   MetaButtonSpace *right_func_rects[MAX_BUTTONS_PER_CORNER];
+  GdkRectangle *left_bg_rects[MAX_BUTTONS_PER_CORNER];
   gboolean left_buttons_has_spacer[MAX_BUTTONS_PER_CORNER];
+  GdkRectangle *right_bg_rects[MAX_BUTTONS_PER_CORNER];
   gboolean right_buttons_has_spacer[MAX_BUTTONS_PER_CORNER];
 
   MetaFrameBorders borders;
@@ -349,13 +647,6 @@
 
   fgeom->borders = borders;
 
-  /* Scale geometry for HiDPI, see comment in meta_frame_layout_draw_with_style() */
-  fgeom->content_border = layout->frame_border;
-  fgeom->content_border.left   += layout->titlebar_border.left * scale;
-  fgeom->content_border.right  += layout->titlebar_border.right * scale;
-  fgeom->content_border.top    += layout->titlebar_border.top * scale;
-  fgeom->content_border.bottom += layout->titlebar_border.bottom * scale;
-
   width = client_width + borders.total.left + borders.total.right;
 
   height = borders.total.top + borders.total.bottom;
@@ -365,17 +656,29 @@
   fgeom->width = width;
   fgeom->height = height;
 
-  content_width = width -
-                  (fgeom->content_border.left + borders.invisible.left) -
-                  (fgeom->content_border.right + borders.invisible.right);
-  content_height = borders.visible.top - fgeom->content_border.top - fgeom->content_border.bottom;
-
-  button_width = layout->icon_size +
-                 layout->button_border.left + layout->button_border.right;
-  button_height = layout->icon_size +
-                  layout->button_border.top + layout->button_border.bottom;
-  button_width *= scale;
-  button_height *= scale;
+  fgeom->top_titlebar_edge = layout->title_border.top;
+  fgeom->bottom_titlebar_edge = layout->title_border.bottom;
+  fgeom->left_titlebar_edge = layout->left_titlebar_edge;
+  fgeom->right_titlebar_edge = layout->right_titlebar_edge;
+
+  /* gcc warnings */
+  button_width = -1;
+  button_height = -1;
+
+  switch (layout->button_sizing)
+    {
+    case META_BUTTON_SIZING_ASPECT:
+      button_height = borders.visible.top - layout->button_border.top - layout->button_border.bottom;
+      button_width = button_height / layout->button_aspect;
+      break;
+    case META_BUTTON_SIZING_FIXED:
+      button_width = layout->button_width;
+      button_height = layout->button_height;
+      break;
+    case META_BUTTON_SIZING_LAST:
+      g_assert_not_reached ();
+      break;
+    }
 
   /* FIXME all this code sort of pretends that duplicate buttons
    * with the same function are allowed, but that breaks the
@@ -426,22 +729,55 @@
         }
     }
 
+  for (i = 0; i < MAX_BUTTONS_PER_CORNER; i++)
+    {
+      left_bg_rects[i] = NULL;
+      right_bg_rects[i] = NULL;
+    }
+
+  for (i = 0; i < n_left; i++)
+    {
+      if (n_left == 1)
+        left_bg_rects[i] = &fgeom->left_single_background;
+      else if (i == 0)
+        left_bg_rects[i] = &fgeom->left_left_background;
+      else if (i == (n_left - 1))
+        left_bg_rects[i] = &fgeom->left_right_background;
+      else
+        left_bg_rects[i] = &fgeom->left_middle_backgrounds[i - 1];
+    }
+
+  for (i = 0; i < n_right; i++)
+    {
+      if (n_right == 1)
+        right_bg_rects[i] = &fgeom->right_single_background;
+      else if (i == (n_right - 1))
+        right_bg_rects[i] = &fgeom->right_right_background;
+      else if (i == 0)
+        right_bg_rects[i] = &fgeom->right_left_background;
+      else
+        right_bg_rects[i] = &fgeom->right_middle_backgrounds[i - 1];
+    }
+
   /* Be sure buttons fit */
   while (n_left > 0 || n_right > 0)
     {
       int space_used_by_buttons;
+      int space_available;
+
+      space_available = fgeom->width - layout->left_titlebar_edge - layout->right_titlebar_edge;
 
       space_used_by_buttons = 0;
 
       space_used_by_buttons += button_width * n_left;
       space_used_by_buttons += (button_width * 0.75) * n_left_spacers;
-      space_used_by_buttons += layout->titlebar_spacing * scale * MAX (n_left - 1, 0);
+      space_used_by_buttons += layout->titlebar_spacing * MAX (n_left - 1, 0);
 
       space_used_by_buttons += button_width * n_right;
       space_used_by_buttons += (button_width * 0.75) * n_right_spacers;
-      space_used_by_buttons += layout->titlebar_spacing * scale * MAX (n_right - 1, 0);
+      space_used_by_buttons += layout->titlebar_spacing * MAX (n_right - 1, 0);
 
-      if (space_used_by_buttons <= content_width)
+      if (space_used_by_buttons <= space_available)
         break; /* Everything fits, bail out */
 
       /* First try to remove separators */
@@ -460,37 +796,53 @@
        * above, stick, shade, min, max, close, then menu (menu is most useful);
        * prefer the default button locations.
        */
-      if (strip_button (left_func_rects, &n_left, &fgeom->above_rect))
+      if (strip_button (left_func_rects, left_bg_rects,
+                        &n_left, &fgeom->above_rect))
         continue;
-      else if (strip_button (right_func_rects, &n_right, &fgeom->above_rect))
+      else if (strip_button (right_func_rects, right_bg_rects,
+                             &n_right, &fgeom->above_rect))
         continue;
-      else if (strip_button (left_func_rects, &n_left, &fgeom->stick_rect))
+      else if (strip_button (left_func_rects, left_bg_rects,
+                             &n_left, &fgeom->stick_rect))
         continue;
-      else if (strip_button (right_func_rects, &n_right, &fgeom->stick_rect))
+      else if (strip_button (right_func_rects, right_bg_rects,
+                             &n_right, &fgeom->stick_rect))
         continue;
-      else if (strip_button (left_func_rects, &n_left, &fgeom->shade_rect))
+      else if (strip_button (left_func_rects, left_bg_rects,
+                             &n_left, &fgeom->shade_rect))
         continue;
-      else if (strip_button (right_func_rects, &n_right, &fgeom->shade_rect))
+      else if (strip_button (right_func_rects, right_bg_rects,
+                             &n_right, &fgeom->shade_rect))
         continue;
-      else if (strip_button (left_func_rects, &n_left, &fgeom->min_rect))
+      else if (strip_button (left_func_rects, left_bg_rects,
+                             &n_left, &fgeom->min_rect))
         continue;
-      else if (strip_button (right_func_rects, &n_right, &fgeom->min_rect))
+      else if (strip_button (right_func_rects, right_bg_rects,
+                             &n_right, &fgeom->min_rect))
         continue;
-      else if (strip_button (left_func_rects, &n_left, &fgeom->max_rect))
+      else if (strip_button (left_func_rects, left_bg_rects,
+                             &n_left, &fgeom->max_rect))
         continue;
-      else if (strip_button (right_func_rects, &n_right, &fgeom->max_rect))
+      else if (strip_button (right_func_rects, right_bg_rects,
+                             &n_right, &fgeom->max_rect))
         continue;
-      else if (strip_button (left_func_rects, &n_left, &fgeom->close_rect))
+      else if (strip_button (left_func_rects, left_bg_rects,
+                             &n_left, &fgeom->close_rect))
         continue;
-      else if (strip_button (right_func_rects, &n_right, &fgeom->close_rect))
+      else if (strip_button (right_func_rects, right_bg_rects,
+                             &n_right, &fgeom->close_rect))
         continue;
-      else if (strip_button (right_func_rects, &n_right, &fgeom->menu_rect))
+      else if (strip_button (right_func_rects, right_bg_rects,
+                             &n_right, &fgeom->menu_rect))
         continue;
-      else if (strip_button (left_func_rects, &n_left, &fgeom->menu_rect))
+      else if (strip_button (left_func_rects, left_bg_rects,
+                             &n_left, &fgeom->menu_rect))
         continue;
-      else if (strip_button (right_func_rects, &n_right, &fgeom->appmenu_rect))
+      else if (strip_button (right_func_rects, right_bg_rects,
+                             &n_right, &fgeom->appmenu_rect))
         continue;
-      else if (strip_button (left_func_rects, &n_left, &fgeom->appmenu_rect))
+      else if (strip_button (left_func_rects, left_bg_rects,
+                             &n_left, &fgeom->appmenu_rect))
         continue;
       else
         {
@@ -505,11 +857,11 @@
   fgeom->n_right_buttons = n_right;
 
   /* center buttons vertically */
-  button_y = fgeom->content_border.top + borders.invisible.top +
-             (content_height - button_height) / 2;
+  button_y = (borders.visible.top -
+              (button_height + layout->button_border.top + layout->button_border.bottom)) / 2 + layout->button_border.top + borders.invisible.top;
 
   /* right edge of farthest-right button */
-  x = width - fgeom->content_border.right - borders.invisible.right;
+  x = width - layout->right_titlebar_edge - borders.invisible.right;
 
   i = n_right - 1;
   while (i >= 0)
@@ -538,12 +890,14 @@
           rect->clickable.height = button_height + button_y;
 
           if (i == n_right - 1)
-            rect->clickable.width += fgeom->content_border.right;
+            rect->clickable.width += layout->right_titlebar_edge + layout->right_width;
 
         }
       else
         g_memmove (&(rect->clickable), &(rect->visible), sizeof(rect->clickable));
 
+      *(right_bg_rects[i]) = rect->visible;
+
       x = rect->visible.x;
 
       if (i > 0)
@@ -553,12 +907,12 @@
     }
 
   /* save right edge of titlebar for later use */
-  title_right_edge = x;
+  title_right_edge = x - layout->title_border.right;
 
   /* Now x changes to be position from the left and we go through
    * the left-side buttons
    */
-  x = fgeom->content_border.left + borders.invisible.left;
+  x = layout->left_titlebar_edge + borders.invisible.left;
   for (i = 0; i < n_left; i++)
     {
       MetaButtonSpace *rect;
@@ -591,17 +945,20 @@
 
       x = rect->visible.x + rect->visible.width;
       if (i < n_left - 1)
-        x += layout->titlebar_spacing * scale;
+        x += layout->titlebar_spacing;
       if (left_buttons_has_spacer[i])
         x += (button_width * 0.75);
+
+      *(left_bg_rects[i]) = rect->visible;
     }
 
-  /* Center vertically in the available content area */
-  fgeom->title_rect.x = x;
-  fgeom->title_rect.y = fgeom->content_border.top + borders.invisible.top +
-                        (content_height - text_height) / 2;
+  /* We always fill as much vertical space as possible with title rect,
+   * rather than centering it like the buttons
+   */
+  fgeom->title_rect.x = x + layout->title_border.left;
+  fgeom->title_rect.y = layout->title_border.top + borders.invisible.top;
   fgeom->title_rect.width = title_right_edge - fgeom->title_rect.x;
-  fgeom->title_rect.height = text_height;
+  fgeom->title_rect.height = borders.visible.top - layout->title_border.top - layout->title_border.bottom;
 
   /* Nuke title if it won't fit */
   if (fgeom->title_rect.width < 0 ||
@@ -614,7 +971,7 @@
   if (flags & META_FRAME_SHADED)
     min_size_for_rounding = 0;
   else
-    min_size_for_rounding = 5 * scale;
+    min_size_for_rounding = 5;
 
   fgeom->top_left_corner_rounded_radius = 0;
   fgeom->top_right_corner_rounded_radius = 0;
@@ -622,135 +979,3628 @@
   fgeom->bottom_right_corner_rounded_radius = 0;
 
   if (borders.visible.top + borders.visible.left >= min_size_for_rounding)
-    fgeom->top_left_corner_rounded_radius = layout->top_left_corner_rounded_radius * scale;
+    fgeom->top_left_corner_rounded_radius = layout->top_left_corner_rounded_radius;
   if (borders.visible.top + borders.visible.right >= min_size_for_rounding)
-    fgeom->top_right_corner_rounded_radius = layout->top_right_corner_rounded_radius * scale;
+    fgeom->top_right_corner_rounded_radius = layout->top_right_corner_rounded_radius;
 
   if (borders.visible.bottom + borders.visible.left >= min_size_for_rounding)
-    fgeom->bottom_left_corner_rounded_radius = layout->bottom_left_corner_rounded_radius * scale;
+    fgeom->bottom_left_corner_rounded_radius = layout->bottom_left_corner_rounded_radius;
   if (borders.visible.bottom + borders.visible.right >= min_size_for_rounding)
-    fgeom->bottom_right_corner_rounded_radius = layout->bottom_right_corner_rounded_radius * scale;
+    fgeom->bottom_right_corner_rounded_radius = layout->bottom_right_corner_rounded_radius;
 }
 
-static void
-get_button_rect (MetaButtonType           type,
-                 const MetaFrameGeometry *fgeom,
-                 GdkRectangle            *rect)
+/**
+ * meta_gradient_spec_new: (skip)
+ *
+ */
+MetaGradientSpec*
+meta_gradient_spec_new (MetaGradientType type)
 {
-  switch (type)
-    {
-    case META_BUTTON_TYPE_CLOSE:
-      *rect = fgeom->close_rect.visible;
-      break;
+  MetaGradientSpec *spec;
 
-    case META_BUTTON_TYPE_SHADE:
-      *rect = fgeom->shade_rect.visible;
-      break;
+  spec = g_new (MetaGradientSpec, 1);
 
-    case META_BUTTON_TYPE_UNSHADE:
-      *rect = fgeom->unshade_rect.visible;
-      break;
+  spec->type = type;
+  spec->color_specs = NULL;
 
-    case META_BUTTON_TYPE_ABOVE:
-      *rect = fgeom->above_rect.visible;
-      break;
+  return spec;
+}
 
-    case META_BUTTON_TYPE_UNABOVE:
-      *rect = fgeom->unabove_rect.visible;
-      break;
+static void
+free_color_spec (gpointer spec, gpointer user_data)
+{
+  meta_color_spec_free (spec);
+}
 
-    case META_BUTTON_TYPE_STICK:
-      *rect = fgeom->stick_rect.visible;
-      break;
+void
+meta_gradient_spec_free (MetaGradientSpec *spec)
+{
+  g_return_if_fail (spec != NULL);
 
-    case META_BUTTON_TYPE_UNSTICK:
-      *rect = fgeom->unstick_rect.visible;
-      break;
+  g_slist_foreach (spec->color_specs, free_color_spec, NULL);
+  g_slist_free (spec->color_specs);
 
-    case META_BUTTON_TYPE_MAXIMIZE:
-      *rect = fgeom->max_rect.visible;
-      break;
+  DEBUG_FILL_STRUCT (spec);
+  g_free (spec);
+}
 
-    case META_BUTTON_TYPE_MINIMIZE:
-      *rect = fgeom->min_rect.visible;
-      break;
+GdkPixbuf*
+meta_gradient_spec_render (const MetaGradientSpec *spec,
+                           GtkStyleContext        *style,
+                           int                     width,
+                           int                     height)
+{
+  int n_colors;
+  GdkRGBA *colors;
+  GSList *tmp;
+  int i;
+  GdkPixbuf *pixbuf;
 
-    case META_BUTTON_TYPE_MENU:
-      *rect = fgeom->menu_rect.visible;
-      break;
+  n_colors = g_slist_length (spec->color_specs);
 
-    case META_BUTTON_TYPE_APPMENU:
-      *rect = fgeom->appmenu_rect.visible;
-      break;
+  if (n_colors == 0)
+    return NULL;
 
-    default:
-    case META_BUTTON_TYPE_LAST:
-      g_assert_not_reached ();
-      break;
+  colors = g_new (GdkRGBA, n_colors);
+
+  i = 0;
+  tmp = spec->color_specs;
+  while (tmp != NULL)
+    {
+      meta_color_spec_render (tmp->data, style, &colors[i]);
+
+      tmp = tmp->next;
+      ++i;
     }
+
+  pixbuf = meta_gradient_create_multi (width, height,
+                                       colors, n_colors,
+                                       spec->type);
+
+  g_free (colors);
+
+  return pixbuf;
 }
 
-static const char *
-get_class_from_button_type (MetaButtonType type)
+gboolean
+meta_gradient_spec_validate (MetaGradientSpec *spec,
+                             GError          **error)
 {
-  switch (type)
+  g_return_val_if_fail (spec != NULL, FALSE);
+
+  if (g_slist_length (spec->color_specs) < 2)
     {
-    case META_BUTTON_TYPE_CLOSE:
-      return "close";
-    case META_BUTTON_TYPE_MAXIMIZE:
-      return "maximize";
-    case META_BUTTON_TYPE_MINIMIZE:
-      return "minimize";
-    default:
-      return NULL;
+      g_set_error (error, META_THEME_ERROR,
+                   META_THEME_ERROR_FAILED,
+                   _("Gradients should have at least two colors"));
+      return FALSE;
     }
+
+  return TRUE;
 }
 
-static void
-meta_frame_layout_draw_with_style (MetaFrameLayout         *layout,
-                                   MetaStyleInfo           *style_info,
-                                   cairo_t                 *cr,
-                                   const MetaFrameGeometry *fgeom,
-                                   PangoLayout             *title_layout,
-                                   MetaFrameFlags           flags,
-                                   MetaButtonState          button_states[META_BUTTON_TYPE_LAST],
-                                   cairo_surface_t         *mini_icon)
+/**
+ * meta_alpha_gradient_spec_new: (skip)
+ *
+ */
+MetaAlphaGradientSpec*
+meta_alpha_gradient_spec_new (MetaGradientType       type,
+                              int                    n_alphas)
 {
-  GtkStyleContext *style;
-  GtkStateFlags state;
-  MetaButtonType button_type;
-  GdkRectangle visible_rect;
-  GdkRectangle titlebar_rect;
-  GdkRectangle button_rect;
-  const MetaFrameBorders *borders;
-  int scale = meta_theme_get_window_scaling_factor ();
+  MetaAlphaGradientSpec *spec;
 
-  /* We opt out of GTK+/Clutter's HiDPI handling, so we have to do the scaling
-   * ourselves; the nitty-gritty is a bit confusing, so here is an overview:
-   *  - the values in MetaFrameLayout are always as they appear in the theme,
-   *    i.e. unscaled
-   *  - calculated values (borders, MetaFrameGeometry) include the scale - as
-   *    the geometry is comprised of scaled decorations and the client size
-   *    which we must not scale, we don't have another option
-   *  - for drawing, we scale the canvas to have GTK+ render elements (borders,
-   *    radii, ...) at the correct scale - as a result, we have to "unscale"
-   *    the geometry again to not apply the scaling twice
-   */
-  cairo_scale (cr, scale, scale);
+  g_return_val_if_fail (n_alphas > 0, NULL);
 
-  borders = &fgeom->borders;
+  spec = g_new0 (MetaAlphaGradientSpec, 1);
 
-  visible_rect.x = borders->invisible.left / scale;
-  visible_rect.y = borders->invisible.top / scale;
-  visible_rect.width = (fgeom->width - borders->invisible.left - borders->invisible.right) / scale;
-  visible_rect.height = (fgeom->height - borders->invisible.top - borders->invisible.bottom) / scale;
+  spec->type = type;
+  spec->alphas = g_new0 (unsigned char, n_alphas);
+  spec->n_alphas = n_alphas;
 
-  meta_style_info_set_flags (style_info, flags);
+  return spec;
+}
 
-  style = style_info->styles[META_STYLE_ELEMENT_FRAME];
-  gtk_render_background (style, cr,
-                         visible_rect.x, visible_rect.y,
-                         visible_rect.width, visible_rect.height);
+void
+meta_alpha_gradient_spec_free (MetaAlphaGradientSpec *spec)
+{
+  g_return_if_fail (spec != NULL);
+
+  g_free (spec->alphas);
+  g_free (spec);
+}
+
+/**
+ * meta_color_spec_new: (skip)
+ *
+ */
+MetaColorSpec*
+meta_color_spec_new (MetaColorSpecType type)
+{
+  MetaColorSpec *spec;
+  MetaColorSpec dummy;
+  int size;
+
+  size = G_STRUCT_OFFSET (MetaColorSpec, data);
+
+  switch (type)
+    {
+    case META_COLOR_SPEC_BASIC:
+      size += sizeof (dummy.data.basic);
+      break;
+
+    case META_COLOR_SPEC_GTK:
+      size += sizeof (dummy.data.gtk);
+      break;
+
+    case META_COLOR_SPEC_GTK_CUSTOM:
+      size += sizeof (dummy.data.gtkcustom);
+      break;
+
+    case META_COLOR_SPEC_BLEND:
+      size += sizeof (dummy.data.blend);
+      break;
+
+    case META_COLOR_SPEC_SHADE:
+      size += sizeof (dummy.data.shade);
+      break;
+    }
+
+  spec = g_malloc0 (size);
+
+  spec->type = type;
+
+  return spec;
+}
+
+void
+meta_color_spec_free (MetaColorSpec *spec)
+{
+  g_return_if_fail (spec != NULL);
+
+  switch (spec->type)
+    {
+    case META_COLOR_SPEC_BASIC:
+      DEBUG_FILL_STRUCT (&spec->data.basic);
+      break;
+
+    case META_COLOR_SPEC_GTK:
+      DEBUG_FILL_STRUCT (&spec->data.gtk);
+      break;
+
+    case META_COLOR_SPEC_GTK_CUSTOM:
+      g_free (spec->data.gtkcustom.color_name);
+      if (spec->data.gtkcustom.fallback)
+        meta_color_spec_free (spec->data.gtkcustom.fallback);
+      DEBUG_FILL_STRUCT (&spec->data.gtkcustom);
+      break;
+
+    case META_COLOR_SPEC_BLEND:
+      if (spec->data.blend.foreground)
+        meta_color_spec_free (spec->data.blend.foreground);
+      if (spec->data.blend.background)
+        meta_color_spec_free (spec->data.blend.background);
+      DEBUG_FILL_STRUCT (&spec->data.blend);
+      break;
+
+    case META_COLOR_SPEC_SHADE:
+      if (spec->data.shade.base)
+        meta_color_spec_free (spec->data.shade.base);
+      DEBUG_FILL_STRUCT (&spec->data.shade);
+      break;
+    }
+
+  g_free (spec);
+}
+
+/**
+ * meta_color_spec_new_from_string: (skip)
+ *
+ */
+MetaColorSpec*
+meta_color_spec_new_from_string (const char *str,
+                                 GError    **err)
+{
+  MetaColorSpec *spec;
+
+  spec = NULL;
+  
+  if (strncmp (str, "gtk:custom", 10) == 0)
+    {
+      const char *color_name_start, *fallback_str_start, *end;
+      char *color_name;
+      MetaColorSpec *fallback = NULL;
+      static gboolean debug, debug_set = FALSE;
+
+      if (!debug_set)
+        {
+          debug = g_getenv ("MUTTER_DISABLE_FALLBACK_COLOR") != NULL;
+          debug_set = TRUE;
+        }
+
+      if (str[10] != '(')
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("GTK custom color specification must have color name and fallback in parentheses, e.g. gtk:custom(foo,bar); could not parse \"%s\""),
+                       str);
+          return NULL;
+        }
+
+      color_name_start = str + 11;
+
+      fallback_str_start = color_name_start;
+      while (*fallback_str_start && *fallback_str_start != ',')
+        {
+          if (!(g_ascii_isalnum (*fallback_str_start)
+                || *fallback_str_start == '-'
+                || *fallback_str_start == '_'))
+            {
+              g_set_error (err, META_THEME_ERROR,
+                           META_THEME_ERROR_FAILED,
+                           _("Invalid character '%c' in color_name parameter of gtk:custom, only A-Za-z0-9-_ are valid"),
+                           *fallback_str_start);
+              return NULL;
+            }
+          fallback_str_start++;
+        }
+      fallback_str_start++;
+
+      end = strrchr (str, ')');
+
+      if (color_name_start == NULL || fallback_str_start == NULL || end == NULL)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Gtk:custom format is \"gtk:custom(color_name,fallback)\", \"%s\" does not fit the format"),
+                       str);
+          return NULL;
+        }
+
+      if (!debug)
+        {
+          char *fallback_str;
+          fallback_str = g_strndup (fallback_str_start,
+                                    end - fallback_str_start);
+          fallback = meta_color_spec_new_from_string (fallback_str, err);
+          g_free (fallback_str);
+        }
+      else
+        {
+          fallback = meta_color_spec_new_from_string ("pink", err);
+        }
+
+      if (fallback == NULL)
+        return NULL;
+
+      color_name = g_strndup (color_name_start,
+                              fallback_str_start - color_name_start - 1);
+
+      spec = meta_color_spec_new (META_COLOR_SPEC_GTK_CUSTOM);
+      spec->data.gtkcustom.color_name = color_name;
+      spec->data.gtkcustom.fallback = fallback;
+    }
+  else if (strncmp (str, "gtk:", 4) == 0)
+    {
+      /* GTK color */
+      const char *bracket;
+      const char *end_bracket;
+      char *tmp;
+      GtkStateFlags state;
+      MetaGtkColorComponent component;
+
+      bracket = str;
+      while (*bracket && *bracket != '[')
+        ++bracket;
+
+      if (*bracket == '\0')
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("GTK color specification must have the state in brackets, e.g. gtk:fg[NORMAL] where NORMAL is the state; could not parse \"%s\""),
+                       str);
+          return NULL;
+        }
+
+      end_bracket = bracket;
+      ++end_bracket;
+      while (*end_bracket && *end_bracket != ']')
+        ++end_bracket;
+
+      if (*end_bracket == '\0')
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("GTK color specification must have a close bracket after the state, e.g. gtk:fg[NORMAL] where NORMAL is the state; could not parse \"%s\""),
+                       str);
+          return NULL;
+        }
+
+      tmp = g_strndup (bracket + 1, end_bracket - bracket - 1);
+      state = meta_gtk_state_from_string (tmp);
+      if (((int) state) == -1)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Did not understand state \"%s\" in color specification"),
+                       tmp);
+          g_free (tmp);
+          return NULL;
+        }
+      g_free (tmp);
+
+      tmp = g_strndup (str + 4, bracket - str - 4);
+      component = meta_color_component_from_string (tmp);
+      if (component == META_GTK_COLOR_LAST)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Did not understand color component \"%s\" in color specification"),
+                       tmp);
+          g_free (tmp);
+          return NULL;
+        }
+      g_free (tmp);
+
+      spec = meta_color_spec_new (META_COLOR_SPEC_GTK);
+      spec->data.gtk.state = state;
+      spec->data.gtk.component = component;
+      g_assert (spec->data.gtk.component < META_GTK_COLOR_LAST);
+    }
+  else if (strncmp (str, "blend/", 6) == 0)
+    {
+      /* blend */
+      char **split;
+      double alpha;
+      char *end;
+      MetaColorSpec *fg;
+      MetaColorSpec *bg;
+
+      split = g_strsplit (str, "/", 4);
+
+      if (split[0] == NULL || split[1] == NULL ||
+          split[2] == NULL || split[3] == NULL)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Blend format is \"blend/bg_color/fg_color/alpha\", \"%s\" does not fit the format"),
+                       str);
+          g_strfreev (split);
+          return NULL;
+        }
+
+      alpha = g_ascii_strtod (split[3], &end);
+      if (end == split[3])
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Could not parse alpha value \"%s\" in blended color"),
+                       split[3]);
+          g_strfreev (split);
+          return NULL;
+        }
+
+      if (alpha < (0.0 - 1e6) || alpha > (1.0 + 1e6))
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Alpha value \"%s\" in blended color is not between 0.0 and 1.0"),
+                       split[3]);
+          g_strfreev (split);
+          return NULL;
+        }
+
+      fg = NULL;
+      bg = NULL;
+
+      bg = meta_color_spec_new_from_string (split[1], err);
+      if (bg == NULL)
+        {
+          g_strfreev (split);
+          return NULL;
+        }
+
+      fg = meta_color_spec_new_from_string (split[2], err);
+      if (fg == NULL)
+        {
+          meta_color_spec_free (bg);
+          g_strfreev (split);
+          return NULL;
+        }
+
+      g_strfreev (split);
+
+      spec = meta_color_spec_new (META_COLOR_SPEC_BLEND);
+      spec->data.blend.alpha = alpha;
+      spec->data.blend.background = bg;
+      spec->data.blend.foreground = fg;
+    }
+  else if (strncmp (str, "shade/", 6) == 0)
+    {
+      /* shade */
+      char **split;
+      double factor;
+      char *end;
+      MetaColorSpec *base;
+
+      split = g_strsplit (str, "/", 3);
+
+      if (split[0] == NULL || split[1] == NULL ||
+          split[2] == NULL)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Shade format is \"shade/base_color/factor\", \"%s\" does not fit the format"),
+                       str);
+          g_strfreev (split);
+          return NULL;
+        }
+
+      factor = g_ascii_strtod (split[2], &end);
+      if (end == split[2])
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Could not parse shade factor \"%s\" in shaded color"),
+                       split[2]);
+          g_strfreev (split);
+          return NULL;
+        }
+
+      if (factor < (0.0 - 1e6))
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Shade factor \"%s\" in shaded color is negative"),
+                       split[2]);
+          g_strfreev (split);
+          return NULL;
+        }
+
+      base = NULL;
+
+      base = meta_color_spec_new_from_string (split[1], err);
+      if (base == NULL)
+        {
+          g_strfreev (split);
+          return NULL;
+        }
+
+      g_strfreev (split);
+
+      spec = meta_color_spec_new (META_COLOR_SPEC_SHADE);
+      spec->data.shade.factor = factor;
+      spec->data.shade.base = base;
+    }
+  else
+    {
+      spec = meta_color_spec_new (META_COLOR_SPEC_BASIC);
+
+      if (!gdk_rgba_parse (&spec->data.basic.color, str))
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Could not parse color \"%s\""),
+                       str);
+          meta_color_spec_free (spec);
+          return NULL;
+        }
+    }
+
+  g_assert (spec);
+
+  return spec;
+}
+
+/**
+ * meta_color_spec_new_gtk: (skip)
+ *
+ */
+MetaColorSpec*
+meta_color_spec_new_gtk (MetaGtkColorComponent component,
+                         GtkStateFlags         state)
+{
+  MetaColorSpec *spec;
+
+  spec = meta_color_spec_new (META_COLOR_SPEC_GTK);
+
+  spec->data.gtk.component = component;
+  spec->data.gtk.state = state;
+
+  return spec;
+}
+
+/* Based on set_color() in gtkstyle.c */
+#define LIGHTNESS_MULT 1.3
+#define DARKNESS_MULT  0.7
+void
+meta_gtk_style_get_light_color (GtkStyleContext *style,
+                                GtkStateFlags    state,
+                                GdkRGBA         *color)
+{
+  gtk_style_context_get_background_color (style, state, color);
+  gtk_style_shade (color, color, LIGHTNESS_MULT);
+}
+
+void
+meta_gtk_style_get_dark_color (GtkStyleContext *style,
+                               GtkStateFlags    state,
+                               GdkRGBA         *color)
+{
+  gtk_style_context_get_background_color (style, state, color);
+  gtk_style_shade (color, color, DARKNESS_MULT);
+}
+
+static void
+meta_set_color_from_style (GdkRGBA               *color,
+                           GtkStyleContext       *context,
+                           GtkStateFlags          state,
+                           MetaGtkColorComponent  component)
+{
+  GdkRGBA other;
+
+  switch (component)
+    {
+    case META_GTK_COLOR_BG:
+    case META_GTK_COLOR_BASE:
+      gtk_style_context_get_background_color (context, state, color);
+      break;
+    case META_GTK_COLOR_FG:
+    case META_GTK_COLOR_TEXT:
+      gtk_style_context_get_color (context, state, color);
+      break;
+    case META_GTK_COLOR_TEXT_AA:
+      gtk_style_context_get_color (context, state, color);
+      meta_set_color_from_style (&other, context, state, META_GTK_COLOR_BASE);
+
+      color->red = (color->red + other.red) / 2;
+      color->green = (color->green + other.green) / 2;
+      color->blue = (color->blue + other.blue) / 2;
+      break;
+    case META_GTK_COLOR_MID:
+      meta_gtk_style_get_light_color (context, state, color);
+      meta_gtk_style_get_dark_color (context, state, &other);
+
+      color->red = (color->red + other.red) / 2;
+      color->green = (color->green + other.green) / 2;
+      color->blue = (color->blue + other.blue) / 2;
+      break;
+    case META_GTK_COLOR_LIGHT:
+      meta_gtk_style_get_light_color (context, state, color);
+      break;
+    case META_GTK_COLOR_DARK:
+      meta_gtk_style_get_dark_color (context, state, color);
+      break;
+    case META_GTK_COLOR_LAST:
+      g_assert_not_reached ();
+      break;
+    }
+}
+
+static void
+meta_set_custom_color_from_style (GdkRGBA         *color,
+                                  GtkStyleContext *context,
+                                  char            *color_name,
+                                  MetaColorSpec   *fallback)
+{
+  if (!gtk_style_context_lookup_color (context, color_name, color))
+    meta_color_spec_render (fallback, context, color);
+}
+
+void
+meta_color_spec_render (MetaColorSpec   *spec,
+                        GtkStyleContext *context,
+                        GdkRGBA         *color)
+{
+  g_return_if_fail (spec != NULL);
+  g_return_if_fail (GTK_IS_STYLE_CONTEXT (context));
+
+  switch (spec->type)
+    {
+    case META_COLOR_SPEC_BASIC:
+      *color = spec->data.basic.color;
+      break;
+
+    case META_COLOR_SPEC_GTK:
+      meta_set_color_from_style (color,
+                                 context,
+                                 spec->data.gtk.state,
+                                 spec->data.gtk.component);
+      break;
+
+    case META_COLOR_SPEC_GTK_CUSTOM:
+      meta_set_custom_color_from_style (color,
+                                        context,
+                                        spec->data.gtkcustom.color_name,
+                                        spec->data.gtkcustom.fallback);
+      break;
+
+    case META_COLOR_SPEC_BLEND:
+      {
+        GdkRGBA bg, fg;
+
+        meta_color_spec_render (spec->data.blend.background, context, &bg);
+        meta_color_spec_render (spec->data.blend.foreground, context, &fg);
+
+        color_composite (&bg, &fg, spec->data.blend.alpha,
+                         &spec->data.blend.color);
+
+        *color = spec->data.blend.color;
+      }
+      break;
+
+    case META_COLOR_SPEC_SHADE:
+      {
+        meta_color_spec_render (spec->data.shade.base, context,
+                                &spec->data.shade.color);
+
+        gtk_style_shade (&spec->data.shade.color,
+                         &spec->data.shade.color, spec->data.shade.factor);
+
+        *color = spec->data.shade.color;
+      }
+      break;
+    }
+}
+
+/**
+ * op_name:
+ * @type: an operation, such as addition
+ *
+ * Represents an operation as a string.
+ *
+ * Returns: a string, such as "+"
+ */
+static const char*
+op_name (PosOperatorType type)
+{
+  switch (type)
+    {
+    case POS_OP_ADD:
+      return "+";
+    case POS_OP_SUBTRACT:
+      return "-";
+    case POS_OP_MULTIPLY:
+      return "*";
+    case POS_OP_DIVIDE:
+      return "/";
+    case POS_OP_MOD:
+      return "%";
+    case POS_OP_MAX:
+      return "`max`";
+    case POS_OP_MIN:
+      return "`min`";
+    case POS_OP_NONE:
+      break;
+    }
+
+  return "<unknown>";
+}
+
+/**
+ * op_from_string:
+ * @p: a pointer into a string representing an operation; part of an
+ *     expression somewhere, so not null-terminated
+ * @len: set to the length of the string found. Set to 0 if none is.
+ *
+ * Parses a string and returns an operation.
+ *
+ * Returns: the operation found. If none was, returns %POS_OP_NONE.
+ */
+static PosOperatorType
+op_from_string (const char *p,
+                int        *len)
+{
+  *len = 0;
+
+  switch (*p)
+    {
+    case '+':
+      *len = 1;
+      return POS_OP_ADD;
+    case '-':
+      *len = 1;
+      return POS_OP_SUBTRACT;
+    case '*':
+      *len = 1;
+      return POS_OP_MULTIPLY;
+    case '/':
+      *len = 1;
+      return POS_OP_DIVIDE;
+    case '%':
+      *len = 1;
+      return POS_OP_MOD;
+
+    case '`':
+      if (strncmp (p, "`max`", 5) == 0)
+        {
+          *len = 5;
+          return POS_OP_MAX;
+        }
+      else if (strncmp (p, "`min`", 5) == 0)
+        {
+          *len = 5;
+          return POS_OP_MIN;
+        }
+    }
+
+  return POS_OP_NONE;
+}
+
+/**
+ * free_tokens:
+ * @tokens: an array of tokens to be freed
+ * @n_tokens: how many tokens are in the array.
+ *
+ * Frees an array of tokens. All the tokens and their associated memory
+ * will be freed.
+ */
+static void
+free_tokens (PosToken *tokens,
+             int       n_tokens)
+{
+  int i;
+
+  /* n_tokens can be 0 since tokens may have been allocated more than
+   * it was initialized
+   */
+
+  for (i = 0; i < n_tokens; i++)
+    if (tokens[i].type == POS_TOKEN_VARIABLE)
+      g_free (tokens[i].d.v.name);
+
+  g_free (tokens);
+}
+
+/**
+ * parse_number:
+ * @p: a pointer into a string representing an operation; part of an
+ *           expression somewhere, so not null-terminated
+ * @end_return: set to a pointer to the end of the number found; but
+ *                    not updated if no number was found at all
+ * @next: set to either an integer or a float token
+ * @err: (out): set to the problem if there was a problem
+ *
+ * Tokenises a number in an expression.
+ *
+ * FIXME: The "while (*start)..." part: what's wrong with strchr-ish things?
+ * FIXME: The name is wrong: it doesn't parse anything.
+ *
+ * Returns: %TRUE if a valid number was found, FALSE otherwise (and "err" will
+ *         have been set)
+ */
+static gboolean
+parse_number (const char  *p,
+              const char **end_return,
+              PosToken    *next,
+              GError     **err)
+{
+  const char *start = p;
+  char *end;
+  gboolean is_float;
+  char *num_str;
+
+  while (*p && (*p == '.' || g_ascii_isdigit (*p)))
+    ++p;
+
+  if (p == start)
+    {
+      char buf[7] = { '\0' };
+      buf[g_unichar_to_utf8 (g_utf8_get_char (p), buf)] = '\0';
+      g_set_error (err, META_THEME_ERROR,
+                   META_THEME_ERROR_BAD_CHARACTER,
+                   _("Coordinate expression contains character '%s' which is not allowed"),
+                   buf);
+      return FALSE;
+    }
+
+  *end_return = p;
+
+  /* we need this to exclude floats like "1e6" */
+  num_str = g_strndup (start, p - start);
+  start = num_str;
+  is_float = FALSE;
+  while (*start)
+    {
+      if (*start == '.')
+        is_float = TRUE;
+      ++start;
+    }
+
+  if (is_float)
+    {
+      next->type = POS_TOKEN_DOUBLE;
+      next->d.d.val = g_ascii_strtod (num_str, &end);
+
+      if (end == num_str)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Coordinate expression contains floating point number '%s' which could not be parsed"),
+                       num_str);
+          g_free (num_str);
+          return FALSE;
+        }
+    }
+  else
+    {
+      next->type = POS_TOKEN_INT;
+      next->d.i.val = strtol (num_str, &end, 10);
+      if (end == num_str)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Coordinate expression contains integer '%s' which could not be parsed"),
+                       num_str);
+          g_free (num_str);
+          return FALSE;
+        }
+    }
+
+  g_free (num_str);
+
+  g_assert (next->type == POS_TOKEN_INT || next->type == POS_TOKEN_DOUBLE);
+
+  return TRUE;
+}
+
+/*
+ * Whether a variable can validly appear as part of the name of a variable.
+ */
+#define IS_VARIABLE_CHAR(c) (g_ascii_isalpha ((c)) || (c) == '_')
+
+#if 0
+static void
+debug_print_tokens (PosToken *tokens,
+                    int       n_tokens)
+{
+  int i;
+
+  for (i = 0; i < n_tokens; i++)
+    {
+      PosToken *t = &tokens[i];
+
+      g_print (" ");
+
+      switch (t->type)
+        {
+        case POS_TOKEN_INT:
+          g_print ("\"%d\"", t->d.i.val);
+          break;
+        case POS_TOKEN_DOUBLE:
+          g_print ("\"%g\"", t->d.d.val);
+          break;
+        case POS_TOKEN_OPEN_PAREN:
+          g_print ("\"(\"");
+          break;
+        case POS_TOKEN_CLOSE_PAREN:
+          g_print ("\")\"");
+          break;
+        case POS_TOKEN_VARIABLE:
+          g_print ("\"%s\"", t->d.v.name);
+          break;
+        case POS_TOKEN_OPERATOR:
+          g_print ("\"%s\"", op_name (t->d.o.op));
+          break;
+        }
+    }
+
+  g_print ("\n");
+}
+#endif
+
+/**
+ * pos_tokenize:
+ * @expr: The expression
+ * @tokens_p: (out): The resulting tokens
+ * @n_tokens_p: (out): The number of resulting tokens
+ * @err: (out):  set to the problem if there was a problem
+
+ * Tokenises an expression.
+ *
+ * Returns: %TRUE if the expression was successfully tokenised; %FALSE otherwise.
+ */
+static gboolean
+pos_tokenize (const char  *expr,
+              PosToken   **tokens_p,
+              int         *n_tokens_p,
+              GError     **err)
+{
+  PosToken *tokens;
+  int n_tokens;
+  int allocated;
+  const char *p;
+
+  *tokens_p = NULL;
+  *n_tokens_p = 0;
+
+  allocated = 3;
+  n_tokens = 0;
+  tokens = g_new (PosToken, allocated);
+
+  p = expr;
+  while (*p)
+    {
+      PosToken *next;
+      int len;
+
+      if (n_tokens == allocated)
+        {
+          allocated *= 2;
+          tokens = g_renew (PosToken, tokens, allocated);
+        }
+
+      next = &tokens[n_tokens];
+
+      switch (*p)
+        {
+        case '*':
+        case '/':
+        case '+':
+        case '-': /* negative numbers aren't allowed so this is easy */
+        case '%':
+        case '`':
+          next->type = POS_TOKEN_OPERATOR;
+          next->d.o.op = op_from_string (p, &len);
+          if (next->d.o.op != POS_OP_NONE)
+            {
+              ++n_tokens;
+              p = p + (len - 1); /* -1 since we ++p later */
+            }
+          else
+            {
+              g_set_error (err, META_THEME_ERROR,
+                           META_THEME_ERROR_FAILED,
+                           _("Coordinate expression contained unknown operator at the start of this text: \"%s\""),
+                           p);
+
+              goto error;
+            }
+          break;
+
+        case '(':
+          next->type = POS_TOKEN_OPEN_PAREN;
+          ++n_tokens;
+          break;
+
+        case ')':
+          next->type = POS_TOKEN_CLOSE_PAREN;
+          ++n_tokens;
+          break;
+
+        case ' ':
+        case '\t':
+        case '\n':
+          break;
+
+        default:
+          if (IS_VARIABLE_CHAR (*p))
+            {
+              /* Assume variable */
+              const char *start = p;
+              while (*p && IS_VARIABLE_CHAR (*p))
+                ++p;
+              g_assert (p != start);
+              next->type = POS_TOKEN_VARIABLE;
+              next->d.v.name = g_strndup (start, p - start);
+              ++n_tokens;
+              --p; /* since we ++p again at the end of while loop */
+            }
+          else
+            {
+              /* Assume number */
+              const char *end;
+
+              if (!parse_number (p, &end, next, err))
+                goto error;
+
+              ++n_tokens;
+              p = end - 1; /* -1 since we ++p again at the end of while loop */
+            }
+
+          break;
+        }
+
+      ++p;
+    }
+
+  if (n_tokens == 0)
+    {
+      g_set_error (err, META_THEME_ERROR,
+                   META_THEME_ERROR_FAILED,
+                   _("Coordinate expression was empty or not understood"));
+
+      goto error;
+    }
+
+  *tokens_p = tokens;
+  *n_tokens_p = n_tokens;
+
+  return TRUE;
+
+ error:
+  g_assert (err == NULL || *err != NULL);
+
+  free_tokens (tokens, n_tokens);
+  return FALSE;
+}
+
+/**
+ * PosExprType:
+ *
+ * The type of a PosExpr: either integer, double, or an operation.
+ */
+typedef enum
+{
+  POS_EXPR_INT,
+  POS_EXPR_DOUBLE,
+  POS_EXPR_OPERATOR
+} PosExprType;
+
+/**
+ * PosExpr:
+ *
+ * Type and value of an expression in a parsed sequence. We don't
+ * keep expressions in a tree; if this is of type %POS_EXPR_OPERATOR,
+ * the arguments of the operator will be in the array positions
+ * immediately preceding and following this operator; they cannot
+ * themselves be operators.
+ *
+ * FIXME: operator is #gchar; it should really be of #PosOperatorType.
+ */
+typedef struct
+{
+  PosExprType type;
+  union
+  {
+    double double_val;
+    int int_val;
+    char operator;
+  } d;
+} PosExpr;
+
+#if 0
+static void
+debug_print_exprs (PosExpr *exprs,
+                   int      n_exprs)
+{
+  int i;
+
+  for (i = 0; i < n_exprs; i++)
+    {
+      switch (exprs[i].type)
+        {
+        case POS_EXPR_INT:
+          g_print (" %d", exprs[i].d.int_val);
+          break;
+        case POS_EXPR_DOUBLE:
+          g_print (" %g", exprs[i].d.double_val);
+          break;
+        case POS_EXPR_OPERATOR:
+          g_print (" %s", op_name (exprs[i].d.operator));
+          break;
+        }
+    }
+  g_print ("\n");
+}
+#endif
+
+static gboolean
+do_operation (PosExpr *a,
+              PosExpr *b,
+              PosOperatorType op,
+              GError **err)
+{
+  /* Promote types to double if required */
+  if (a->type == POS_EXPR_DOUBLE ||
+      b->type == POS_EXPR_DOUBLE)
+    {
+      if (a->type != POS_EXPR_DOUBLE)
+        {
+          a->type = POS_EXPR_DOUBLE;
+          a->d.double_val = a->d.int_val;
+        }
+      if (b->type != POS_EXPR_DOUBLE)
+        {
+          b->type = POS_EXPR_DOUBLE;
+          b->d.double_val = b->d.int_val;
+        }
+    }
+
+  g_assert (a->type == b->type);
+
+  if (a->type == POS_EXPR_INT)
+    {
+      switch (op)
+        {
+        case POS_OP_MULTIPLY:
+          a->d.int_val = a->d.int_val * b->d.int_val;
+          break;
+        case POS_OP_DIVIDE:
+          if (b->d.int_val == 0)
+            {
+              g_set_error (err, META_THEME_ERROR,
+                           META_THEME_ERROR_DIVIDE_BY_ZERO,
+                           _("Coordinate expression results in division by zero"));
+              return FALSE;
+            }
+          a->d.int_val = a->d.int_val / b->d.int_val;
+          break;
+        case POS_OP_MOD:
+          if (b->d.int_val == 0)
+            {
+              g_set_error (err, META_THEME_ERROR,
+                           META_THEME_ERROR_DIVIDE_BY_ZERO,
+                           _("Coordinate expression results in division by zero"));
+              return FALSE;
+            }
+          a->d.int_val = a->d.int_val % b->d.int_val;
+          break;
+        case POS_OP_ADD:
+          a->d.int_val = a->d.int_val + b->d.int_val;
+          break;
+        case POS_OP_SUBTRACT:
+          a->d.int_val = a->d.int_val - b->d.int_val;
+          break;
+        case POS_OP_MAX:
+          a->d.int_val = MAX (a->d.int_val, b->d.int_val);
+          break;
+        case POS_OP_MIN:
+          a->d.int_val = MIN (a->d.int_val, b->d.int_val);
+          break;
+        case POS_OP_NONE:
+          g_assert_not_reached ();
+          break;
+        }
+    }
+  else if (a->type == POS_EXPR_DOUBLE)
+    {
+      switch (op)
+        {
+        case POS_OP_MULTIPLY:
+          a->d.double_val = a->d.double_val * b->d.double_val;
+          break;
+        case POS_OP_DIVIDE:
+          if (b->d.double_val == 0.0)
+            {
+              g_set_error (err, META_THEME_ERROR,
+                           META_THEME_ERROR_DIVIDE_BY_ZERO,
+                           _("Coordinate expression results in division by zero"));
+              return FALSE;
+            }
+          a->d.double_val = a->d.double_val / b->d.double_val;
+          break;
+        case POS_OP_MOD:
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_MOD_ON_FLOAT,
+                       _("Coordinate expression tries to use mod operator on a floating-point number"));
+          return FALSE;
+        case POS_OP_ADD:
+          a->d.double_val = a->d.double_val + b->d.double_val;
+          break;
+        case POS_OP_SUBTRACT:
+          a->d.double_val = a->d.double_val - b->d.double_val;
+          break;
+        case POS_OP_MAX:
+          a->d.double_val = MAX (a->d.double_val, b->d.double_val);
+          break;
+        case POS_OP_MIN:
+          a->d.double_val = MIN (a->d.double_val, b->d.double_val);
+          break;
+        case POS_OP_NONE:
+          g_assert_not_reached ();
+          break;
+        }
+    }
+  else
+    g_assert_not_reached ();
+
+  return TRUE;
+}
+
+static gboolean
+do_operations (PosExpr *exprs,
+               int     *n_exprs,
+               int      precedence,
+               GError **err)
+{
+  int i;
+
+#if 0
+  g_print ("Doing prec %d ops on %d exprs\n", precedence, *n_exprs);
+  debug_print_exprs (exprs, *n_exprs);
+#endif
+
+  i = 1;
+  while (i < *n_exprs)
+    {
+      gboolean compress;
+
+      /* exprs[i-1] first operand
+       * exprs[i]   operator
+       * exprs[i+1] second operand
+       *
+       * we replace first operand with result of mul/div/mod,
+       * or skip over operator and second operand if we have
+       * an add/subtract
+       */
+
+      if (exprs[i-1].type == POS_EXPR_OPERATOR)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Coordinate expression has an operator \"%s\" where an operand was expected"),
+                       op_name (exprs[i-1].d.operator));
+          return FALSE;
+        }
+
+      if (exprs[i].type != POS_EXPR_OPERATOR)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Coordinate expression had an operand where an operator was expected"));
+          return FALSE;
+        }
+
+      if (i == (*n_exprs - 1))
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Coordinate expression ended with an operator instead of an operand"));
+          return FALSE;
+        }
+
+      g_assert ((i+1) < *n_exprs);
+
+      if (exprs[i+1].type == POS_EXPR_OPERATOR)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Coordinate expression has operator \"%c\" following operator \"%c\" with no operand in between"),
+                       exprs[i+1].d.operator,
+                       exprs[i].d.operator);
+          return FALSE;
+        }
+
+      compress = FALSE;
+
+      switch (precedence)
+        {
+        case 2:
+          switch (exprs[i].d.operator)
+            {
+            case POS_OP_DIVIDE:
+            case POS_OP_MOD:
+            case POS_OP_MULTIPLY:
+              compress = TRUE;
+              if (!do_operation (&exprs[i-1], &exprs[i+1],
+                                 exprs[i].d.operator,
+                                 err))
+                return FALSE;
+              break;
+            }
+          break;
+        case 1:
+          switch (exprs[i].d.operator)
+            {
+            case POS_OP_ADD:
+            case POS_OP_SUBTRACT:
+              compress = TRUE;
+              if (!do_operation (&exprs[i-1], &exprs[i+1],
+                                 exprs[i].d.operator,
+                                 err))
+                return FALSE;
+              break;
+            }
+          break;
+          /* I have no rationale at all for making these low-precedence */
+        case 0:
+          switch (exprs[i].d.operator)
+            {
+            case POS_OP_MAX:
+            case POS_OP_MIN:
+              compress = TRUE;
+              if (!do_operation (&exprs[i-1], &exprs[i+1],
+                                 exprs[i].d.operator,
+                                 err))
+                return FALSE;
+              break;
+            }
+          break;
+        }
+
+      if (compress)
+        {
+          /* exprs[i-1] first operand (now result)
+           * exprs[i]   operator
+           * exprs[i+1] second operand
+           * exprs[i+2] new operator
+           *
+           * we move new operator just after first operand
+           */
+          if ((i+2) < *n_exprs)
+            {
+              g_memmove (&exprs[i], &exprs[i+2],
+                         sizeof (PosExpr) * (*n_exprs - i - 2));
+            }
+
+          *n_exprs -= 2;
+        }
+      else
+        {
+          /* Skip operator and next operand */
+          i += 2;
+        }
+    }
+
+  return TRUE;
+}
+
+/**
+ * pos_eval_get_variable:
+ * @t: The token representing a variable
+ * @result: (out): The value of that variable; not set if the token did
+ *                 not represent a known variable
+ * @env: The environment within which t should be evaluated
+ * @err: (out): set to the problem if there was a problem
+ *
+ * There is a predefined set of variables which can appear in an expression.
+ * Here we take a token representing a variable, and return the current value
+ * of that variable in a particular environment.
+ * (The value is always an integer.)
+ *
+ * There are supposedly some circumstances in which this function can be
+ * called from outside Metacity, in which case env->theme will be %NULL, and
+ * therefore we can't use it to find out quark values, so we do the comparison
+ * using strcmp(), which is slower.
+ *
+ * FIXME: shouldn't @t be const?
+ * FIXME: we should perhaps consider some sort of lookup arrangement into an
+ *        array; also, the duplication of code is unlovely; perhaps using glib
+ *        string hashes instead of quarks would fix both problems?
+ *
+ * Returns: %TRUE if we found the variable asked for, %FALSE if we didn't
+ */
+static gboolean
+pos_eval_get_variable (PosToken                  *t,
+                       int                       *result,
+                       const MetaPositionExprEnv *env,
+                       GError                   **err)
+{
+  if (env->theme)
+    {
+      if (t->d.v.name_quark == env->theme->quark_width)
+        *result = env->rect.width;
+      else if (t->d.v.name_quark == env->theme->quark_height)
+        *result = env->rect.height;
+      else if (env->object_width >= 0 &&
+               t->d.v.name_quark == env->theme->quark_object_width)
+        *result = env->object_width;
+      else if (env->object_height >= 0 &&
+               t->d.v.name_quark == env->theme->quark_object_height)
+        *result = env->object_height;
+      else if (t->d.v.name_quark == env->theme->quark_left_width)
+        *result = env->left_width;
+      else if (t->d.v.name_quark == env->theme->quark_right_width)
+        *result = env->right_width;
+      else if (t->d.v.name_quark == env->theme->quark_top_height)
+        *result = env->top_height;
+      else if (t->d.v.name_quark == env->theme->quark_bottom_height)
+        *result = env->bottom_height;
+      else if (t->d.v.name_quark == env->theme->quark_mini_icon_width)
+        *result = env->mini_icon_width;
+      else if (t->d.v.name_quark == env->theme->quark_mini_icon_height)
+        *result = env->mini_icon_height;
+      else if (t->d.v.name_quark == env->theme->quark_icon_width)
+        *result = env->icon_width;
+      else if (t->d.v.name_quark == env->theme->quark_icon_height)
+        *result = env->icon_height;
+      else if (t->d.v.name_quark == env->theme->quark_title_width)
+        *result = env->title_width;
+      else if (t->d.v.name_quark == env->theme->quark_title_height)
+        *result = env->title_height;
+      else if (t->d.v.name_quark == env->theme->quark_frame_x_center)
+        *result = env->frame_x_center;
+      else if (t->d.v.name_quark == env->theme->quark_frame_y_center)
+        *result = env->frame_y_center;
+      else
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_UNKNOWN_VARIABLE,
+                       _("Coordinate expression had unknown variable or constant \"%s\""),
+                       t->d.v.name);
+          return FALSE;
+        }
+    }
+  else
+    {
+      if (strcmp (t->d.v.name, "width") == 0)
+        *result = env->rect.width;
+      else if (strcmp (t->d.v.name, "height") == 0)
+        *result = env->rect.height;
+      else if (env->object_width >= 0 &&
+               strcmp (t->d.v.name, "object_width") == 0)
+        *result = env->object_width;
+      else if (env->object_height >= 0 &&
+               strcmp (t->d.v.name, "object_height") == 0)
+        *result = env->object_height;
+      else if (strcmp (t->d.v.name, "left_width") == 0)
+        *result = env->left_width;
+      else if (strcmp (t->d.v.name, "right_width") == 0)
+        *result = env->right_width;
+      else if (strcmp (t->d.v.name, "top_height") == 0)
+        *result = env->top_height;
+      else if (strcmp (t->d.v.name, "bottom_height") == 0)
+        *result = env->bottom_height;
+      else if (strcmp (t->d.v.name, "mini_icon_width") == 0)
+        *result = env->mini_icon_width;
+      else if (strcmp (t->d.v.name, "mini_icon_height") == 0)
+        *result = env->mini_icon_height;
+      else if (strcmp (t->d.v.name, "icon_width") == 0)
+        *result = env->icon_width;
+      else if (strcmp (t->d.v.name, "icon_height") == 0)
+        *result = env->icon_height;
+      else if (strcmp (t->d.v.name, "title_width") == 0)
+        *result = env->title_width;
+      else if (strcmp (t->d.v.name, "title_height") == 0)
+        *result = env->title_height;
+      else if (strcmp (t->d.v.name, "frame_x_center") == 0)
+        *result = env->frame_x_center;
+      else if (strcmp (t->d.v.name, "frame_y_center") == 0)
+        *result = env->frame_y_center;
+      else
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_UNKNOWN_VARIABLE,
+                       _("Coordinate expression had unknown variable or constant \"%s\""),
+                       t->d.v.name);
+          return FALSE;
+        }
+    }
+
+  return TRUE;
+}
+
+/**
+ * pos_eval_helper:
+ * @tokens: A list of tokens to evaluate.
+ * @n_tokens: How many tokens are in the list.
+ * @env: The environment context in which to evaluate the expression.
+ * @result: (out): The current value of the expression
+ *
+ * Evaluates a sequence of tokens within a particular environment context,
+ * and returns the current value. May recur if parantheses are found.
+ *
+ * FIXME: Yes, we really do reparse the expression every time it's evaluated.
+ *        We should keep the parse tree around all the time and just
+ *        run the new values through it.
+ */
+static gboolean
+pos_eval_helper (PosToken                   *tokens,
+                 int                         n_tokens,
+                 const MetaPositionExprEnv  *env,
+                 PosExpr                    *result,
+                 GError                    **err)
+{
+  /* Lazy-ass hardcoded limit on number of terms in expression */
+#define MAX_EXPRS 32
+  int paren_level;
+  int first_paren;
+  int i;
+  PosExpr exprs[MAX_EXPRS];
+  int n_exprs;
+  int precedence;
+
+  /* Our first goal is to get a list of PosExpr, essentially
+   * substituting variables and handling parentheses.
+   */
+
+  first_paren = 0;
+  paren_level = 0;
+  n_exprs = 0;
+  for (i = 0; i < n_tokens; i++)
+    {
+      PosToken *t = &tokens[i];
+
+      if (n_exprs >= MAX_EXPRS)
+        {
+          g_set_error (err, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Coordinate expression parser overflowed its buffer."));
+          return FALSE;
+        }
+
+      if (paren_level == 0)
+        {
+          switch (t->type)
+            {
+            case POS_TOKEN_INT:
+              exprs[n_exprs].type = POS_EXPR_INT;
+              exprs[n_exprs].d.int_val = t->d.i.val;
+              ++n_exprs;
+              break;
+
+            case POS_TOKEN_DOUBLE:
+              exprs[n_exprs].type = POS_EXPR_DOUBLE;
+              exprs[n_exprs].d.double_val = t->d.d.val;
+              ++n_exprs;
+              break;
+
+            case POS_TOKEN_OPEN_PAREN:
+              ++paren_level;
+              if (paren_level == 1)
+                first_paren = i;
+              break;
+
+            case POS_TOKEN_CLOSE_PAREN:
+              g_set_error (err, META_THEME_ERROR,
+                           META_THEME_ERROR_BAD_PARENS,
+                           _("Coordinate expression had a close parenthesis with no open parenthesis"));
+              return FALSE;
+
+            case POS_TOKEN_VARIABLE:
+              exprs[n_exprs].type = POS_EXPR_INT;
+
+              /* FIXME we should just dump all this crap
+               * in a hash, maybe keep width/height out
+               * for optimization purposes
+               */
+              if (!pos_eval_get_variable (t, &exprs[n_exprs].d.int_val, env, err))
+                return FALSE;
+
+              ++n_exprs;
+              break;
+
+            case POS_TOKEN_OPERATOR:
+              exprs[n_exprs].type = POS_EXPR_OPERATOR;
+              exprs[n_exprs].d.operator = t->d.o.op;
+              ++n_exprs;
+              break;
+            }
+        }
+      else
+        {
+          g_assert (paren_level > 0);
+
+          switch (t->type)
+            {
+            case POS_TOKEN_INT:
+            case POS_TOKEN_DOUBLE:
+            case POS_TOKEN_VARIABLE:
+            case POS_TOKEN_OPERATOR:
+              break;
+
+            case POS_TOKEN_OPEN_PAREN:
+              ++paren_level;
+              break;
+
+            case POS_TOKEN_CLOSE_PAREN:
+              if (paren_level == 1)
+                {
+                  /* We closed a toplevel paren group, so recurse */
+                  if (!pos_eval_helper (&tokens[first_paren+1],
+                                        i - first_paren - 1,
+                                        env,
+                                        &exprs[n_exprs],
+                                        err))
+                    return FALSE;
+
+                  ++n_exprs;
+                }
+
+              --paren_level;
+              break;
+
+            }
+        }
+    }
+
+  if (paren_level > 0)
+    {
+      g_set_error (err, META_THEME_ERROR,
+                   META_THEME_ERROR_BAD_PARENS,
+                   _("Coordinate expression had an open parenthesis with no close parenthesis"));
+      return FALSE;
+    }
+
+  /* Now we have no parens and no vars; so we just do all the multiplies
+   * and divides, then all the add and subtract.
+   */
+  if (n_exprs == 0)
+    {
+      g_set_error (err, META_THEME_ERROR,
+                   META_THEME_ERROR_FAILED,
+                   _("Coordinate expression doesn't seem to have any operators or operands"));
+      return FALSE;
+    }
+
+  /* precedence 1 ops */
+  precedence = 2;
+  while (precedence >= 0)
+    {
+      if (!do_operations (exprs, &n_exprs, precedence, err))
+        return FALSE;
+      --precedence;
+    }
+
+  g_assert (n_exprs == 1);
+
+  *result = *exprs;
+
+  return TRUE;
+}
+
+/*
+ *   expr = int | double | expr * expr | expr / expr |
+ *          expr + expr | expr - expr | (expr)
+ *
+ *   so very not worth fooling with bison, yet so very painful by hand.
+ */
+
+/**
+ * pos_eval:
+ * @spec: The expression to evaluate.
+ * @env: The environment context to evaluate the expression in.
+ * @val_p: (out): The integer value of the expression; if the expression
+ *                 is of type float, this will be rounded. If we return
+ *                 %FALSE because the expression is invalid, this will be
+ *                 zero.
+ * @err: (out): The error, if anything went wrong.
+ *
+ * Evaluates an expression.
+ *
+ * FIXME: Shouldn't @spec be const?
+ *
+ * Returns: %TRUE if we evaluated the expression successfully; %FALSE otherwise.
+ */
+static gboolean
+pos_eval (MetaDrawSpec              *spec,
+          const MetaPositionExprEnv *env,
+          int                       *val_p,
+          GError                   **err)
+{
+  PosExpr expr;
+
+  *val_p = 0;
+
+  if (pos_eval_helper (spec->tokens, spec->n_tokens, env, &expr, err))
+    {
+      switch (expr.type)
+        {
+        case POS_EXPR_INT:
+          *val_p = expr.d.int_val;
+          break;
+        case POS_EXPR_DOUBLE:
+          *val_p = expr.d.double_val;
+          break;
+        case POS_EXPR_OPERATOR:
+          g_assert_not_reached ();
+          break;
+        }
+      return TRUE;
+    }
+  else
+    {
+      return FALSE;
+    }
+}
+
+/* We always return both X and Y, but only one will be meaningful in
+ * most contexts.
+ */
+
+/**
+ * meta_parse_position_expression: (skip)
+ *
+ */
+gboolean
+meta_parse_position_expression (MetaDrawSpec              *spec,
+                                const MetaPositionExprEnv *env,
+                                int                       *x_return,
+                                int                       *y_return,
+                                GError                   **err)
+{
+  /* All positions are in a coordinate system with x, y at the origin.
+   * The expression can have -, +, *, / as operators, floating point
+   * or integer constants, and the variables "width" and "height" and
+   * optionally "object_width" and object_height". Negative numbers
+   * aren't allowed.
+   */
+  int val;
+
+  if (spec->constant)
+    val = spec->value;
+  else
+    {
+      if (pos_eval (spec, env, &spec->value, err) == FALSE)
+        {
+          g_assert (err == NULL || *err != NULL);
+          return FALSE;
+        }
+
+      val = spec->value;
+    }
+
+  if (x_return)
+    *x_return = env->rect.x + val;
+  if (y_return)
+    *y_return = env->rect.y + val;
+
+  return TRUE;
+}
+
+
+/**
+ * meta_parse_size_expression: (skip)
+ *
+ */
+gboolean
+meta_parse_size_expression (MetaDrawSpec              *spec,
+                            const MetaPositionExprEnv *env,
+                            int                       *val_return,
+                            GError                   **err)
+{
+  int val;
+
+  if (spec->constant)
+    val = spec->value;
+  else
+    {
+      if (pos_eval (spec, env, &spec->value, err) == FALSE)
+        {
+          g_assert (err == NULL || *err != NULL);
+          return FALSE;
+        }
+
+      val = spec->value;
+    }
+
+  if (val_return)
+    *val_return = MAX (val, 1); /* require that sizes be at least 1x1 */
+
+  return TRUE;
+}
+
+/* To do this we tokenize, replace variable tokens
+ * that are constants, then reassemble. The purpose
+ * here is to optimize expressions so we don't do hash
+ * lookups to eval them. Obviously it's a tradeoff that
+ * slows down theme load times.
+ */
+gboolean
+meta_theme_replace_constants (MetaTheme   *theme,
+                              PosToken    *tokens,
+                              int          n_tokens,
+                              GError     **err)
+{
+  int i;
+  double dval;
+  int ival;
+  gboolean is_constant = TRUE;
+
+  /* Loop through tokenized string looking for variables to replace */
+  for (i = 0; i < n_tokens; i++)
+    {
+      PosToken *t = &tokens[i];
+
+      if (t->type == POS_TOKEN_VARIABLE)
+        {
+          if (meta_theme_lookup_int_constant (theme, t->d.v.name, &ival))
+            {
+              g_free (t->d.v.name);
+              t->type = POS_TOKEN_INT;
+              t->d.i.val = ival;
+            }
+          else if (meta_theme_lookup_float_constant (theme, t->d.v.name, &dval))
+            {
+              g_free (t->d.v.name);
+              t->type = POS_TOKEN_DOUBLE;
+              t->d.d.val = dval;
+            }
+          else
+            {
+              /* If we've found a variable that cannot be replaced then the
+                 expression is not a constant expression and we want to
+                 replace it with a GQuark */
+
+              t->d.v.name_quark = g_quark_from_string (t->d.v.name);
+              is_constant = FALSE;
+            }
+        }
+    }
+
+  return is_constant;
+}
+
+static int
+parse_x_position_unchecked (MetaDrawSpec              *spec,
+                            const MetaPositionExprEnv *env)
+{
+  int retval;
+  GError *error;
+
+  retval = 0;
+  error = NULL;
+  if (!meta_parse_position_expression (spec, env, &retval, NULL, &error))
+    {
+      meta_warning (_("Theme contained an expression that resulted in an error: %s\n"),
+                    error->message);
+
+      g_error_free (error);
+    }
+
+  return retval;
+}
+
+static int
+parse_y_position_unchecked (MetaDrawSpec              *spec,
+                            const MetaPositionExprEnv *env)
+{
+  int retval;
+  GError *error;
+
+  retval = 0;
+  error = NULL;
+  if (!meta_parse_position_expression (spec, env, NULL, &retval, &error))
+    {
+      meta_warning (_("Theme contained an expression that resulted in an error: %s\n"),
+                    error->message);
+
+      g_error_free (error);
+    }
+
+  return retval;
+}
+
+static int
+parse_size_unchecked (MetaDrawSpec        *spec,
+                      MetaPositionExprEnv *env)
+{
+  int retval;
+  GError *error;
+
+  retval = 0;
+  error = NULL;
+  if (!meta_parse_size_expression (spec, env, &retval, &error))
+    {
+      meta_warning (_("Theme contained an expression that resulted in an error: %s\n"),
+                    error->message);
+
+      g_error_free (error);
+    }
+
+  return retval;
+}
+
+void
+meta_draw_spec_free (MetaDrawSpec *spec)
+{
+  if (!spec) return;
+  free_tokens (spec->tokens, spec->n_tokens);
+  g_slice_free (MetaDrawSpec, spec);
+}
+
+/**
+ * meta_draw_spec_new: (skip)
+ *
+ */
+MetaDrawSpec *
+meta_draw_spec_new (MetaTheme  *theme,
+                    const char *expr,
+                    GError    **error)
+{
+  MetaDrawSpec *spec;
+
+  spec = g_slice_new0 (MetaDrawSpec);
+
+  pos_tokenize (expr, &spec->tokens, &spec->n_tokens, NULL);
+
+  spec->constant = meta_theme_replace_constants (theme, spec->tokens,
+                                                 spec->n_tokens, NULL);
+  if (spec->constant)
+    {
+      gboolean result;
+
+      result = pos_eval (spec, NULL, &spec->value, error);
+      if (result == FALSE)
+        {
+          meta_draw_spec_free (spec);
+          return NULL;
+        }
+    }
+
+  return spec;
+}
+
+/**
+ * meta_draw_op_new: (skip)
+ *
+ */
+MetaDrawOp*
+meta_draw_op_new (MetaDrawType type)
+{
+  MetaDrawOp *op;
+  MetaDrawOp dummy;
+  int size;
+
+  size = G_STRUCT_OFFSET (MetaDrawOp, data);
+
+  switch (type)
+    {
+    case META_DRAW_LINE:
+      size += sizeof (dummy.data.line);
+      break;
+
+    case META_DRAW_RECTANGLE:
+      size += sizeof (dummy.data.rectangle);
+      break;
+
+    case META_DRAW_ARC:
+      size += sizeof (dummy.data.arc);
+      break;
+
+    case META_DRAW_CLIP:
+      size += sizeof (dummy.data.clip);
+      break;
+
+    case META_DRAW_TINT:
+      size += sizeof (dummy.data.tint);
+      break;
+
+    case META_DRAW_GRADIENT:
+      size += sizeof (dummy.data.gradient);
+      break;
+
+    case META_DRAW_IMAGE:
+      size += sizeof (dummy.data.image);
+      break;
+
+    case META_DRAW_GTK_ARROW:
+      size += sizeof (dummy.data.gtk_arrow);
+      break;
+
+    case META_DRAW_GTK_BOX:
+      size += sizeof (dummy.data.gtk_box);
+      break;
+
+    case META_DRAW_GTK_VLINE:
+      size += sizeof (dummy.data.gtk_vline);
+      break;
+
+    case META_DRAW_ICON:
+      size += sizeof (dummy.data.icon);
+      break;
+
+    case META_DRAW_TITLE:
+      size += sizeof (dummy.data.title);
+      break;
+    case META_DRAW_OP_LIST:
+      size += sizeof (dummy.data.op_list);
+      break;
+    case META_DRAW_TILE:
+      size += sizeof (dummy.data.tile);
+      break;
+    }
+
+  op = g_malloc0 (size);
+
+  op->type = type;
+
+  return op;
+}
+
+void
+meta_draw_op_free (MetaDrawOp *op)
+{
+  g_return_if_fail (op != NULL);
+
+  switch (op->type)
+    {
+    case META_DRAW_LINE:
+      if (op->data.line.color_spec)
+        meta_color_spec_free (op->data.line.color_spec);
+
+      meta_draw_spec_free (op->data.line.x1);
+      meta_draw_spec_free (op->data.line.y1);
+      meta_draw_spec_free (op->data.line.x2);
+      meta_draw_spec_free (op->data.line.y2);
+      break;
+
+    case META_DRAW_RECTANGLE:
+      g_free (op->data.rectangle.color_spec);
+      meta_draw_spec_free (op->data.rectangle.x);
+      meta_draw_spec_free (op->data.rectangle.y);
+      meta_draw_spec_free (op->data.rectangle.width);
+      meta_draw_spec_free (op->data.rectangle.height);
+      break;
+
+    case META_DRAW_ARC:
+      g_free (op->data.arc.color_spec);
+      meta_draw_spec_free (op->data.arc.x);
+      meta_draw_spec_free (op->data.arc.y);
+      meta_draw_spec_free (op->data.arc.width);
+      meta_draw_spec_free (op->data.arc.height);
+      break;
+
+    case META_DRAW_CLIP:
+      meta_draw_spec_free (op->data.clip.x);
+      meta_draw_spec_free (op->data.clip.y);
+      meta_draw_spec_free (op->data.clip.width);
+      meta_draw_spec_free (op->data.clip.height);
+      break;
+
+    case META_DRAW_TINT:
+      if (op->data.tint.color_spec)
+        meta_color_spec_free (op->data.tint.color_spec);
+
+      if (op->data.tint.alpha_spec)
+        meta_alpha_gradient_spec_free (op->data.tint.alpha_spec);
+
+      meta_draw_spec_free (op->data.tint.x);
+      meta_draw_spec_free (op->data.tint.y);
+      meta_draw_spec_free (op->data.tint.width);
+      meta_draw_spec_free (op->data.tint.height);
+      break;
+
+    case META_DRAW_GRADIENT:
+      if (op->data.gradient.gradient_spec)
+        meta_gradient_spec_free (op->data.gradient.gradient_spec);
+
+      if (op->data.gradient.alpha_spec)
+        meta_alpha_gradient_spec_free (op->data.gradient.alpha_spec);
+
+      meta_draw_spec_free (op->data.gradient.x);
+      meta_draw_spec_free (op->data.gradient.y);
+      meta_draw_spec_free (op->data.gradient.width);
+      meta_draw_spec_free (op->data.gradient.height);
+      break;
+
+    case META_DRAW_IMAGE:
+      if (op->data.image.alpha_spec)
+        meta_alpha_gradient_spec_free (op->data.image.alpha_spec);
+
+      if (op->data.image.pixbuf)
+        g_object_unref (G_OBJECT (op->data.image.pixbuf));
+
+      if (op->data.image.colorize_spec)
+        meta_color_spec_free (op->data.image.colorize_spec);
+
+      if (op->data.image.colorize_cache_pixbuf)
+        g_object_unref (G_OBJECT (op->data.image.colorize_cache_pixbuf));
+
+      meta_draw_spec_free (op->data.image.x);
+      meta_draw_spec_free (op->data.image.y);
+      meta_draw_spec_free (op->data.image.width);
+      meta_draw_spec_free (op->data.image.height);
+      break;
+
+    case META_DRAW_GTK_ARROW:
+      meta_draw_spec_free (op->data.gtk_arrow.x);
+      meta_draw_spec_free (op->data.gtk_arrow.y);
+      meta_draw_spec_free (op->data.gtk_arrow.width);
+      meta_draw_spec_free (op->data.gtk_arrow.height);
+      break;
+
+    case META_DRAW_GTK_BOX:
+      meta_draw_spec_free (op->data.gtk_box.x);
+      meta_draw_spec_free (op->data.gtk_box.y);
+      meta_draw_spec_free (op->data.gtk_box.width);
+      meta_draw_spec_free (op->data.gtk_box.height);
+      break;
+
+    case META_DRAW_GTK_VLINE:
+      meta_draw_spec_free (op->data.gtk_vline.x);
+      meta_draw_spec_free (op->data.gtk_vline.y1);
+      meta_draw_spec_free (op->data.gtk_vline.y2);
+      break;
+
+    case META_DRAW_ICON:
+      if (op->data.icon.alpha_spec)
+        meta_alpha_gradient_spec_free (op->data.icon.alpha_spec);
+
+      meta_draw_spec_free (op->data.icon.x);
+      meta_draw_spec_free (op->data.icon.y);
+      meta_draw_spec_free (op->data.icon.width);
+      meta_draw_spec_free (op->data.icon.height);
+      break;
+
+    case META_DRAW_TITLE:
+      if (op->data.title.color_spec)
+        meta_color_spec_free (op->data.title.color_spec);
+
+      meta_draw_spec_free (op->data.title.x);
+      meta_draw_spec_free (op->data.title.y);
+      if (op->data.title.ellipsize_width)
+        meta_draw_spec_free (op->data.title.ellipsize_width);
+      break;
+
+    case META_DRAW_OP_LIST:
+      if (op->data.op_list.op_list)
+        meta_draw_op_list_unref (op->data.op_list.op_list);
+
+      meta_draw_spec_free (op->data.op_list.x);
+      meta_draw_spec_free (op->data.op_list.y);
+      meta_draw_spec_free (op->data.op_list.width);
+      meta_draw_spec_free (op->data.op_list.height);
+      break;
+
+    case META_DRAW_TILE:
+      if (op->data.tile.op_list)
+        meta_draw_op_list_unref (op->data.tile.op_list);
+
+      meta_draw_spec_free (op->data.tile.x);
+      meta_draw_spec_free (op->data.tile.y);
+      meta_draw_spec_free (op->data.tile.width);
+      meta_draw_spec_free (op->data.tile.height);
+      meta_draw_spec_free (op->data.tile.tile_xoffset);
+      meta_draw_spec_free (op->data.tile.tile_yoffset);
+      meta_draw_spec_free (op->data.tile.tile_width);
+      meta_draw_spec_free (op->data.tile.tile_height);
+      break;
+    }
+
+  g_free (op);
+}
+
+static GdkPixbuf*
+apply_alpha (GdkPixbuf             *pixbuf,
+             MetaAlphaGradientSpec *spec,
+             gboolean               force_copy)
+{
+  GdkPixbuf *new_pixbuf;
+  gboolean needs_alpha;
+
+  g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
+
+  needs_alpha = spec && (spec->n_alphas > 1 ||
+                         spec->alphas[0] != 0xff);
+
+  if (!needs_alpha)
+    return pixbuf;
+
+  if (!gdk_pixbuf_get_has_alpha (pixbuf))
+    {
+      new_pixbuf = gdk_pixbuf_add_alpha (pixbuf, FALSE, 0, 0, 0);
+      g_object_unref (G_OBJECT (pixbuf));
+      pixbuf = new_pixbuf;
+    }
+  else if (force_copy)
+    {
+      new_pixbuf = gdk_pixbuf_copy (pixbuf);
+      g_object_unref (G_OBJECT (pixbuf));
+      pixbuf = new_pixbuf;
+    }
+
+  g_assert (gdk_pixbuf_get_has_alpha (pixbuf));
+
+  meta_gradient_add_alpha (pixbuf, spec->alphas, spec->n_alphas, spec->type);
+
+  return pixbuf;
+}
+
+static GdkPixbuf*
+pixbuf_tile (GdkPixbuf *tile,
+             int        width,
+             int        height)
+{
+  GdkPixbuf *pixbuf;
+  int tile_width;
+  int tile_height;
+  int i, j;
+
+  tile_width = gdk_pixbuf_get_width (tile);
+  tile_height = gdk_pixbuf_get_height (tile);
+
+  pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB,
+                           gdk_pixbuf_get_has_alpha (tile),
+                           8, width, height);
+
+  i = 0;
+  while (i < width)
+    {
+      j = 0;
+      while (j < height)
+        {
+          int w, h;
+
+          w = MIN (tile_width, width - i);
+          h = MIN (tile_height, height - j);
+
+          gdk_pixbuf_copy_area (tile,
+                                0, 0,
+                                w, h,
+                                pixbuf,
+                                i, j);
+
+          j += tile_height;
+        }
+
+      i += tile_width;
+    }
+
+  return pixbuf;
+}
+
+static GdkPixbuf *
+replicate_rows (GdkPixbuf  *src,
+                int         src_x,
+                int         src_y,
+                int         width,
+                int         height)
+{
+  unsigned int n_channels = gdk_pixbuf_get_n_channels (src);
+  unsigned int src_rowstride = gdk_pixbuf_get_rowstride (src);
+  unsigned char *pixels = (gdk_pixbuf_get_pixels (src) + src_y * src_rowstride + src_x
+                           * n_channels);
+  unsigned char *dest_pixels;
+  GdkPixbuf *result;
+  unsigned int dest_rowstride;
+  int i;
+
+  result = gdk_pixbuf_new (GDK_COLORSPACE_RGB, n_channels == 4, 8,
+                           width, height);
+  dest_rowstride = gdk_pixbuf_get_rowstride (result);
+  dest_pixels = gdk_pixbuf_get_pixels (result);
+
+  for (i = 0; i < height; i++)
+    memcpy (dest_pixels + dest_rowstride * i, pixels, n_channels * width);
+
+  return result;
+}
+
+static GdkPixbuf *
+replicate_cols (GdkPixbuf  *src,
+                int         src_x,
+                int         src_y,
+                int         width,
+                int         height)
+{
+  unsigned int n_channels = gdk_pixbuf_get_n_channels (src);
+  unsigned int src_rowstride = gdk_pixbuf_get_rowstride (src);
+  unsigned char *pixels = (gdk_pixbuf_get_pixels (src) + src_y * src_rowstride + src_x
+                           * n_channels);
+  unsigned char *dest_pixels;
+  GdkPixbuf *result;
+  unsigned int dest_rowstride;
+  int i, j;
+
+  result = gdk_pixbuf_new (GDK_COLORSPACE_RGB, n_channels == 4, 8,
+                           width, height);
+  dest_rowstride = gdk_pixbuf_get_rowstride (result);
+  dest_pixels = gdk_pixbuf_get_pixels (result);
+
+  for (i = 0; i < height; i++)
+    {
+      unsigned char *p = dest_pixels + dest_rowstride * i;
+      unsigned char *q = pixels + src_rowstride * i;
+
+      unsigned char r = *(q++);
+      unsigned char g = *(q++);
+      unsigned char b = *(q++);
+
+      if (n_channels == 4)
+        {
+          unsigned char a;
+
+          a = *(q++);
+
+          for (j = 0; j < width; j++)
+            {
+              *(p++) = r;
+              *(p++) = g;
+              *(p++) = b;
+              *(p++) = a;
+            }
+        }
+      else
+        {
+          for (j = 0; j < width; j++)
+            {
+              *(p++) = r;
+              *(p++) = g;
+              *(p++) = b;
+            }
+        }
+    }
+
+  return result;
+}
+
+static GdkPixbuf*
+scale_and_alpha_pixbuf (GdkPixbuf             *src,
+                        MetaAlphaGradientSpec *alpha_spec,
+                        MetaImageFillType      fill_type,
+                        int                    width,
+                        int                    height,
+                        gboolean               vertical_stripes,
+                        gboolean               horizontal_stripes)
+{
+  GdkPixbuf *pixbuf;
+  GdkPixbuf *temp_pixbuf;
+
+  pixbuf = NULL;
+
+  pixbuf = src;
+
+  if (gdk_pixbuf_get_width (pixbuf) == width &&
+      gdk_pixbuf_get_height (pixbuf) == height)
+    {
+      g_object_ref (G_OBJECT (pixbuf));
+    }
+  else
+    {
+      if (fill_type == META_IMAGE_FILL_TILE)
+        {
+          pixbuf = pixbuf_tile (pixbuf, width, height);
+        }
+      else
+        {
+    	  int src_h, src_w, dest_h, dest_w;
+          src_h = gdk_pixbuf_get_height (src);
+          src_w = gdk_pixbuf_get_width (src);
+
+          /* prefer to replicate_cols if possible, as that
+           * is faster (no memory reads)
+           */
+          if (horizontal_stripes)
+            {
+              dest_w = gdk_pixbuf_get_width (src);
+              dest_h = height;
+            }
+          else if (vertical_stripes)
+            {
+              dest_w = width;
+              dest_h = gdk_pixbuf_get_height (src);
+            }
+
+          else
+            {
+              dest_w = width;
+              dest_h = height;
+            }
+
+          if (dest_w == src_w && dest_h == src_h)
+            {
+              temp_pixbuf = src;
+              g_object_ref (G_OBJECT (temp_pixbuf));
+            }
+          else
+            {
+              temp_pixbuf = gdk_pixbuf_scale_simple (src,
+                                                     dest_w, dest_h,
+                                                     GDK_INTERP_BILINEAR);
+            }
+
+          /* prefer to replicate_cols if possible, as that
+           * is faster (no memory reads)
+           */
+          if (horizontal_stripes)
+            {
+              pixbuf = replicate_cols (temp_pixbuf, 0, 0, width, height);
+              g_object_unref (G_OBJECT (temp_pixbuf));
+            }
+          else if (vertical_stripes)
+            {
+              pixbuf = replicate_rows (temp_pixbuf, 0, 0, width, height);
+              g_object_unref (G_OBJECT (temp_pixbuf));
+            }
+          else
+            {
+              pixbuf = temp_pixbuf;
+            }
+        }
+    }
+
+  if (pixbuf)
+    pixbuf = apply_alpha (pixbuf, alpha_spec, pixbuf == src);
+
+  return pixbuf;
+}
+
+static GdkPixbuf*
+draw_op_as_pixbuf (const MetaDrawOp    *op,
+                   GtkStyleContext     *context,
+                   const MetaDrawInfo  *info,
+                   int                  width,
+                   int                  height)
+{
+  /* Try to get the op as a pixbuf, assuming w/h in the op
+   * matches the width/height passed in. return NULL
+   * if the op can't be converted to an equivalent pixbuf.
+   */
+  GdkPixbuf *pixbuf;
+
+  pixbuf = NULL;
+
+  switch (op->type)
+    {
+    case META_DRAW_TINT:
+      {
+        GdkRGBA color;
+        guint32 rgba;
+        gboolean has_alpha;
+
+        meta_color_spec_render (op->data.rectangle.color_spec,
+                                context,
+                                &color);
+
+        has_alpha =
+          op->data.tint.alpha_spec &&
+          (op->data.tint.alpha_spec->n_alphas > 1 ||
+           op->data.tint.alpha_spec->alphas[0] != 0xff);
+
+        pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB,
+                                 has_alpha,
+                                 8, width, height);
+
+        if (!has_alpha)
+          {
+            rgba = GDK_COLOR_RGBA (color);
+
+            gdk_pixbuf_fill (pixbuf, rgba);
+          }
+        else if (op->data.tint.alpha_spec->n_alphas == 1)
+          {
+            rgba = GDK_COLOR_RGBA (color);
+            rgba &= ~0xff;
+            rgba |= op->data.tint.alpha_spec->alphas[0];
+
+            gdk_pixbuf_fill (pixbuf, rgba);
+          }
+        else
+          {
+            rgba = GDK_COLOR_RGBA (color);
+
+            gdk_pixbuf_fill (pixbuf, rgba);
+
+            meta_gradient_add_alpha (pixbuf,
+                                     op->data.tint.alpha_spec->alphas,
+                                     op->data.tint.alpha_spec->n_alphas,
+                                     op->data.tint.alpha_spec->type);
+          }
+      }
+      break;
+
+    case META_DRAW_GRADIENT:
+      {
+        pixbuf = meta_gradient_spec_render (op->data.gradient.gradient_spec,
+                                            context, width, height);
+
+        pixbuf = apply_alpha (pixbuf,
+                              op->data.gradient.alpha_spec,
+                              FALSE);
+      }
+      break;
+
+    case META_DRAW_IMAGE:
+      {
+        if (op->data.image.colorize_spec)
+          {
+            GdkRGBA color;
+
+            meta_color_spec_render (op->data.image.colorize_spec,
+                                    context, &color);
+
+            if (op->data.image.colorize_cache_pixbuf == NULL ||
+                op->data.image.colorize_cache_pixel != GDK_COLOR_RGB (color))
+              {
+                if (op->data.image.colorize_cache_pixbuf)
+                  g_object_unref (G_OBJECT (op->data.image.colorize_cache_pixbuf));
+
+                /* const cast here */
+                ((MetaDrawOp*)op)->data.image.colorize_cache_pixbuf =
+                  colorize_pixbuf (op->data.image.pixbuf,
+                                   &color);
+                ((MetaDrawOp*)op)->data.image.colorize_cache_pixel =
+                  GDK_COLOR_RGB (color);
+              }
+
+            if (op->data.image.colorize_cache_pixbuf)
+              {
+                pixbuf = scale_and_alpha_pixbuf (op->data.image.colorize_cache_pixbuf,
+                                                 op->data.image.alpha_spec,
+                                                 op->data.image.fill_type,
+                                                 width, height,
+                                                 op->data.image.vertical_stripes,
+                                                 op->data.image.horizontal_stripes);
+              }
+          }
+        else
+          {
+            pixbuf = scale_and_alpha_pixbuf (op->data.image.pixbuf,
+                                             op->data.image.alpha_spec,
+                                             op->data.image.fill_type,
+                                             width, height,
+                                             op->data.image.vertical_stripes,
+                                             op->data.image.horizontal_stripes);
+          }
+        break;
+      }
+    case META_DRAW_ICON:
+      if (info->mini_icon &&
+          width <= gdk_pixbuf_get_width (info->mini_icon) &&
+          height <= gdk_pixbuf_get_height (info->mini_icon))
+        pixbuf = scale_and_alpha_pixbuf (info->mini_icon,
+                                         op->data.icon.alpha_spec,
+                                         op->data.icon.fill_type,
+                                         width, height,
+                                         FALSE, FALSE);
+      else if (info->icon)
+        pixbuf = scale_and_alpha_pixbuf (info->icon,
+                                         op->data.icon.alpha_spec,
+                                         op->data.icon.fill_type,
+                                         width, height,
+                                         FALSE, FALSE);
+      break;
+
+    case META_DRAW_LINE:
+    case META_DRAW_RECTANGLE:
+    case META_DRAW_ARC:
+    case META_DRAW_CLIP:
+    case META_DRAW_GTK_ARROW:
+    case META_DRAW_GTK_BOX:
+    case META_DRAW_GTK_VLINE:
+    case META_DRAW_TITLE:
+    case META_DRAW_OP_LIST:
+    case META_DRAW_TILE:
+      break;
+    }
+
+  return pixbuf;
+}
+
+static void
+fill_env (MetaPositionExprEnv *env,
+          const MetaDrawInfo  *info,
+          MetaRectangle        logical_region)
+{
+  /* FIXME this stuff could be raised into draw_op_list_draw() probably
+   */
+  env->rect = logical_region;
+  env->object_width = -1;
+  env->object_height = -1;
+  if (info->fgeom)
+    {
+      env->left_width = info->fgeom->borders.visible.left;
+      env->right_width = info->fgeom->borders.visible.right;
+      env->top_height = info->fgeom->borders.visible.top;
+      env->bottom_height = info->fgeom->borders.visible.bottom;
+      env->frame_x_center = info->fgeom->width / 2 - logical_region.x;
+      env->frame_y_center = info->fgeom->height / 2 - logical_region.y;
+    }
+  else
+    {
+      env->left_width = 0;
+      env->right_width = 0;
+      env->top_height = 0;
+      env->bottom_height = 0;
+      env->frame_x_center = 0;
+      env->frame_y_center = 0;
+    }
+
+  env->mini_icon_width = info->mini_icon ? gdk_pixbuf_get_width (info->mini_icon) : 0;
+  env->mini_icon_height = info->mini_icon ? gdk_pixbuf_get_height (info->mini_icon) : 0;
+  env->icon_width = info->icon ? gdk_pixbuf_get_width (info->icon) : 0;
+  env->icon_height = info->icon ? gdk_pixbuf_get_height (info->icon) : 0;
+
+  env->title_width = info->title_layout_width;
+  env->title_height = info->title_layout_height;
+  env->theme = meta_current_theme;
+}
+
+
+/* This code was originally rendering anti-aliased using X primitives, and
+ * now has been switched to draw anti-aliased using cairo. In general, the
+ * closest correspondence between X rendering and cairo rendering is given
+ * by offsetting the geometry by 0.5 pixels in both directions before rendering
+ * with cairo. This is because X samples at the upper left corner of the
+ * pixel while cairo averages over the entire pixel. However, in the cases
+ * where the X rendering was an exact rectangle with no "jaggies"
+ * we need to be a bit careful about applying the offset. We want to produce
+ * the exact same pixel-aligned rectangle, rather than a rectangle with
+ * fuzz around the edges.
+ */
+static void
+meta_draw_op_draw_with_env (const MetaDrawOp    *op,
+                            GtkStyleContext     *style_gtk,
+                            cairo_t             *cr,
+                            const MetaDrawInfo  *info,
+                            MetaRectangle        rect,
+                            MetaPositionExprEnv *env)
+{
+  GdkRGBA color;
+
+  cairo_save (cr);
+
+  cairo_set_line_width (cr, 1.0);
+
+  switch (op->type)
+    {
+    case META_DRAW_LINE:
+      {
+        int x1, x2, y1, y2;
+
+        meta_color_spec_render (op->data.line.color_spec, style_gtk, &color);
+        gdk_cairo_set_source_rgba (cr, &color);
+
+        if (op->data.line.width > 0)
+          cairo_set_line_width (cr, op->data.line.width);
+
+        if (op->data.line.dash_on_length > 0 &&
+            op->data.line.dash_off_length > 0)
+          {
+            double dash_list[2];
+            dash_list[0] = op->data.line.dash_on_length;
+            dash_list[1] = op->data.line.dash_off_length;
+            cairo_set_dash (cr, dash_list, 2, 0);
+          }
+
+        x1 = parse_x_position_unchecked (op->data.line.x1, env);
+        y1 = parse_y_position_unchecked (op->data.line.y1, env);
+
+        if (!op->data.line.x2 &&
+            !op->data.line.y2 &&
+            op->data.line.width==0)
+          {
+            cairo_rectangle (cr, x1, y1, 1, 1);
+            cairo_fill (cr);
+          }
+        else
+          {
+            if (op->data.line.x2)
+              x2 = parse_x_position_unchecked (op->data.line.x2, env);
+            else
+              x2 = x1;
+
+            if (op->data.line.y2)
+              y2 = parse_y_position_unchecked (op->data.line.y2, env);
+            else
+              y2 = y1;
+
+            /* This is one of the cases where we are matching the exact
+             * pixel aligned rectangle produced by X; for zero-width lines
+             * the generic algorithm produces the right result so we don't
+             * need to handle them here.
+             */
+            if ((y1 == y2 || x1 == x2) && op->data.line.width != 0)
+              {
+                double offset = op->data.line.width % 2 ? .5 : 0;
+
+                if (y1 == y2)
+                  {
+                    cairo_move_to (cr, x1, y1 + offset);
+                    cairo_line_to (cr, x2, y2 + offset);
+                  }
+                else
+                  {
+                    cairo_move_to (cr, x1 + offset, y1);
+                    cairo_line_to (cr, x2 + offset, y2);
+                  }
+              }
+            else
+              {
+                /* zero-width lines include both end-points in X, unlike wide lines */
+                if (op->data.line.width == 0)
+                  cairo_set_line_cap (cr, CAIRO_LINE_CAP_SQUARE);
+
+                cairo_move_to (cr, x1 + .5, y1 + .5);
+                cairo_line_to (cr, x2 + .5, y2 + .5);
+              }
+            cairo_stroke (cr);
+          }
+      }
+      break;
+
+    case META_DRAW_RECTANGLE:
+      {
+        int rx, ry, rwidth, rheight;
+
+        meta_color_spec_render (op->data.rectangle.color_spec,
+                                style_gtk, &color);
+        gdk_cairo_set_source_rgba (cr, &color);
+
+        rx = parse_x_position_unchecked (op->data.rectangle.x, env);
+        ry = parse_y_position_unchecked (op->data.rectangle.y, env);
+        rwidth = parse_size_unchecked (op->data.rectangle.width, env);
+        rheight = parse_size_unchecked (op->data.rectangle.height, env);
+
+        /* Filled and stroked rectangles are the other cases
+         * we pixel-align to X rasterization
+         */
+        if (op->data.rectangle.filled)
+          {
+            cairo_rectangle (cr, rx, ry, rwidth, rheight);
+            cairo_fill (cr);
+          }
+        else
+          {
+            cairo_rectangle (cr, rx + .5, ry + .5, rwidth, rheight);
+            cairo_stroke (cr);
+          }
+      }
+      break;
+
+    case META_DRAW_ARC:
+      {
+        int rx, ry, rwidth, rheight;
+        double start_angle, end_angle;
+        double center_x, center_y;
+
+        meta_color_spec_render (op->data.arc.color_spec, style_gtk, &color);
+        gdk_cairo_set_source_rgba (cr, &color);
+
+        rx = parse_x_position_unchecked (op->data.arc.x, env);
+        ry = parse_y_position_unchecked (op->data.arc.y, env);
+        rwidth = parse_size_unchecked (op->data.arc.width, env);
+        rheight = parse_size_unchecked (op->data.arc.height, env);
+
+        start_angle = op->data.arc.start_angle * (M_PI / 180.)
+                      - (.5 * M_PI); /* start at 12 instead of 3 oclock */
+        end_angle = start_angle + op->data.arc.extent_angle * (M_PI / 180.);
+        center_x = rx + (double)rwidth / 2. + .5;
+        center_y = ry + (double)rheight / 2. + .5;
+
+        cairo_save (cr);
+
+        cairo_translate (cr, center_x, center_y);
+        cairo_scale (cr, (double)rwidth / 2., (double)rheight / 2.);
+
+        if (op->data.arc.extent_angle >= 0)
+          cairo_arc (cr, 0, 0, 1, start_angle, end_angle);
+        else
+          cairo_arc_negative (cr, 0, 0, 1, start_angle, end_angle);
+
+        cairo_restore (cr);
+
+        if (op->data.arc.filled)
+          {
+            cairo_line_to (cr, center_x, center_y);
+            cairo_fill (cr);
+          }
+        else
+          cairo_stroke (cr);
+      }
+      break;
+
+    case META_DRAW_CLIP:
+      break;
+
+    case META_DRAW_TINT:
+      {
+        int rx, ry, rwidth, rheight;
+        gboolean needs_alpha;
+
+        needs_alpha = op->data.tint.alpha_spec &&
+          (op->data.tint.alpha_spec->n_alphas > 1 ||
+           op->data.tint.alpha_spec->alphas[0] != 0xff);
+
+        rx = parse_x_position_unchecked (op->data.tint.x, env);
+        ry = parse_y_position_unchecked (op->data.tint.y, env);
+        rwidth = parse_size_unchecked (op->data.tint.width, env);
+        rheight = parse_size_unchecked (op->data.tint.height, env);
+
+        if (!needs_alpha)
+          {
+            meta_color_spec_render (op->data.tint.color_spec,
+                                    style_gtk, &color);
+            gdk_cairo_set_source_rgba (cr, &color);
+
+            cairo_rectangle (cr, rx, ry, rwidth, rheight);
+            cairo_fill (cr);
+          }
+        else
+          {
+            GdkPixbuf *pixbuf;
+
+            pixbuf = draw_op_as_pixbuf (op, style_gtk, info,
+                                        rwidth, rheight);
+
+            if (pixbuf)
+              {
+                gdk_cairo_set_source_pixbuf (cr, pixbuf, rx, ry);
+                cairo_paint (cr);
+
+                g_object_unref (G_OBJECT (pixbuf));
+              }
+          }
+      }
+      break;
+
+    case META_DRAW_GRADIENT:
+      {
+        int rx, ry, rwidth, rheight;
+        GdkPixbuf *pixbuf;
+
+        rx = parse_x_position_unchecked (op->data.gradient.x, env);
+        ry = parse_y_position_unchecked (op->data.gradient.y, env);
+        rwidth = parse_size_unchecked (op->data.gradient.width, env);
+        rheight = parse_size_unchecked (op->data.gradient.height, env);
+
+        pixbuf = draw_op_as_pixbuf (op, style_gtk, info,
+                                    rwidth, rheight);
+
+        if (pixbuf)
+          {
+            gdk_cairo_set_source_pixbuf (cr, pixbuf, rx, ry);
+            cairo_paint (cr);
+
+            g_object_unref (G_OBJECT (pixbuf));
+          }
+      }
+      break;
+
+    case META_DRAW_IMAGE:
+      {
+        int rx, ry, rwidth, rheight;
+        GdkPixbuf *pixbuf;
+
+        if (op->data.image.pixbuf)
+          {
+            env->object_width = gdk_pixbuf_get_width (op->data.image.pixbuf);
+            env->object_height = gdk_pixbuf_get_height (op->data.image.pixbuf);
+          }
+
+        rwidth = parse_size_unchecked (op->data.image.width, env);
+        rheight = parse_size_unchecked (op->data.image.height, env);
+
+        pixbuf = draw_op_as_pixbuf (op, style_gtk, info,
+                                    rwidth, rheight);
+
+        if (pixbuf)
+          {
+            rx = parse_x_position_unchecked (op->data.image.x, env);
+            ry = parse_y_position_unchecked (op->data.image.y, env);
+
+            gdk_cairo_set_source_pixbuf (cr, pixbuf, rx, ry);
+            cairo_paint (cr);
+
+            g_object_unref (G_OBJECT (pixbuf));
+          }
+      }
+      break;
+
+    case META_DRAW_GTK_ARROW:
+      {
+        int rx, ry, rwidth, rheight;
+        double angle = 0, size;
+
+        rx = parse_x_position_unchecked (op->data.gtk_arrow.x, env);
+        ry = parse_y_position_unchecked (op->data.gtk_arrow.y, env);
+        rwidth = parse_size_unchecked (op->data.gtk_arrow.width, env);
+        rheight = parse_size_unchecked (op->data.gtk_arrow.height, env);
+
+        size = MAX(rwidth, rheight);
+
+        switch (op->data.gtk_arrow.arrow)
+          {
+          case GTK_ARROW_UP:
+            angle = 0;
+            break;
+          case GTK_ARROW_RIGHT:
+            angle = M_PI / 2;
+            break;
+          case GTK_ARROW_DOWN:
+            angle = M_PI;
+            break;
+          case GTK_ARROW_LEFT:
+            angle = 3 * M_PI / 2;
+            break;
+          case GTK_ARROW_NONE:
+            return;
+          }
+
+        gtk_style_context_set_state (style_gtk, op->data.gtk_arrow.state);
+        gtk_render_arrow (style_gtk, cr, angle, rx, ry, size);
+      }
+      break;
+
+    case META_DRAW_GTK_BOX:
+      {
+        int rx, ry, rwidth, rheight;
+
+        rx = parse_x_position_unchecked (op->data.gtk_box.x, env);
+        ry = parse_y_position_unchecked (op->data.gtk_box.y, env);
+        rwidth = parse_size_unchecked (op->data.gtk_box.width, env);
+        rheight = parse_size_unchecked (op->data.gtk_box.height, env);
+
+        gtk_style_context_set_state (style_gtk, op->data.gtk_box.state);
+        gtk_render_background (style_gtk, cr, rx, ry, rwidth, rheight);
+        gtk_render_frame (style_gtk, cr, rx, ry, rwidth, rheight);
+      }
+      break;
+
+    case META_DRAW_GTK_VLINE:
+      {
+        int rx, ry1, ry2;
+
+        rx = parse_x_position_unchecked (op->data.gtk_vline.x, env);
+        ry1 = parse_y_position_unchecked (op->data.gtk_vline.y1, env);
+        ry2 = parse_y_position_unchecked (op->data.gtk_vline.y2, env);
+
+        gtk_style_context_set_state (style_gtk, op->data.gtk_vline.state);
+        gtk_render_line (style_gtk, cr, rx, ry1, rx, ry2);
+      }
+      break;
+
+    case META_DRAW_ICON:
+      {
+        int rx, ry, rwidth, rheight;
+        GdkPixbuf *pixbuf;
+
+        rwidth = parse_size_unchecked (op->data.icon.width, env);
+        rheight = parse_size_unchecked (op->data.icon.height, env);
+
+        pixbuf = draw_op_as_pixbuf (op, style_gtk, info,
+                                    rwidth, rheight);
+
+        if (pixbuf)
+          {
+            rx = parse_x_position_unchecked (op->data.icon.x, env);
+            ry = parse_y_position_unchecked (op->data.icon.y, env);
+
+            gdk_cairo_set_source_pixbuf (cr, pixbuf, rx, ry);
+            cairo_paint (cr);
+
+            g_object_unref (G_OBJECT (pixbuf));
+          }
+      }
+      break;
+
+    case META_DRAW_TITLE:
+      if (info->title_layout)
+        {
+          int rx, ry;
+          PangoRectangle ink_rect, logical_rect;
+
+          meta_color_spec_render (op->data.title.color_spec,
+                                  style_gtk, &color);
+          gdk_cairo_set_source_rgba (cr, &color);
+
+          rx = parse_x_position_unchecked (op->data.title.x, env);
+          ry = parse_y_position_unchecked (op->data.title.y, env);
+
+          if (op->data.title.ellipsize_width)
+            {
+              int ellipsize_width;
+              int right_bearing;
+
+              ellipsize_width = parse_x_position_unchecked (op->data.title.ellipsize_width, env);
+              /* HACK: parse_x_position_unchecked adds in env->rect.x, subtract out again */
+              ellipsize_width -= env->rect.x;
+
+              pango_layout_set_width (info->title_layout, -1);
+              pango_layout_get_pixel_extents (info->title_layout,
+                                              &ink_rect, &logical_rect);
+
+              /* Pango's idea of ellipsization is with respect to the logical rect.
+               * correct for this, by reducing the ellipsization width by the overflow
+               * of the un-ellipsized text on the right... it's always the visual
+               * right we want regardless of bidi, since since the X we pass in to
+               * cairo_move_to() is always the left edge of the line.
+               */
+              right_bearing = (ink_rect.x + ink_rect.width) - (logical_rect.x + logical_rect.width);
+              right_bearing = MAX (right_bearing, 0);
+
+              ellipsize_width -= right_bearing;
+              ellipsize_width = MAX (ellipsize_width, 0);
+
+              /* Only ellipsizing when necessary is a performance optimization -
+               * pango_layout_set_width() will force a relayout if it isn't the
+               * same as the current width of -1.
+               */
+              if (ellipsize_width < logical_rect.width)
+                pango_layout_set_width (info->title_layout, PANGO_SCALE * ellipsize_width);
+            }
+
+          cairo_move_to (cr, rx, ry);
+          pango_cairo_show_layout (cr, info->title_layout);
+
+          /* Remove any ellipsization we might have set; will short-circuit
+           * if the width is already -1 */
+          pango_layout_set_width (info->title_layout, -1);
+        }
+      break;
+
+    case META_DRAW_OP_LIST:
+      {
+        MetaRectangle d_rect;
+
+        d_rect.x = parse_x_position_unchecked (op->data.op_list.x, env);
+        d_rect.y = parse_y_position_unchecked (op->data.op_list.y, env);
+        d_rect.width = parse_size_unchecked (op->data.op_list.width, env);
+        d_rect.height = parse_size_unchecked (op->data.op_list.height, env);
+
+        meta_draw_op_list_draw_with_style (op->data.op_list.op_list,
+                                           style_gtk, cr, info, d_rect);
+      }
+      break;
+
+    case META_DRAW_TILE:
+      {
+        int rx, ry, rwidth, rheight;
+        int tile_xoffset, tile_yoffset;
+        MetaRectangle tile;
+
+        rx = parse_x_position_unchecked (op->data.tile.x, env);
+        ry = parse_y_position_unchecked (op->data.tile.y, env);
+        rwidth = parse_size_unchecked (op->data.tile.width, env);
+        rheight = parse_size_unchecked (op->data.tile.height, env);
+
+        cairo_save (cr);
+
+        cairo_rectangle (cr, rx, ry, rwidth, rheight);
+        cairo_clip (cr);
+
+        tile_xoffset = parse_x_position_unchecked (op->data.tile.tile_xoffset, env);
+        tile_yoffset = parse_y_position_unchecked (op->data.tile.tile_yoffset, env);
+        /* tile offset should not include x/y */
+        tile_xoffset -= rect.x;
+        tile_yoffset -= rect.y;
+
+        tile.width = parse_size_unchecked (op->data.tile.tile_width, env);
+        tile.height = parse_size_unchecked (op->data.tile.tile_height, env);
+
+        tile.x = rx - tile_xoffset;
+
+        while (tile.x < (rx + rwidth))
+          {
+            tile.y = ry - tile_yoffset;
+            while (tile.y < (ry + rheight))
+              {
+                meta_draw_op_list_draw_with_style (op->data.tile.op_list,
+                                                   style_gtk, cr, info, tile);
+
+                tile.y += tile.height;
+              }
+
+            tile.x += tile.width;
+          }
+        cairo_restore (cr);
+
+      }
+      break;
+    }
+
+  cairo_restore (cr);
+}
+
+void
+meta_draw_op_draw_with_style (const MetaDrawOp    *op,
+                              GtkStyleContext     *style_gtk,
+                              cairo_t             *cr,
+                              const MetaDrawInfo  *info,
+                              MetaRectangle        logical_region)
+{
+  MetaPositionExprEnv env;
+
+  fill_env (&env, info, logical_region);
+
+  meta_draw_op_draw_with_env (op, style_gtk, cr,
+                              info, logical_region,
+                              &env);
+
+}
+
+/**
+ * meta_draw_op_list_new: (skip)
+ *
+ */
+MetaDrawOpList*
+meta_draw_op_list_new (int n_preallocs)
+{
+  MetaDrawOpList *op_list;
+
+  g_return_val_if_fail (n_preallocs >= 0, NULL);
+
+  op_list = g_new (MetaDrawOpList, 1);
+
+  op_list->refcount = 1;
+  op_list->n_allocated = n_preallocs;
+  op_list->ops = g_new (MetaDrawOp*, op_list->n_allocated);
+  op_list->n_ops = 0;
+
+  return op_list;
+}
+
+void
+meta_draw_op_list_ref (MetaDrawOpList *op_list)
+{
+  g_return_if_fail (op_list != NULL);
+
+  op_list->refcount += 1;
+}
+
+void
+meta_draw_op_list_unref (MetaDrawOpList *op_list)
+{
+  g_return_if_fail (op_list != NULL);
+  g_return_if_fail (op_list->refcount > 0);
+
+  op_list->refcount -= 1;
+
+  if (op_list->refcount == 0)
+    {
+      int i;
+
+      for (i = 0; i < op_list->n_ops; i++)
+        meta_draw_op_free (op_list->ops[i]);
+
+      g_free (op_list->ops);
+
+      DEBUG_FILL_STRUCT (op_list);
+      g_free (op_list);
+    }
+}
+
+void
+meta_draw_op_list_draw_with_style  (const MetaDrawOpList *op_list,
+                                    GtkStyleContext      *style_gtk,
+                                    cairo_t              *cr,
+                                    const MetaDrawInfo   *info,
+                                    MetaRectangle         rect)
+{
+  int i;
+  MetaPositionExprEnv env;
+
+  if (op_list->n_ops == 0)
+    return;
+
+  fill_env (&env, info, rect);
+
+  cairo_save (cr);
+
+  for (i = 0; i < op_list->n_ops; i++)
+    {
+      MetaDrawOp *op = op_list->ops[i];
+
+      if (op->type == META_DRAW_CLIP)
+        {
+          cairo_restore (cr);
+
+          cairo_rectangle (cr,
+                           parse_x_position_unchecked (op->data.clip.x, &env),
+                           parse_y_position_unchecked (op->data.clip.y, &env),
+                           parse_size_unchecked (op->data.clip.width, &env),
+                           parse_size_unchecked (op->data.clip.height, &env));
+          cairo_clip (cr);
+
+          cairo_save (cr);
+        }
+      else if (gdk_cairo_get_clip_rectangle (cr, NULL))
+        {
+          meta_draw_op_draw_with_env (op,
+                                      style_gtk, cr, info,
+                                      rect,
+                                      &env);
+        }
+    }
+
+  cairo_restore (cr);
+}
+
+void
+meta_draw_op_list_append (MetaDrawOpList       *op_list,
+                          MetaDrawOp           *op)
+{
+  if (op_list->n_ops == op_list->n_allocated)
+    {
+      op_list->n_allocated *= 2;
+      op_list->ops = g_renew (MetaDrawOp*, op_list->ops, op_list->n_allocated);
+    }
+
+  op_list->ops[op_list->n_ops] = op;
+  op_list->n_ops += 1;
+}
+
+gboolean
+meta_draw_op_list_validate (MetaDrawOpList    *op_list,
+                            GError           **error)
+{
+  g_return_val_if_fail (op_list != NULL, FALSE);
+
+  /* empty lists are OK, nothing else to check really */
+
+  return TRUE;
+}
+
+/* This is not done in validate, since we wouldn't know the name
+ * of the list to report the error. It might be nice to
+ * store names inside the list sometime.
+ */
+gboolean
+meta_draw_op_list_contains (MetaDrawOpList    *op_list,
+                            MetaDrawOpList    *child)
+{
+  int i;
+
+  /* mmm, huge tree recursion */
+
+  for (i = 0; i < op_list->n_ops; i++)
+    {
+      if (op_list->ops[i]->type == META_DRAW_OP_LIST)
+        {
+          if (op_list->ops[i]->data.op_list.op_list == child)
+            return TRUE;
+
+          if (meta_draw_op_list_contains (op_list->ops[i]->data.op_list.op_list,
+                                          child))
+            return TRUE;
+        }
+      else if (op_list->ops[i]->type == META_DRAW_TILE)
+        {
+          if (op_list->ops[i]->data.tile.op_list == child)
+            return TRUE;
+
+          if (meta_draw_op_list_contains (op_list->ops[i]->data.tile.op_list,
+                                          child))
+            return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
+/**
+ * meta_frame_style_new:
+ * @parent: The parent style. Data not filled in here will be
+ *          looked for in the parent style, and in its parent
+ *          style, and so on.
+ *
+ * Constructor for a MetaFrameStyle.
+ *
+ * Returns: (transfer full): The newly-constructed style.
+ */
+MetaFrameStyle*
+meta_frame_style_new (MetaFrameStyle *parent)
+{
+  MetaFrameStyle *style;
+
+  style = g_new0 (MetaFrameStyle, 1);
+
+  style->refcount = 1;
+
+  /* Default alpha is fully opaque */
+  style->window_background_alpha = 255;
+
+  style->parent = parent;
+  if (parent)
+    meta_frame_style_ref (parent);
+
+  return style;
+}
+
+/**
+ * meta_frame_style_ref:
+ * @style: The style.
+ *
+ * Increases the reference count of a frame style.
+ */
+void
+meta_frame_style_ref (MetaFrameStyle *style)
+{
+  g_return_if_fail (style != NULL);
+
+  style->refcount += 1;
+}
+
+static void
+free_button_ops (MetaDrawOpList *op_lists[META_BUTTON_TYPE_LAST][META_BUTTON_STATE_LAST])
+{
+  int i, j;
+
+  for (i = 0; i < META_BUTTON_TYPE_LAST; i++)
+    for (j = 0; j < META_BUTTON_STATE_LAST; j++)
+      if (op_lists[i][j])
+        meta_draw_op_list_unref (op_lists[i][j]);
+}
+
+void
+meta_frame_style_unref (MetaFrameStyle *style)
+{
+  g_return_if_fail (style != NULL);
+  g_return_if_fail (style->refcount > 0);
+
+  style->refcount -= 1;
+
+  if (style->refcount == 0)
+    {
+      int i;
+
+      free_button_ops (style->buttons);
+
+      for (i = 0; i < META_FRAME_PIECE_LAST; i++)
+        if (style->pieces[i])
+          meta_draw_op_list_unref (style->pieces[i]);
+
+      if (style->layout)
+        meta_frame_layout_unref (style->layout);
+
+      if (style->window_background_color)
+        meta_color_spec_free (style->window_background_color);
+
+      /* we hold a reference to any parent style */
+      if (style->parent)
+        meta_frame_style_unref (style->parent);
+
+      DEBUG_FILL_STRUCT (style);
+      g_free (style);
+    }
+}
+
+static MetaButtonState
+map_button_state (MetaButtonType           button_type,
+                  const MetaFrameGeometry *fgeom,
+                  int                      middle_bg_offset,
+                  MetaButtonState          button_states[META_BUTTON_TYPE_LAST])
+{
+  MetaButtonFunction function = META_BUTTON_FUNCTION_LAST;
+
+  switch (button_type)
+    {
+    /* First handle functions, which map directly */
+    case META_BUTTON_TYPE_SHADE:
+    case META_BUTTON_TYPE_ABOVE:
+    case META_BUTTON_TYPE_STICK:
+    case META_BUTTON_TYPE_UNSHADE:
+    case META_BUTTON_TYPE_UNABOVE:
+    case META_BUTTON_TYPE_UNSTICK:
+    case META_BUTTON_TYPE_MENU:
+    case META_BUTTON_TYPE_APPMENU:
+    case META_BUTTON_TYPE_MINIMIZE:
+    case META_BUTTON_TYPE_MAXIMIZE:
+    case META_BUTTON_TYPE_CLOSE:
+      return button_states[button_type];
+
+    /* Map position buttons to the corresponding function */
+    case META_BUTTON_TYPE_RIGHT_LEFT_BACKGROUND:
+    case META_BUTTON_TYPE_RIGHT_SINGLE_BACKGROUND:
+      if (fgeom->n_right_buttons > 0)
+        function = fgeom->button_layout.right_buttons[0];
+      break;
+    case META_BUTTON_TYPE_RIGHT_RIGHT_BACKGROUND:
+      if (fgeom->n_right_buttons > 0)
+        function = fgeom->button_layout.right_buttons[fgeom->n_right_buttons - 1];
+      break;
+    case META_BUTTON_TYPE_RIGHT_MIDDLE_BACKGROUND:
+      if (middle_bg_offset + 1 < fgeom->n_right_buttons)
+        function = fgeom->button_layout.right_buttons[middle_bg_offset + 1];
+      break;
+    case META_BUTTON_TYPE_LEFT_LEFT_BACKGROUND:
+    case META_BUTTON_TYPE_LEFT_SINGLE_BACKGROUND:
+      if (fgeom->n_left_buttons > 0)
+        function = fgeom->button_layout.left_buttons[0];
+      break;
+    case META_BUTTON_TYPE_LEFT_RIGHT_BACKGROUND:
+      if (fgeom->n_left_buttons > 0)
+        function = fgeom->button_layout.left_buttons[fgeom->n_left_buttons - 1];
+      break;
+    case META_BUTTON_TYPE_LEFT_MIDDLE_BACKGROUND:
+      if (middle_bg_offset + 1 < fgeom->n_left_buttons)
+        function = fgeom->button_layout.left_buttons[middle_bg_offset + 1];
+      break;
+    case META_BUTTON_TYPE_LAST:
+      break;
+    }
+
+  if (function != META_BUTTON_FUNCTION_LAST)
+    return button_states[map_button_function_to_type (function)];
+
+  return META_BUTTON_STATE_LAST;
+}
+
+static MetaDrawOpList*
+get_button (MetaFrameStyle *style,
+            MetaButtonType  type,
+            MetaButtonState state)
+{
+  MetaDrawOpList *op_list;
+  MetaFrameStyle *parent;
+
+  parent = style;
+  op_list = NULL;
+  while (parent && op_list == NULL)
+    {
+      op_list = parent->buttons[type][state];
+      parent = parent->parent;
+    }
+
+  /* We fall back to the side buttons if we don't have
+   * single button backgrounds, and to middle button
+   * backgrounds if we don't have the ones on the sides
+   */
+
+  if (op_list == NULL &&
+      type == META_BUTTON_TYPE_LEFT_SINGLE_BACKGROUND)
+    return get_button (style, META_BUTTON_TYPE_LEFT_LEFT_BACKGROUND, state);
+
+  if (op_list == NULL &&
+      type == META_BUTTON_TYPE_RIGHT_SINGLE_BACKGROUND)
+    return get_button (style, META_BUTTON_TYPE_RIGHT_RIGHT_BACKGROUND, state);
+
+  if (op_list == NULL &&
+      (type == META_BUTTON_TYPE_LEFT_LEFT_BACKGROUND ||
+       type == META_BUTTON_TYPE_LEFT_RIGHT_BACKGROUND))
+    return get_button (style, META_BUTTON_TYPE_LEFT_MIDDLE_BACKGROUND,
+                       state);
+
+  if (op_list == NULL &&
+      (type == META_BUTTON_TYPE_RIGHT_LEFT_BACKGROUND ||
+       type == META_BUTTON_TYPE_RIGHT_RIGHT_BACKGROUND))
+    return get_button (style, META_BUTTON_TYPE_RIGHT_MIDDLE_BACKGROUND,
+                       state);
+
+  /* We fall back to normal if no prelight */
+  if (op_list == NULL &&
+      state == META_BUTTON_STATE_PRELIGHT)
+    return get_button (style, type, META_BUTTON_STATE_NORMAL);
+
+  return op_list;
+}
+
+void
+meta_frame_style_apply_scale (const MetaFrameStyle *style,
+                              PangoFontDescription *font_desc)
+{
+  int size = pango_font_description_get_size (font_desc);
+  pango_font_description_set_size (font_desc,
+                                   MAX (size * style->layout->title_scale, 1));
+}
+
+gboolean
+meta_frame_style_validate (MetaFrameStyle    *style,
+                           guint              current_theme_version,
+                           GError           **error)
+{
+  int i, j;
+
+  g_return_val_if_fail (style != NULL, FALSE);
+  g_return_val_if_fail (style->layout != NULL, FALSE);
+
+  for (i = 0; i < META_BUTTON_TYPE_LAST; i++)
+    {
+      /* for now the "positional" buttons are optional */
+      if (i >= META_BUTTON_TYPE_CLOSE)
+        {
+          for (j = 0; j < META_BUTTON_STATE_LAST; j++)
+            {
+              if (get_button (style, i, j) == NULL &&
+                  meta_theme_earliest_version_with_button (i) <= current_theme_version
+                  )
+                {
+                  g_set_error (error, META_THEME_ERROR,
+                               META_THEME_ERROR_FAILED,
+                               _("<button function=\"%s\" state=\"%s\" draw_ops=\"whatever\"/> must be specified for this frame style"),
+                               meta_button_type_to_string (i),
+                               meta_button_state_to_string (j));
+                  return FALSE;
+                }
+            }
+        }
+    }
+
+  return TRUE;
+}
+
+static void
+get_button_rect (MetaButtonType           type,
+                 const MetaFrameGeometry *fgeom,
+                 int                      middle_background_offset,
+                 GdkRectangle            *rect)
+{
+  switch (type)
+    {
+    case META_BUTTON_TYPE_LEFT_LEFT_BACKGROUND:
+      *rect = fgeom->left_left_background;
+      break;
+
+    case META_BUTTON_TYPE_LEFT_MIDDLE_BACKGROUND:
+      *rect = fgeom->left_middle_backgrounds[middle_background_offset];
+      break;
+
+    case META_BUTTON_TYPE_LEFT_RIGHT_BACKGROUND:
+      *rect = fgeom->left_right_background;
+      break;
+
+    case META_BUTTON_TYPE_LEFT_SINGLE_BACKGROUND:
+      *rect = fgeom->left_single_background;
+      break;
+
+    case META_BUTTON_TYPE_RIGHT_LEFT_BACKGROUND:
+      *rect = fgeom->right_left_background;
+      break;
+
+    case META_BUTTON_TYPE_RIGHT_MIDDLE_BACKGROUND:
+      *rect = fgeom->right_middle_backgrounds[middle_background_offset];
+      break;
+
+    case META_BUTTON_TYPE_RIGHT_RIGHT_BACKGROUND:
+      *rect = fgeom->right_right_background;
+      break;
+
+    case META_BUTTON_TYPE_RIGHT_SINGLE_BACKGROUND:
+      *rect = fgeom->right_single_background;
+      break;
+
+    case META_BUTTON_TYPE_CLOSE:
+      *rect = fgeom->close_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_SHADE:
+      *rect = fgeom->shade_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_UNSHADE:
+      *rect = fgeom->unshade_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_ABOVE:
+      *rect = fgeom->above_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_UNABOVE:
+      *rect = fgeom->unabove_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_STICK:
+      *rect = fgeom->stick_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_UNSTICK:
+      *rect = fgeom->unstick_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_MAXIMIZE:
+      *rect = fgeom->max_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_MINIMIZE:
+      *rect = fgeom->min_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_MENU:
+      *rect = fgeom->menu_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_APPMENU:
+      *rect = fgeom->appmenu_rect.visible;
+      break;
+
+    case META_BUTTON_TYPE_LAST:
+      g_assert_not_reached ();
+      break;
+    }
+}
+
+static void
+meta_frame_style_draw_with_style (MetaFrameStyle          *frame_style,
+                                  MetaStyleInfo           *style_info,
+                                  cairo_t                 *cr,
+                                  const MetaFrameGeometry *fgeom,
+                                  PangoLayout             *title_layout,
+                                  MetaFrameFlags           flags,
+                                  MetaButtonState          button_states[META_BUTTON_TYPE_LAST],
+                                  GdkPixbuf               *mini_icon)
+{
+  GtkStyleContext *style;
+  GtkStateFlags state;
+  MetaButtonType button_type;
+  GdkRectangle visible_rect;
+  GdkRectangle titlebar_rect;
+  GdkRectangle button_rect;
+  const MetaFrameBorders *borders;
+
+  borders = &fgeom->borders;
+
+  visible_rect.x = borders->invisible.left;
+  visible_rect.y = borders->invisible.top;
+  visible_rect.width = fgeom->width - borders->invisible.left - borders->invisible.right;
+  visible_rect.height = fgeom->height - borders->invisible.top - borders->invisible.bottom;
+
+  meta_style_info_set_flags (style_info, flags);
+
+  style = style_info->styles[META_STYLE_ELEMENT_FRAME];
+  gtk_render_background (style, cr,
+                         visible_rect.x, visible_rect.y,
+                         visible_rect.width, visible_rect.height);
   gtk_render_frame (style, cr,
                     visible_rect.x, visible_rect.y,
                     visible_rect.width, visible_rect.height);
@@ -758,7 +4608,7 @@
   titlebar_rect.x = visible_rect.x;
   titlebar_rect.y = visible_rect.y;
   titlebar_rect.width = visible_rect.width;
-  titlebar_rect.height = borders->visible.top / scale;
+  titlebar_rect.height = borders->visible.top;
 
   style = style_info->styles[META_STYLE_ELEMENT_TITLEBAR];
   gtk_render_background (style, cr,
@@ -768,7 +4618,7 @@
                     titlebar_rect.x, titlebar_rect.y,
                     titlebar_rect.width, titlebar_rect.height);
 
-  if (layout->has_title && title_layout)
+  if (frame_style->layout->has_title && title_layout)
     {
       PangoRectangle logical;
       int text_width, x, y;
@@ -776,7 +4626,7 @@
       pango_layout_set_width (title_layout, -1);
       pango_layout_get_pixel_extents (title_layout, NULL, &logical);
 
-      text_width = MIN(fgeom->title_rect.width / scale, logical.width);
+      text_width = MIN(fgeom->title_rect.width, logical.width);
 
       if (text_width < logical.width)
         pango_layout_set_width (title_layout, PANGO_SCALE * text_width);
@@ -785,10 +4635,10 @@
       x = titlebar_rect.x + (titlebar_rect.width - text_width) / 2;
       y = titlebar_rect.y + (titlebar_rect.height - logical.height) / 2;
 
-      if (x < fgeom->title_rect.x / scale)
-        x = fgeom->title_rect.x / scale;
-      else if (x + text_width > (fgeom->title_rect.x + fgeom->title_rect.width) / scale)
-        x = (fgeom->title_rect.x + fgeom->title_rect.width) / scale - text_width;
+      if (x < fgeom->title_rect.x)
+        x = fgeom->title_rect.x;
+      else if (x + text_width > fgeom->title_rect.x + fgeom->title_rect.width)
+        x = fgeom->title_rect.x + fgeom->title_rect.width - text_width;
 
       style = style_info->styles[META_STYLE_ELEMENT_TITLE];
       gtk_render_layout (style, cr, x, y, title_layout);
@@ -798,20 +4648,15 @@
   state = gtk_style_context_get_state (style);
   for (button_type = META_BUTTON_TYPE_CLOSE; button_type < META_BUTTON_TYPE_LAST; button_type++)
     {
-      const char *button_class = get_class_from_button_type (button_type);
-      if (button_class)
-        gtk_style_context_add_class (style, button_class);
-
-      get_button_rect (button_type, fgeom, &button_rect);
-
-      button_rect.x /= scale;
-      button_rect.y /= scale;
-      button_rect.width /= scale;
-      button_rect.height /= scale;
+      MetaButtonState button_state;
 
-      if (button_states[button_type] == META_BUTTON_STATE_PRELIGHT)
+      get_button_rect (button_type, fgeom, 0, &button_rect);
+
+      button_state = map_button_state (button_type, fgeom, 0, button_states);
+
+      if (button_state == META_BUTTON_STATE_PRELIGHT)
         gtk_style_context_set_state (style, state | GTK_STATE_PRELIGHT);
-      else if (button_states[button_type] == META_BUTTON_STATE_PRESSED)
+      else if (button_state == META_BUTTON_STATE_PRESSED)
         gtk_style_context_set_state (style, state | GTK_STATE_ACTIVE);
       else
         gtk_style_context_set_state (style, state);
@@ -820,7 +4665,7 @@
 
       if (button_rect.width > 0 && button_rect.height > 0)
         {
-          cairo_surface_t *surface = NULL;
+          GdkPixbuf *pixbuf = NULL;
           const char *icon_name = NULL;
 
           gtk_render_background (style, cr,
@@ -848,7 +4693,7 @@
                icon_name = "open-menu-symbolic";
                break;
             case META_BUTTON_TYPE_APPMENU:
-               surface = cairo_surface_reference (mini_icon);
+               pixbuf = g_object_ref (mini_icon);
                break;
             default:
                icon_name = NULL;
@@ -859,38 +4704,251 @@
             {
               GtkIconTheme *theme = gtk_icon_theme_get_default ();
               GtkIconInfo *info;
-              GdkPixbuf *pixbuf;
 
-              info = gtk_icon_theme_lookup_icon_for_scale (theme, icon_name,
-                                                           layout->icon_size, scale, 0);
+              info = gtk_icon_theme_lookup_icon (theme, icon_name, frame_style->layout->icon_size, 0);
               pixbuf = gtk_icon_info_load_symbolic_for_context (info, style, NULL, NULL);
-              surface = gdk_cairo_surface_create_from_pixbuf (pixbuf, scale, NULL);
             }
 
-          if (surface)
-            {
-              float width, height;
-              int x, y;
+          if (pixbuf)
+            {
+              float width, height;
+              int x, y;
+
+              width = gdk_pixbuf_get_width (pixbuf);
+              height = gdk_pixbuf_get_height (pixbuf);
+              x = button_rect.x + (button_rect.width - width) / 2;
+              y = button_rect.y + (button_rect.height - height) / 2;
+
+              cairo_translate (cr, x, y);
+              cairo_scale (cr,
+                           width / frame_style->layout->icon_size,
+                           height / frame_style->layout->icon_size);
+
+              gdk_cairo_set_source_pixbuf (cr, pixbuf, 0, 0);
+              cairo_paint (cr);
+
+              g_object_unref (pixbuf);
+            }
+        }
+      cairo_restore (cr);
+    }
+}
+
+MetaFrameStyleSet*
+meta_frame_style_set_new (MetaFrameStyleSet *parent)
+{
+  MetaFrameStyleSet *style_set;
+
+  style_set = g_new0 (MetaFrameStyleSet, 1);
+
+  style_set->parent = parent;
+  if (parent)
+    meta_frame_style_set_ref (parent);
+
+  style_set->refcount = 1;
+
+  return style_set;
+}
+
+static void
+free_focus_styles (MetaFrameStyle *focus_styles[META_FRAME_FOCUS_LAST])
+{
+  int i;
+
+  for (i = 0; i < META_FRAME_FOCUS_LAST; i++)
+    if (focus_styles[i])
+      meta_frame_style_unref (focus_styles[i]);
+}
+
+void
+meta_frame_style_set_ref (MetaFrameStyleSet *style_set)
+{
+  g_return_if_fail (style_set != NULL);
+
+  style_set->refcount += 1;
+}
+
+void
+meta_frame_style_set_unref (MetaFrameStyleSet *style_set)
+{
+  g_return_if_fail (style_set != NULL);
+  g_return_if_fail (style_set->refcount > 0);
+
+  style_set->refcount -= 1;
+
+  if (style_set->refcount == 0)
+    {
+      int i;
+
+      for (i = 0; i < META_FRAME_RESIZE_LAST; i++)
+        {
+          free_focus_styles (style_set->normal_styles[i]);
+          free_focus_styles (style_set->shaded_styles[i]);
+        }
+
+      free_focus_styles (style_set->maximized_styles);
+      free_focus_styles (style_set->tiled_left_styles);
+      free_focus_styles (style_set->tiled_right_styles);
+      free_focus_styles (style_set->maximized_and_shaded_styles);
+      free_focus_styles (style_set->tiled_left_and_shaded_styles);
+      free_focus_styles (style_set->tiled_right_and_shaded_styles);
+
+      if (style_set->parent)
+        meta_frame_style_set_unref (style_set->parent);
+
+      DEBUG_FILL_STRUCT (style_set);
+      g_free (style_set);
+    }
+}
+
+
+static MetaFrameStyle*
+get_style (MetaFrameStyleSet *style_set,
+           MetaFrameState     state,
+           MetaFrameResize    resize,
+           MetaFrameFocus     focus)
+{
+  MetaFrameStyle *style;
+
+  style = NULL;
+
+  switch (state)
+    {
+    case META_FRAME_STATE_NORMAL:
+    case META_FRAME_STATE_SHADED:
+      {
+        if (state == META_FRAME_STATE_SHADED)
+          style = style_set->shaded_styles[resize][focus];
+        else
+          style = style_set->normal_styles[resize][focus];
+
+        /* Try parent if we failed here */
+        if (style == NULL && style_set->parent)
+          style = get_style (style_set->parent, state, resize, focus);
+
+        /* Allow people to omit the vert/horz/none resize modes */
+        if (style == NULL &&
+            resize != META_FRAME_RESIZE_BOTH)
+          style = get_style (style_set, state, META_FRAME_RESIZE_BOTH, focus);
+      }
+      break;
+    default:
+      {
+        MetaFrameStyle **styles;
+
+        styles = NULL;
+
+        switch (state)
+          {
+          case META_FRAME_STATE_MAXIMIZED:
+            styles = style_set->maximized_styles;
+            break;
+          case META_FRAME_STATE_TILED_LEFT:
+            styles = style_set->tiled_left_styles;
+            break;
+          case META_FRAME_STATE_TILED_RIGHT:
+            styles = style_set->tiled_right_styles;
+            break;
+          case META_FRAME_STATE_MAXIMIZED_AND_SHADED:
+            styles = style_set->maximized_and_shaded_styles;
+            break;
+          case META_FRAME_STATE_TILED_LEFT_AND_SHADED:
+            styles = style_set->tiled_left_and_shaded_styles;
+            break;
+          case META_FRAME_STATE_TILED_RIGHT_AND_SHADED:
+            styles = style_set->tiled_right_and_shaded_styles;
+            break;
+          case META_FRAME_STATE_NORMAL:
+          case META_FRAME_STATE_SHADED:
+          case META_FRAME_STATE_LAST:
+            g_assert_not_reached ();
+            break;
+          }
+
+        style = styles[focus];
+
+        /* Tiled states are optional, try falling back to non-tiled states */
+        if (style == NULL)
+          {
+            if (state == META_FRAME_STATE_TILED_LEFT ||
+                state == META_FRAME_STATE_TILED_RIGHT)
+              style = get_style (style_set, META_FRAME_STATE_NORMAL,
+                                 resize, focus);
+            else if (state == META_FRAME_STATE_TILED_LEFT_AND_SHADED ||
+                     state == META_FRAME_STATE_TILED_RIGHT_AND_SHADED)
+              style = get_style (style_set, META_FRAME_STATE_SHADED,
+                                 resize, focus);
+          }
+
+        /* Try parent if we failed here */
+        if (style == NULL && style_set->parent)
+          style = get_style (style_set->parent, state, resize, focus);
+      }
+    }
+
+  return style;
+}
+
+static gboolean
+check_state  (MetaFrameStyleSet *style_set,
+              MetaFrameState     state,
+              GError           **error)
+{
+  int i;
+
+  for (i = 0; i < META_FRAME_FOCUS_LAST; i++)
+    {
+      if (get_style (style_set, state,
+                     META_FRAME_RESIZE_NONE, i) == NULL)
+        {
+          /* Translators: This error occurs when a <frame> tag is missing
+           * in theme XML.  The "<frame ...>" is intended as a noun phrase,
+           * and the "missing" qualifies it.  You should translate "whatever".
+           */
+          g_set_error (error, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Missing <frame state=\"%s\" resize=\"%s\" focus=\"%s\" style=\"whatever\"/>"),
+                       meta_frame_state_to_string (state),
+                       meta_frame_resize_to_string (META_FRAME_RESIZE_NONE),
+                       meta_frame_focus_to_string (i));
+          return FALSE;
+        }
+    }
+
+  return TRUE;
+}
 
-              width = cairo_image_surface_get_width (surface) / scale;
-              height = cairo_image_surface_get_height (surface) / scale;
-              x = button_rect.x + (button_rect.width - width) / 2;
-              y = button_rect.y + (button_rect.height - height) / 2;
+gboolean
+meta_frame_style_set_validate  (MetaFrameStyleSet *style_set,
+                                GError           **error)
+{
+  int i, j;
 
-              cairo_translate (cr, x, y);
-              cairo_scale (cr,
-                           width / layout->icon_size,
-                           height / layout->icon_size);
-              cairo_set_source_surface (cr, surface, 0, 0);
-              cairo_paint (cr);
+  g_return_val_if_fail (style_set != NULL, FALSE);
 
-              cairo_surface_destroy (surface);
-            }
+  for (i = 0; i < META_FRAME_RESIZE_LAST; i++)
+    for (j = 0; j < META_FRAME_FOCUS_LAST; j++)
+      if (get_style (style_set, META_FRAME_STATE_NORMAL, i, j) == NULL)
+        {
+          g_set_error (error, META_THEME_ERROR,
+                       META_THEME_ERROR_FAILED,
+                       _("Missing <frame state=\"%s\" resize=\"%s\" focus=\"%s\" style=\"whatever\"/>"),
+                       meta_frame_state_to_string (META_FRAME_STATE_NORMAL),
+                       meta_frame_resize_to_string (i),
+                       meta_frame_focus_to_string (j));
+          return FALSE;
         }
-      cairo_restore (cr);
-      if (button_class)
-        gtk_style_context_remove_class (style, button_class);
-    }
+
+  if (!check_state (style_set, META_FRAME_STATE_SHADED, error))
+    return FALSE;
+
+  if (!check_state (style_set, META_FRAME_STATE_MAXIMIZED, error))
+    return FALSE;
+
+  if (!check_state (style_set, META_FRAME_STATE_MAXIMIZED_AND_SHADED, error))
+    return FALSE;
+
+  return TRUE;
 }
 
 /**
@@ -901,7 +4959,7 @@
 meta_theme_get_default (void)
 {
   static MetaTheme *theme = NULL;
-  int frame_type;
+  int i, j, frame_type;
 
   if (theme)
     return theme;
@@ -910,7 +4968,10 @@
 
   for (frame_type = 0; frame_type < META_FRAME_TYPE_LAST; frame_type++)
     {
-      MetaFrameLayout *layout = meta_frame_layout_new ();
+      MetaFrameStyleSet *style_set = meta_frame_style_set_new (NULL);
+      MetaFrameStyle *style = meta_frame_style_new (NULL);
+
+      style->layout = meta_frame_layout_new ();
 
       switch (frame_type)
         {
@@ -919,21 +4980,52 @@
         case META_FRAME_TYPE_DIALOG:
         case META_FRAME_TYPE_MODAL_DIALOG:
         case META_FRAME_TYPE_ATTACHED:
-          layout->hide_buttons = TRUE;
+          style->layout->hide_buttons = TRUE;
           break;
         case META_FRAME_TYPE_MENU:
         case META_FRAME_TYPE_UTILITY:
-          layout->title_scale = PANGO_SCALE_SMALL;
+          style->layout->title_scale = PANGO_SCALE_SMALL;
           break;
         case META_FRAME_TYPE_BORDER:
-          layout->has_title = FALSE;
-          layout->hide_buttons = TRUE;
+          style->layout->has_title = FALSE;
+          style->layout->hide_buttons = TRUE;
           break;
         default:
           g_assert_not_reached ();
         }
 
-      theme->layouts[frame_type] = layout;
+      for (i = 0; i < META_FRAME_FOCUS_LAST; i++)
+        {
+          for (j = 0; j < META_FRAME_RESIZE_LAST; j++)
+            {
+              meta_frame_style_ref (style);
+              style_set->normal_styles[j][i] = style;
+
+              meta_frame_style_ref (style);
+              style_set->shaded_styles[j][i] = style;
+            }
+
+          meta_frame_style_ref (style);
+          style_set->maximized_styles[i] = style;
+
+          meta_frame_style_ref (style);
+          style_set->tiled_left_styles[i] = style;
+
+          meta_frame_style_ref (style);
+          style_set->tiled_right_styles[i] = style;
+
+          meta_frame_style_ref (style);
+          style_set->maximized_and_shaded_styles[i] = style;
+
+          meta_frame_style_ref (style);
+          style_set->tiled_left_and_shaded_styles[i] = style;
+
+          meta_frame_style_ref (style);
+          style_set->tiled_right_and_shaded_styles[i] = style;
+        }
+
+      meta_frame_style_unref (style);
+      theme->style_sets_by_type[frame_type] = style_set;
     }
   return theme;
 }
@@ -945,7 +5037,59 @@
 MetaTheme*
 meta_theme_new (void)
 {
-  return g_new0 (MetaTheme, 1);
+  MetaTheme *theme;
+
+  theme = g_new0 (MetaTheme, 1);
+
+  theme->images_by_filename =
+    g_hash_table_new_full (g_str_hash,
+                           g_str_equal,
+                           g_free,
+                           (GDestroyNotify) g_object_unref);
+
+  theme->layouts_by_name =
+    g_hash_table_new_full (g_str_hash,
+                           g_str_equal,
+                           g_free,
+                           (GDestroyNotify) meta_frame_layout_unref);
+
+  theme->draw_op_lists_by_name =
+    g_hash_table_new_full (g_str_hash,
+                           g_str_equal,
+                           g_free,
+                           (GDestroyNotify) meta_draw_op_list_unref);
+
+  theme->styles_by_name =
+    g_hash_table_new_full (g_str_hash,
+                           g_str_equal,
+                           g_free,
+                           (GDestroyNotify) meta_frame_style_unref);
+
+  theme->style_sets_by_name =
+    g_hash_table_new_full (g_str_hash,
+                           g_str_equal,
+                           g_free,
+                           (GDestroyNotify) meta_frame_style_set_unref);
+
+  /* Create our variable quarks so we can look up variables without
+     having to strcmp for the names */
+  theme->quark_width = g_quark_from_static_string ("width");
+  theme->quark_height = g_quark_from_static_string ("height");
+  theme->quark_object_width = g_quark_from_static_string ("object_width");
+  theme->quark_object_height = g_quark_from_static_string ("object_height");
+  theme->quark_left_width = g_quark_from_static_string ("left_width");
+  theme->quark_right_width = g_quark_from_static_string ("right_width");
+  theme->quark_top_height = g_quark_from_static_string ("top_height");
+  theme->quark_bottom_height = g_quark_from_static_string ("bottom_height");
+  theme->quark_mini_icon_width = g_quark_from_static_string ("mini_icon_width");
+  theme->quark_mini_icon_height = g_quark_from_static_string ("mini_icon_height");
+  theme->quark_icon_width = g_quark_from_static_string ("icon_width");
+  theme->quark_icon_height = g_quark_from_static_string ("icon_height");
+  theme->quark_title_width = g_quark_from_static_string ("title_width");
+  theme->quark_title_height = g_quark_from_static_string ("title_height");
+  theme->quark_frame_x_center = g_quark_from_static_string ("frame_x_center");
+  theme->quark_frame_y_center = g_quark_from_static_string ("frame_y_center");
+  return theme;
 }
 
 
@@ -956,21 +5100,260 @@
 
   g_return_if_fail (theme != NULL);
 
+  g_free (theme->name);
+  g_free (theme->dirname);
+  g_free (theme->filename);
+  g_free (theme->readable_name);
+  g_free (theme->date);
+  g_free (theme->description);
+  g_free (theme->author);
+  g_free (theme->copyright);
+
+  /* be more careful when destroying the theme hash tables,
+     since they are only constructed as needed, and may be NULL. */
+  if (theme->integer_constants)
+    g_hash_table_destroy (theme->integer_constants);
+  if (theme->images_by_filename)
+    g_hash_table_destroy (theme->images_by_filename);
+  if (theme->layouts_by_name)
+    g_hash_table_destroy (theme->layouts_by_name);
+  if (theme->draw_op_lists_by_name)
+    g_hash_table_destroy (theme->draw_op_lists_by_name);
+  if (theme->styles_by_name)
+    g_hash_table_destroy (theme->styles_by_name);
+  if (theme->style_sets_by_name)
+    g_hash_table_destroy (theme->style_sets_by_name);
+
   for (i = 0; i < META_FRAME_TYPE_LAST; i++)
-    if (theme->layouts[i])
-      meta_frame_layout_free (theme->layouts[i]);
+    if (theme->style_sets_by_type[i])
+      meta_frame_style_set_unref (theme->style_sets_by_type[i]);
 
   DEBUG_FILL_STRUCT (theme);
   g_free (theme);
 }
 
-MetaFrameLayout*
-meta_theme_get_frame_layout (MetaTheme     *theme,
-                             MetaFrameType  type)
+gboolean
+meta_theme_validate (MetaTheme *theme,
+                     GError   **error)
+{
+  int i;
+
+  g_return_val_if_fail (theme != NULL, FALSE);
+
+  /* FIXME what else should be checked? */
+
+  g_assert (theme->name);
+
+  if (theme->readable_name == NULL)
+    {
+      /* Translators: This error means that a necessary XML tag (whose name
+       * is given in angle brackets) was not found in a given theme (whose
+       * name is given second, in quotation marks).
+       */
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("No <%s> set for theme \"%s\""), "name", theme->name);
+      return FALSE;
+    }
+
+  if (theme->author == NULL)
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("No <%s> set for theme \"%s\""), "author", theme->name);
+      return FALSE;
+    }
+
+  if (theme->date == NULL)
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("No <%s> set for theme \"%s\""), "date", theme->name);
+      return FALSE;
+    }
+
+  if (theme->description == NULL)
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("No <%s> set for theme \"%s\""), "description", theme->name);
+      return FALSE;
+    }
+
+  if (theme->copyright == NULL)
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("No <%s> set for theme \"%s\""), "copyright", theme->name);
+      return FALSE;
+    }
+
+  for (i = 0; i < (int)META_FRAME_TYPE_LAST; i++)
+    if (i != (int)META_FRAME_TYPE_ATTACHED && theme->style_sets_by_type[i] == NULL)
+      {
+        g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                     _("No frame style set for window type \"%s\" in theme \"%s\", add a <window type=\"%s\" style_set=\"whatever\"/> element"),
+                     meta_frame_type_to_string (i),
+                     theme->name,
+                     meta_frame_type_to_string (i));
+
+        return FALSE;
+      }
+
+  return TRUE;
+}
+
+/**
+ * meta_theme_load_image: (skip)
+ *
+ */
+GdkPixbuf*
+meta_theme_load_image (MetaTheme  *theme,
+                       const char *filename,
+                       guint size_of_theme_icons,
+                       GError    **error)
+{
+  GdkPixbuf *pixbuf;
+
+  pixbuf = g_hash_table_lookup (theme->images_by_filename,
+                                filename);
+
+  if (pixbuf == NULL)
+    {
+
+      if (g_str_has_prefix (filename, "theme:") &&
+          META_THEME_ALLOWS (theme, META_THEME_IMAGES_FROM_ICON_THEMES))
+        {
+          pixbuf = gtk_icon_theme_load_icon (
+              gtk_icon_theme_get_default (),
+              filename+6,
+              size_of_theme_icons,
+              0,
+              error);
+          if (pixbuf == NULL) return NULL;
+         }
+      else
+        {
+          char *full_path;
+          full_path = g_build_filename (theme->dirname, filename, NULL);
+
+          pixbuf = gdk_pixbuf_new_from_file (full_path, error);
+          if (pixbuf == NULL)
+            {
+              g_free (full_path);
+              return NULL;
+            }
+
+          g_free (full_path);
+        }
+      g_hash_table_replace (theme->images_by_filename,
+                            g_strdup (filename),
+                            pixbuf);
+    }
+
+  g_assert (pixbuf);
+
+  g_object_ref (G_OBJECT (pixbuf));
+
+  return pixbuf;
+}
+
+static MetaFrameStyle*
+theme_get_style (MetaTheme     *theme,
+                 MetaFrameType  type,
+                 MetaFrameFlags flags)
+{
+  MetaFrameState state;
+  MetaFrameResize resize;
+  MetaFrameFocus focus;
+  MetaFrameStyle *style;
+  MetaFrameStyleSet *style_set;
+
+  style_set = theme->style_sets_by_type[type];
+
+  if (style_set == NULL && type == META_FRAME_TYPE_ATTACHED)
+    style_set = theme->style_sets_by_type[META_FRAME_TYPE_BORDER];
+
+  /* Right now the parser forces a style set for all other types,
+   * but this fallback code is here in case I take that out.
+   */
+  if (style_set == NULL)
+    style_set = theme->style_sets_by_type[META_FRAME_TYPE_NORMAL];
+  if (style_set == NULL)
+    return NULL;
+
+  switch (flags & (META_FRAME_MAXIMIZED | META_FRAME_SHADED |
+                   META_FRAME_TILED_LEFT | META_FRAME_TILED_RIGHT))
+    {
+    case 0:
+      state = META_FRAME_STATE_NORMAL;
+      break;
+    case META_FRAME_MAXIMIZED:
+      state = META_FRAME_STATE_MAXIMIZED;
+      break;
+    case META_FRAME_TILED_LEFT:
+      state = META_FRAME_STATE_TILED_LEFT;
+      break;
+    case META_FRAME_TILED_RIGHT:
+      state = META_FRAME_STATE_TILED_RIGHT;
+      break;
+    case META_FRAME_SHADED:
+      state = META_FRAME_STATE_SHADED;
+      break;
+    case (META_FRAME_MAXIMIZED | META_FRAME_SHADED):
+      state = META_FRAME_STATE_MAXIMIZED_AND_SHADED;
+      break;
+    case (META_FRAME_TILED_LEFT | META_FRAME_SHADED):
+      state = META_FRAME_STATE_TILED_LEFT_AND_SHADED;
+      break;
+    case (META_FRAME_TILED_RIGHT | META_FRAME_SHADED):
+      state = META_FRAME_STATE_TILED_RIGHT_AND_SHADED;
+      break;
+    default:
+      g_assert_not_reached ();
+      state = META_FRAME_STATE_LAST; /* compiler */
+      break;
+    }
+
+  switch (flags & (META_FRAME_ALLOWS_VERTICAL_RESIZE | META_FRAME_ALLOWS_HORIZONTAL_RESIZE))
+    {
+    case 0:
+      resize = META_FRAME_RESIZE_NONE;
+      break;
+    case META_FRAME_ALLOWS_VERTICAL_RESIZE:
+      resize = META_FRAME_RESIZE_VERTICAL;
+      break;
+    case META_FRAME_ALLOWS_HORIZONTAL_RESIZE:
+      resize = META_FRAME_RESIZE_HORIZONTAL;
+      break;
+    case (META_FRAME_ALLOWS_VERTICAL_RESIZE | META_FRAME_ALLOWS_HORIZONTAL_RESIZE):
+      resize = META_FRAME_RESIZE_BOTH;
+      break;
+    default:
+      g_assert_not_reached ();
+      resize = META_FRAME_RESIZE_LAST; /* compiler */
+      break;
+    }
+
+  /* re invert the styles used for focus/unfocussed while flashing a frame */
+  if (((flags & META_FRAME_HAS_FOCUS) && !(flags & META_FRAME_IS_FLASHING))
+      || (!(flags & META_FRAME_HAS_FOCUS) && (flags & META_FRAME_IS_FLASHING)))
+    focus = META_FRAME_FOCUS_YES;
+  else
+    focus = META_FRAME_FOCUS_NO;
+
+  style = get_style (style_set, state, resize, focus);
+
+  return style;
+}
+
+MetaFrameStyle*
+meta_theme_get_frame_style (MetaTheme     *theme,
+                            MetaFrameType  type,
+                            MetaFrameFlags flags)
 {
+  MetaFrameStyle *style;
+
   g_return_val_if_fail (type < META_FRAME_TYPE_LAST, NULL);
 
-  return theme->layouts[type];
+  style = theme_get_style (theme, type, flags);
+
+  return style;
 }
 
 static GtkStyleContext *
@@ -986,7 +5369,6 @@
   va_list ap;
 
   style = gtk_style_context_new ();
-  gtk_style_context_set_scale (style, meta_theme_get_window_scaling_factor ());
   gtk_style_context_set_parent (style, parent_style);
 
   if (parent_style)
@@ -1194,20 +5576,20 @@
                        int                     text_height,
                        const MetaButtonLayout *button_layout,
                        MetaButtonState         button_states[META_BUTTON_TYPE_LAST],
-                       cairo_surface_t        *mini_icon)
+                       GdkPixbuf              *mini_icon)
 {
   MetaFrameGeometry fgeom;
-  MetaFrameLayout *layout;
+  MetaFrameStyle *style;
 
   g_return_if_fail (type < META_FRAME_TYPE_LAST);
 
-  layout = theme->layouts[type];
+  style = theme_get_style (theme, type, flags);
 
   /* Parser is not supposed to allow this currently */
-  if (layout == NULL)
+  if (style == NULL)
     return;
 
-  meta_frame_layout_calc_geometry (layout,
+  meta_frame_layout_calc_geometry (style->layout,
                                    style_info,
                                    text_height,
                                    flags,
@@ -1217,74 +5599,341 @@
                                    &fgeom,
                                    theme);
 
-  meta_frame_layout_draw_with_style (layout,
-                                     style_info,
-                                     cr,
-                                     &fgeom,
-                                     title_layout,
-                                     flags,
-                                     button_states,
-                                     mini_icon);
+  meta_frame_style_draw_with_style (style,
+                                    style_info,
+                                    cr,
+                                    &fgeom,
+                                    title_layout,
+                                    flags,
+                                    button_states,
+                                    mini_icon);
+}
+
+void
+meta_theme_get_frame_borders (MetaTheme        *theme,
+                              MetaStyleInfo    *style_info,
+                              MetaFrameType     type,
+                              int               text_height,
+                              MetaFrameFlags    flags,
+                              MetaFrameBorders *borders)
+{
+  MetaFrameStyle *style;
+
+  g_return_if_fail (type < META_FRAME_TYPE_LAST);
+
+  style = theme_get_style (theme, type, flags);
+
+  meta_frame_borders_clear (borders);
+
+  /* Parser is not supposed to allow this currently */
+  if (style == NULL)
+    return;
+
+  meta_frame_layout_sync_with_style (style->layout, style_info, flags);
+
+  meta_frame_layout_get_borders (style->layout,
+                                 text_height,
+                                 flags, type,
+                                 borders);
+}
+
+void
+meta_theme_calc_geometry (MetaTheme              *theme,
+                          MetaStyleInfo          *style_info,
+                          MetaFrameType           type,
+                          int                     text_height,
+                          MetaFrameFlags          flags,
+                          int                     client_width,
+                          int                     client_height,
+                          const MetaButtonLayout *button_layout,
+                          MetaFrameGeometry      *fgeom)
+{
+  MetaFrameStyle *style;
+
+  g_return_if_fail (type < META_FRAME_TYPE_LAST);
+
+  style = theme_get_style (theme, type, flags);
+
+  /* Parser is not supposed to allow this currently */
+  if (style == NULL)
+    return;
+
+  meta_frame_layout_calc_geometry (style->layout,
+                                   style_info,
+                                   text_height,
+                                   flags,
+                                   client_width, client_height,
+                                   button_layout,
+                                   type,
+                                   fgeom,
+                                   theme);
+}
+
+MetaFrameLayout*
+meta_theme_lookup_layout (MetaTheme         *theme,
+                          const char        *name)
+{
+  return g_hash_table_lookup (theme->layouts_by_name, name);
+}
+
+void
+meta_theme_insert_layout (MetaTheme         *theme,
+                          const char        *name,
+                          MetaFrameLayout   *layout)
+{
+  meta_frame_layout_ref (layout);
+  g_hash_table_replace (theme->layouts_by_name, g_strdup (name), layout);
+}
+
+MetaDrawOpList*
+meta_theme_lookup_draw_op_list (MetaTheme         *theme,
+                                const char        *name)
+{
+  return g_hash_table_lookup (theme->draw_op_lists_by_name, name);
+}
+
+void
+meta_theme_insert_draw_op_list (MetaTheme         *theme,
+                                const char        *name,
+                                MetaDrawOpList    *op_list)
+{
+  meta_draw_op_list_ref (op_list);
+  g_hash_table_replace (theme->draw_op_lists_by_name, g_strdup (name), op_list);
+}
+
+MetaFrameStyle*
+meta_theme_lookup_style (MetaTheme         *theme,
+                         const char        *name)
+{
+  return g_hash_table_lookup (theme->styles_by_name, name);
+}
+
+void
+meta_theme_insert_style (MetaTheme         *theme,
+                         const char        *name,
+                         MetaFrameStyle    *style)
+{
+  meta_frame_style_ref (style);
+  g_hash_table_replace (theme->styles_by_name, g_strdup (name), style);
+}
+
+MetaFrameStyleSet*
+meta_theme_lookup_style_set (MetaTheme         *theme,
+                             const char        *name)
+{
+  return g_hash_table_lookup (theme->style_sets_by_name, name);
+}
+
+void
+meta_theme_insert_style_set    (MetaTheme         *theme,
+                                const char        *name,
+                                MetaFrameStyleSet *style_set)
+{
+  meta_frame_style_set_ref (style_set);
+  g_hash_table_replace (theme->style_sets_by_name, g_strdup (name), style_set);
+}
+
+static gboolean
+first_uppercase (const char *str)
+{
+  return g_ascii_isupper (*str);
+}
+
+gboolean
+meta_theme_define_int_constant (MetaTheme   *theme,
+                                const char  *name,
+                                int          value,
+                                GError     **error)
+{
+  if (theme->integer_constants == NULL)
+    theme->integer_constants = g_hash_table_new_full (g_str_hash,
+                                                      g_str_equal,
+                                                      g_free,
+                                                      NULL);
+
+  if (!first_uppercase (name))
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("User-defined constants must begin with a capital letter; \"%s\" does not"),
+                   name);
+      return FALSE;
+    }
+
+  if (g_hash_table_lookup_extended (theme->integer_constants, name, NULL, NULL))
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("Constant \"%s\" has already been defined"),
+                   name);
+
+      return FALSE;
+    }
+
+  g_hash_table_insert (theme->integer_constants,
+                       g_strdup (name),
+                       GINT_TO_POINTER (value));
+
+  return TRUE;
+}
+
+gboolean
+meta_theme_lookup_int_constant (MetaTheme   *theme,
+                                const char  *name,
+                                int         *value)
+{
+  gpointer old_value;
+
+  *value = 0;
+
+  if (theme->integer_constants == NULL)
+    return FALSE;
+
+  if (g_hash_table_lookup_extended (theme->integer_constants,
+                                    name, NULL, &old_value))
+    {
+      *value = GPOINTER_TO_INT (old_value);
+      return TRUE;
+    }
+  else
+    {
+      return FALSE;
+    }
+}
+
+gboolean
+meta_theme_define_float_constant (MetaTheme   *theme,
+                                  const char  *name,
+                                  double       value,
+                                  GError     **error)
+{
+  double *d;
+
+  if (theme->float_constants == NULL)
+    theme->float_constants = g_hash_table_new_full (g_str_hash,
+                                                    g_str_equal,
+                                                    g_free,
+                                                    g_free);
+
+  if (!first_uppercase (name))
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("User-defined constants must begin with a capital letter; \"%s\" does not"),
+                   name);
+      return FALSE;
+    }
+
+  if (g_hash_table_lookup_extended (theme->float_constants, name, NULL, NULL))
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("Constant \"%s\" has already been defined"),
+                   name);
+
+      return FALSE;
+    }
+
+  d = g_new (double, 1);
+  *d = value;
+
+  g_hash_table_insert (theme->float_constants,
+                       g_strdup (name), d);
+
+  return TRUE;
+}
+
+gboolean
+meta_theme_lookup_float_constant (MetaTheme   *theme,
+                                  const char  *name,
+                                  double      *value)
+{
+  double *d;
+
+  *value = 0.0;
+
+  if (theme->float_constants == NULL)
+    return FALSE;
+
+  d = g_hash_table_lookup (theme->float_constants, name);
+
+  if (d)
+    {
+      *value = *d;
+      return TRUE;
+    }
+  else
+    {
+      return FALSE;
+    }
 }
 
-void
-meta_theme_get_frame_borders (MetaTheme        *theme,
-                              MetaStyleInfo    *style_info,
-                              MetaFrameType     type,
-                              int               text_height,
-                              MetaFrameFlags    flags,
-                              MetaFrameBorders *borders)
+gboolean
+meta_theme_define_color_constant (MetaTheme   *theme,
+                                  const char  *name,
+                                  const char  *value,
+                                  GError     **error)
 {
-  MetaFrameLayout *layout;
-
-  g_return_if_fail (type < META_FRAME_TYPE_LAST);
+  if (theme->color_constants == NULL)
+    theme->color_constants = g_hash_table_new_full (g_str_hash,
+                                                    g_str_equal,
+                                                    g_free,
+                                                    NULL);
 
-  layout = theme->layouts[type];
+  if (!first_uppercase (name))
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("User-defined constants must begin with a capital letter; \"%s\" does not"),
+                   name);
+      return FALSE;
+    }
 
-  meta_frame_borders_clear (borders);
+  if (g_hash_table_lookup_extended (theme->color_constants, name, NULL, NULL))
+    {
+      g_set_error (error, META_THEME_ERROR, META_THEME_ERROR_FAILED,
+                   _("Constant \"%s\" has already been defined"),
+                   name);
 
-  /* Parser is not supposed to allow this currently */
-  if (layout == NULL)
-    return;
+      return FALSE;
+    }
 
-  meta_frame_layout_sync_with_style (layout, style_info, flags);
+  g_hash_table_insert (theme->color_constants,
+                       g_strdup (name),
+                       g_strdup (value));
 
-  meta_frame_layout_get_borders (layout,
-                                 text_height,
-                                 flags, type,
-                                 borders);
+  return TRUE;
 }
 
-void
-meta_theme_calc_geometry (MetaTheme              *theme,
-                          MetaStyleInfo          *style_info,
-                          MetaFrameType           type,
-                          int                     text_height,
-                          MetaFrameFlags          flags,
-                          int                     client_width,
-                          int                     client_height,
-                          const MetaButtonLayout *button_layout,
-                          MetaFrameGeometry      *fgeom)
+/**
+ * meta_theme_lookup_color_constant:
+ * @theme: the theme containing the constant
+ * @name: the name of the constant
+ * @value: (out): the string representation of the colour, or %NULL if it
+ *                doesn't exist
+ *
+ * Looks up a colour constant.
+ *
+ * Returns: %TRUE if it exists, %FALSE otherwise
+ */
+gboolean
+meta_theme_lookup_color_constant (MetaTheme   *theme,
+                                  const char  *name,
+                                  char       **value)
 {
-  MetaFrameLayout *layout;
+  char *result;
 
-  g_return_if_fail (type < META_FRAME_TYPE_LAST);
+  *value = NULL;
 
-  layout = theme->layouts[type];
+  if (theme->color_constants == NULL)
+    return FALSE;
 
-  /* Parser is not supposed to allow this currently */
-  if (layout == NULL)
-    return;
+  result = g_hash_table_lookup (theme->color_constants, name);
 
-  meta_frame_layout_calc_geometry (layout,
-                                   style_info,
-                                   text_height,
-                                   flags,
-                                   client_width, client_height,
-                                   button_layout,
-                                   type,
-                                   fgeom,
-                                   theme);
+  if (result)
+    {
+      *value = result;
+      return TRUE;
+    }
+  else
+    {
+      return FALSE;
+    }
 }
 
 /**
@@ -1315,6 +5964,328 @@
   return retval;
 }
 
+MetaGtkColorComponent
+meta_color_component_from_string (const char *str)
+{
+  if (strcmp ("fg", str) == 0)
+    return META_GTK_COLOR_FG;
+  else if (strcmp ("bg", str) == 0)
+    return META_GTK_COLOR_BG;
+  else if (strcmp ("light", str) == 0)
+    return META_GTK_COLOR_LIGHT;
+  else if (strcmp ("dark", str) == 0)
+    return META_GTK_COLOR_DARK;
+  else if (strcmp ("mid", str) == 0)
+    return META_GTK_COLOR_MID;
+  else if (strcmp ("text", str) == 0)
+    return META_GTK_COLOR_TEXT;
+  else if (strcmp ("base", str) == 0)
+    return META_GTK_COLOR_BASE;
+  else if (strcmp ("text_aa", str) == 0)
+    return META_GTK_COLOR_TEXT_AA;
+  else
+    return META_GTK_COLOR_LAST;
+}
+
+MetaButtonState
+meta_button_state_from_string (const char *str)
+{
+  if (strcmp ("normal", str) == 0)
+    return META_BUTTON_STATE_NORMAL;
+  else if (strcmp ("pressed", str) == 0)
+    return META_BUTTON_STATE_PRESSED;
+  else if (strcmp ("prelight", str) == 0)
+    return META_BUTTON_STATE_PRELIGHT;
+  else
+    return META_BUTTON_STATE_LAST;
+}
+
+const char*
+meta_button_state_to_string (MetaButtonState state)
+{
+  switch (state)
+    {
+    case META_BUTTON_STATE_NORMAL:
+      return "normal";
+    case META_BUTTON_STATE_PRESSED:
+      return "pressed";
+    case META_BUTTON_STATE_PRELIGHT:
+      return "prelight";
+    case META_BUTTON_STATE_LAST:
+      break;
+    }
+
+  return "<unknown>";
+}
+
+MetaButtonType
+meta_button_type_from_string (const char *str, MetaTheme *theme)
+{
+  if (META_THEME_ALLOWS(theme, META_THEME_SHADE_STICK_ABOVE_BUTTONS))
+    {
+      if (strcmp ("shade", str) == 0)
+        return META_BUTTON_TYPE_SHADE;
+      else if (strcmp ("above", str) == 0)
+        return META_BUTTON_TYPE_ABOVE;
+      else if (strcmp ("stick", str) == 0)
+        return META_BUTTON_TYPE_STICK;
+      else if (strcmp ("unshade", str) == 0)
+        return META_BUTTON_TYPE_UNSHADE;
+      else if (strcmp ("unabove", str) == 0)
+        return META_BUTTON_TYPE_UNABOVE;
+      else if (strcmp ("unstick", str) == 0)
+        return META_BUTTON_TYPE_UNSTICK;
+     }
+
+  if (strcmp ("close", str) == 0)
+    return META_BUTTON_TYPE_CLOSE;
+  else if (strcmp ("maximize", str) == 0)
+    return META_BUTTON_TYPE_MAXIMIZE;
+  else if (strcmp ("minimize", str) == 0)
+    return META_BUTTON_TYPE_MINIMIZE;
+  else if (strcmp ("menu", str) == 0)
+    return META_BUTTON_TYPE_MENU;
+  else if (strcmp ("appmenu", str) == 0)
+    return META_BUTTON_TYPE_APPMENU;
+  else if (strcmp ("left_left_background", str) == 0)
+    return META_BUTTON_TYPE_LEFT_LEFT_BACKGROUND;
+  else if (strcmp ("left_middle_background", str) == 0)
+    return META_BUTTON_TYPE_LEFT_MIDDLE_BACKGROUND;
+  else if (strcmp ("left_right_background", str) == 0)
+    return META_BUTTON_TYPE_LEFT_RIGHT_BACKGROUND;
+  else if (strcmp ("left_single_background", str) == 0)
+    return META_BUTTON_TYPE_LEFT_SINGLE_BACKGROUND;
+  else if (strcmp ("right_left_background", str) == 0)
+    return META_BUTTON_TYPE_RIGHT_LEFT_BACKGROUND;
+  else if (strcmp ("right_middle_background", str) == 0)
+    return META_BUTTON_TYPE_RIGHT_MIDDLE_BACKGROUND;
+  else if (strcmp ("right_right_background", str) == 0)
+    return META_BUTTON_TYPE_RIGHT_RIGHT_BACKGROUND;
+  else if (strcmp ("right_single_background", str) == 0)
+    return META_BUTTON_TYPE_RIGHT_SINGLE_BACKGROUND;
+  else
+    return META_BUTTON_TYPE_LAST;
+}
+
+const char*
+meta_button_type_to_string (MetaButtonType type)
+{
+  switch (type)
+    {
+    case META_BUTTON_TYPE_CLOSE:
+      return "close";
+    case META_BUTTON_TYPE_MAXIMIZE:
+      return "maximize";
+    case META_BUTTON_TYPE_MINIMIZE:
+      return "minimize";
+    case META_BUTTON_TYPE_SHADE:
+     return "shade";
+    case META_BUTTON_TYPE_ABOVE:
+      return "above";
+    case META_BUTTON_TYPE_STICK:
+      return "stick";
+    case META_BUTTON_TYPE_UNSHADE:
+      return "unshade";
+    case META_BUTTON_TYPE_UNABOVE:
+      return "unabove";
+    case META_BUTTON_TYPE_UNSTICK:
+      return "unstick";
+     case META_BUTTON_TYPE_MENU:
+      return "menu";
+    case META_BUTTON_TYPE_APPMENU:
+      return "appmenu";
+    case META_BUTTON_TYPE_LEFT_LEFT_BACKGROUND:
+      return "left_left_background";
+    case META_BUTTON_TYPE_LEFT_MIDDLE_BACKGROUND:
+      return "left_middle_background";
+    case META_BUTTON_TYPE_LEFT_RIGHT_BACKGROUND:
+      return "left_right_background";
+    case META_BUTTON_TYPE_LEFT_SINGLE_BACKGROUND:
+      return "left_single_background";
+    case META_BUTTON_TYPE_RIGHT_LEFT_BACKGROUND:
+      return "right_left_background";
+    case META_BUTTON_TYPE_RIGHT_MIDDLE_BACKGROUND:
+      return "right_middle_background";
+    case META_BUTTON_TYPE_RIGHT_RIGHT_BACKGROUND:
+      return "right_right_background";
+    case META_BUTTON_TYPE_RIGHT_SINGLE_BACKGROUND:
+      return "right_single_background";
+    case META_BUTTON_TYPE_LAST:
+      break;
+    }
+
+  return "<unknown>";
+}
+
+MetaFramePiece
+meta_frame_piece_from_string (const char *str)
+{
+  if (strcmp ("entire_background", str) == 0)
+    return META_FRAME_PIECE_ENTIRE_BACKGROUND;
+  else if (strcmp ("titlebar", str) == 0)
+    return META_FRAME_PIECE_TITLEBAR;
+  else if (strcmp ("titlebar_middle", str) == 0)
+    return META_FRAME_PIECE_TITLEBAR_MIDDLE;
+  else if (strcmp ("left_titlebar_edge", str) == 0)
+    return META_FRAME_PIECE_LEFT_TITLEBAR_EDGE;
+  else if (strcmp ("right_titlebar_edge", str) == 0)
+    return META_FRAME_PIECE_RIGHT_TITLEBAR_EDGE;
+  else if (strcmp ("top_titlebar_edge", str) == 0)
+    return META_FRAME_PIECE_TOP_TITLEBAR_EDGE;
+  else if (strcmp ("bottom_titlebar_edge", str) == 0)
+    return META_FRAME_PIECE_BOTTOM_TITLEBAR_EDGE;
+  else if (strcmp ("title", str) == 0)
+    return META_FRAME_PIECE_TITLE;
+  else if (strcmp ("left_edge", str) == 0)
+    return META_FRAME_PIECE_LEFT_EDGE;
+  else if (strcmp ("right_edge", str) == 0)
+    return META_FRAME_PIECE_RIGHT_EDGE;
+  else if (strcmp ("bottom_edge", str) == 0)
+    return META_FRAME_PIECE_BOTTOM_EDGE;
+  else if (strcmp ("overlay", str) == 0)
+    return META_FRAME_PIECE_OVERLAY;
+  else
+    return META_FRAME_PIECE_LAST;
+}
+
+MetaFrameState
+meta_frame_state_from_string (const char *str)
+{
+  if (strcmp ("normal", str) == 0)
+    return META_FRAME_STATE_NORMAL;
+  else if (strcmp ("maximized", str) == 0)
+    return META_FRAME_STATE_MAXIMIZED;
+  else if (strcmp ("tiled_left", str) == 0)
+    return META_FRAME_STATE_TILED_LEFT;
+  else if (strcmp ("tiled_right", str) == 0)
+    return META_FRAME_STATE_TILED_RIGHT;
+  else if (strcmp ("shaded", str) == 0)
+    return META_FRAME_STATE_SHADED;
+  else if (strcmp ("maximized_and_shaded", str) == 0)
+    return META_FRAME_STATE_MAXIMIZED_AND_SHADED;
+  else if (strcmp ("tiled_left_and_shaded", str) == 0)
+    return META_FRAME_STATE_TILED_LEFT_AND_SHADED;
+  else if (strcmp ("tiled_right_and_shaded", str) == 0)
+    return META_FRAME_STATE_TILED_RIGHT_AND_SHADED;
+  else
+    return META_FRAME_STATE_LAST;
+}
+
+const char*
+meta_frame_state_to_string (MetaFrameState state)
+{
+  switch (state)
+    {
+    case META_FRAME_STATE_NORMAL:
+      return "normal";
+    case META_FRAME_STATE_MAXIMIZED:
+      return "maximized";
+    case META_FRAME_STATE_TILED_LEFT:
+      return "tiled_left";
+    case META_FRAME_STATE_TILED_RIGHT:
+      return "tiled_right";
+    case META_FRAME_STATE_SHADED:
+      return "shaded";
+    case META_FRAME_STATE_MAXIMIZED_AND_SHADED:
+      return "maximized_and_shaded";
+    case META_FRAME_STATE_TILED_LEFT_AND_SHADED:
+      return "tiled_left_and_shaded";
+    case META_FRAME_STATE_TILED_RIGHT_AND_SHADED:
+      return "tiled_right_and_shaded";
+    case META_FRAME_STATE_LAST:
+      break;
+    }
+
+  return "<unknown>";
+}
+
+MetaFrameResize
+meta_frame_resize_from_string (const char *str)
+{
+  if (strcmp ("none", str) == 0)
+    return META_FRAME_RESIZE_NONE;
+  else if (strcmp ("vertical", str) == 0)
+    return META_FRAME_RESIZE_VERTICAL;
+  else if (strcmp ("horizontal", str) == 0)
+    return META_FRAME_RESIZE_HORIZONTAL;
+  else if (strcmp ("both", str) == 0)
+    return META_FRAME_RESIZE_BOTH;
+  else
+    return META_FRAME_RESIZE_LAST;
+}
+
+const char*
+meta_frame_resize_to_string (MetaFrameResize resize)
+{
+  switch (resize)
+    {
+    case META_FRAME_RESIZE_NONE:
+      return "none";
+    case META_FRAME_RESIZE_VERTICAL:
+      return "vertical";
+    case META_FRAME_RESIZE_HORIZONTAL:
+      return "horizontal";
+    case META_FRAME_RESIZE_BOTH:
+      return "both";
+    case META_FRAME_RESIZE_LAST:
+      break;
+    }
+
+  return "<unknown>";
+}
+
+MetaFrameFocus
+meta_frame_focus_from_string (const char *str)
+{
+  if (strcmp ("no", str) == 0)
+    return META_FRAME_FOCUS_NO;
+  else if (strcmp ("yes", str) == 0)
+    return META_FRAME_FOCUS_YES;
+  else
+    return META_FRAME_FOCUS_LAST;
+}
+
+const char*
+meta_frame_focus_to_string (MetaFrameFocus focus)
+{
+  switch (focus)
+    {
+    case META_FRAME_FOCUS_NO:
+      return "no";
+    case META_FRAME_FOCUS_YES:
+      return "yes";
+    case META_FRAME_FOCUS_LAST:
+      break;
+    }
+
+  return "<unknown>";
+}
+
+MetaFrameType
+meta_frame_type_from_string (const char *str)
+{
+  if (strcmp ("normal", str) == 0)
+    return META_FRAME_TYPE_NORMAL;
+  else if (strcmp ("dialog", str) == 0)
+    return META_FRAME_TYPE_DIALOG;
+  else if (strcmp ("modal_dialog", str) == 0)
+    return META_FRAME_TYPE_MODAL_DIALOG;
+  else if (strcmp ("utility", str) == 0)
+    return META_FRAME_TYPE_UTILITY;
+  else if (strcmp ("menu", str) == 0)
+    return META_FRAME_TYPE_MENU;
+  else if (strcmp ("border", str) == 0)
+    return META_FRAME_TYPE_BORDER;
+  else if (strcmp ("attached", str) == 0)
+    return META_FRAME_TYPE_ATTACHED;
+#if 0
+  else if (strcmp ("toolbar", str) == 0)
+    return META_FRAME_TYPE_TOOLBAR;
+#endif
+  else
+    return META_FRAME_TYPE_LAST;
+}
+
 /**
  * meta_frame_type_to_string:
  * @type: a #MetaFrameType
@@ -1353,3 +6324,352 @@
 
   return "<unknown>";
 }
+
+MetaGradientType
+meta_gradient_type_from_string (const char *str)
+{
+  if (strcmp ("vertical", str) == 0)
+    return META_GRADIENT_VERTICAL;
+  else if (strcmp ("horizontal", str) == 0)
+    return META_GRADIENT_HORIZONTAL;
+  else if (strcmp ("diagonal", str) == 0)
+    return META_GRADIENT_DIAGONAL;
+  else
+    return META_GRADIENT_LAST;
+}
+
+GtkStateFlags
+meta_gtk_state_from_string (const char *str)
+{
+  if (g_ascii_strcasecmp ("normal", str) == 0)
+    return GTK_STATE_FLAG_NORMAL;
+  else if (g_ascii_strcasecmp ("prelight", str) == 0)
+    return GTK_STATE_FLAG_PRELIGHT;
+  else if (g_ascii_strcasecmp ("active", str) == 0)
+    return GTK_STATE_FLAG_ACTIVE;
+  else if (g_ascii_strcasecmp ("selected", str) == 0)
+    return GTK_STATE_FLAG_SELECTED;
+  else if (g_ascii_strcasecmp ("insensitive", str) == 0)
+    return GTK_STATE_FLAG_INSENSITIVE;
+  else if (g_ascii_strcasecmp ("inconsistent", str) == 0)
+    return GTK_STATE_FLAG_INCONSISTENT;
+  else if (g_ascii_strcasecmp ("focused", str) == 0)
+    return GTK_STATE_FLAG_FOCUSED;
+  else if (g_ascii_strcasecmp ("backdrop", str) == 0)
+    return GTK_STATE_FLAG_BACKDROP;
+  else
+    return -1; /* hack */
+}
+
+GtkShadowType
+meta_gtk_shadow_from_string (const char *str)
+{
+  if (strcmp ("none", str) == 0)
+    return GTK_SHADOW_NONE;
+  else if (strcmp ("in", str) == 0)
+    return GTK_SHADOW_IN;
+  else if (strcmp ("out", str) == 0)
+    return GTK_SHADOW_OUT;
+  else if (strcmp ("etched_in", str) == 0)
+    return GTK_SHADOW_ETCHED_IN;
+  else if (strcmp ("etched_out", str) == 0)
+    return GTK_SHADOW_ETCHED_OUT;
+  else
+    return -1;
+}
+
+GtkArrowType
+meta_gtk_arrow_from_string (const char *str)
+{
+  if (strcmp ("up", str) == 0)
+    return GTK_ARROW_UP;
+  else if (strcmp ("down", str) == 0)
+    return GTK_ARROW_DOWN;
+  else if (strcmp ("left", str) == 0)
+    return GTK_ARROW_LEFT;
+  else if (strcmp ("right", str) == 0)
+    return GTK_ARROW_RIGHT;
+  else if (strcmp ("none", str) == 0)
+    return GTK_ARROW_NONE;
+  else
+    return -1;
+}
+
+/**
+ * meta_image_fill_type_from_string:
+ * @str: a string representing a fill_type
+ *
+ * Returns a fill_type from a string.  The inverse of
+ * meta_image_fill_type_to_string().
+ *
+ * Returns: the fill type, or -1 if it represents no fill type.
+ */
+MetaImageFillType
+meta_image_fill_type_from_string (const char *str)
+{
+  if (strcmp ("tile", str) == 0)
+    return META_IMAGE_FILL_TILE;
+  else if (strcmp ("scale", str) == 0)
+    return META_IMAGE_FILL_SCALE;
+  else
+    return -1;
+}
+
+/**
+ * gtk_style_shade:
+ * @a: the starting colour
+ * @b: (out): the resulting colour
+ * @k: amount to scale lightness and saturation by
+ *
+ * Takes a colour "a", scales the lightness and saturation by a certain amount,
+ * and sets "b" to the resulting colour.
+ * gtkstyle.c cut-and-pastage.
+ */
+static void
+gtk_style_shade (GdkRGBA *a,
+                 GdkRGBA *b,
+                 gdouble   k)
+{
+  gdouble red;
+  gdouble green;
+  gdouble blue;
+
+  red = a->red;
+  green = a->green;
+  blue = a->blue;
+
+  rgb_to_hls (&red, &green, &blue);
+
+  green *= k;
+  if (green > 1.0)
+    green = 1.0;
+  else if (green < 0.0)
+    green = 0.0;
+
+  blue *= k;
+  if (blue > 1.0)
+    blue = 1.0;
+  else if (blue < 0.0)
+    blue = 0.0;
+
+  hls_to_rgb (&red, &green, &blue);
+
+  b->red = red;
+  b->green = green;
+  b->blue = blue;
+  b->alpha = a->alpha;
+}
+
+/**
+ * rgb_to_hls:
+ * @r: on input, red; on output, hue
+ * @g: on input, green; on output, lightness
+ * @b: on input, blue; on output, saturation
+ *
+ * Converts a red/green/blue triplet to a hue/lightness/saturation triplet.
+ */
+static void
+rgb_to_hls (gdouble *r,
+            gdouble *g,
+            gdouble *b)
+{
+  gdouble min;
+  gdouble max;
+  gdouble red;
+  gdouble green;
+  gdouble blue;
+  gdouble h, l, s;
+  gdouble delta;
+
+  red = *r;
+  green = *g;
+  blue = *b;
+
+  if (red > green)
+    {
+      if (red > blue)
+        max = red;
+      else
+        max = blue;
+
+      if (green < blue)
+        min = green;
+      else
+        min = blue;
+    }
+  else
+    {
+      if (green > blue)
+        max = green;
+      else
+        max = blue;
+
+      if (red < blue)
+        min = red;
+      else
+        min = blue;
+    }
+
+  l = (max + min) / 2;
+  s = 0;
+  h = 0;
+
+  if (max != min)
+    {
+      if (l <= 0.5)
+        s = (max - min) / (max + min);
+      else
+        s = (max - min) / (2 - max - min);
+
+      delta = max -min;
+      if (red == max)
+        h = (green - blue) / delta;
+      else if (green == max)
+        h = 2 + (blue - red) / delta;
+      else if (blue == max)
+        h = 4 + (red - green) / delta;
+
+      h *= 60;
+      if (h < 0.0)
+        h += 360;
+    }
+
+  *r = h;
+  *g = l;
+  *b = s;
+}
+
+/**
+ * hls_to_rgb:
+ * @h: on input, hue; on output, red
+ * @l: on input, lightness; on output, green
+ * @s: on input, saturation; on output, blue
+ *
+ * Converts a hue/lightness/saturation triplet to a red/green/blue triplet.
+ */
+static void
+hls_to_rgb (gdouble *h,
+            gdouble *l,
+            gdouble *s)
+{
+  gdouble hue;
+  gdouble lightness;
+  gdouble saturation;
+  gdouble m1, m2;
+  gdouble r, g, b;
+
+  lightness = *l;
+  saturation = *s;
+
+  if (lightness <= 0.5)
+    m2 = lightness * (1 + saturation);
+  else
+    m2 = lightness + saturation - lightness * saturation;
+  m1 = 2 * lightness - m2;
+
+  if (saturation == 0)
+    {
+      *h = lightness;
+      *l = lightness;
+      *s = lightness;
+    }
+  else
+    {
+      hue = *h + 120;
+      while (hue > 360)
+        hue -= 360;
+      while (hue < 0)
+        hue += 360;
+
+      if (hue < 60)
+        r = m1 + (m2 - m1) * hue / 60;
+      else if (hue < 180)
+        r = m2;
+      else if (hue < 240)
+        r = m1 + (m2 - m1) * (240 - hue) / 60;
+      else
+        r = m1;
+
+      hue = *h;
+      while (hue > 360)
+        hue -= 360;
+      while (hue < 0)
+        hue += 360;
+
+      if (hue < 60)
+        g = m1 + (m2 - m1) * hue / 60;
+      else if (hue < 180)
+        g = m2;
+      else if (hue < 240)
+        g = m1 + (m2 - m1) * (240 - hue) / 60;
+      else
+        g = m1;
+
+      hue = *h - 120;
+      while (hue > 360)
+        hue -= 360;
+      while (hue < 0)
+        hue += 360;
+
+      if (hue < 60)
+        b = m1 + (m2 - m1) * hue / 60;
+      else if (hue < 180)
+        b = m2;
+      else if (hue < 240)
+        b = m1 + (m2 - m1) * (240 - hue) / 60;
+      else
+        b = m1;
+
+      *h = r;
+      *l = g;
+      *s = b;
+    }
+}
+
+/**
+ * meta_theme_earliest_version_with_button:
+ * @type: the button type
+ *
+ * Returns the earliest version of the theme format which required support
+ * for a particular button.  (For example, "shade" first appeared in v2, and
+ * "close" in v1.)
+ *
+ * Returns: the number of the theme format
+ */
+guint
+meta_theme_earliest_version_with_button (MetaButtonType type)
+{
+  switch (type)
+    {
+    case META_BUTTON_TYPE_CLOSE:
+    case META_BUTTON_TYPE_MAXIMIZE:
+    case META_BUTTON_TYPE_MINIMIZE:
+    case META_BUTTON_TYPE_MENU:
+    case META_BUTTON_TYPE_LEFT_LEFT_BACKGROUND:
+    case META_BUTTON_TYPE_LEFT_MIDDLE_BACKGROUND:
+    case META_BUTTON_TYPE_LEFT_RIGHT_BACKGROUND:
+    case META_BUTTON_TYPE_RIGHT_LEFT_BACKGROUND:
+    case META_BUTTON_TYPE_RIGHT_MIDDLE_BACKGROUND:
+    case META_BUTTON_TYPE_RIGHT_RIGHT_BACKGROUND:
+      return 1000;
+
+    case META_BUTTON_TYPE_SHADE:
+    case META_BUTTON_TYPE_ABOVE:
+    case META_BUTTON_TYPE_STICK:
+    case META_BUTTON_TYPE_UNSHADE:
+    case META_BUTTON_TYPE_UNABOVE:
+    case META_BUTTON_TYPE_UNSTICK:
+      return 2000;
+
+    case META_BUTTON_TYPE_LEFT_SINGLE_BACKGROUND:
+    case META_BUTTON_TYPE_RIGHT_SINGLE_BACKGROUND:
+      return 3003;
+
+    case META_BUTTON_TYPE_APPMENU:
+      return 3005;
+
+    default:
+      meta_warning("Unknown button %d\n", type);
+      return 1000;
+    }
+}
diff '--exclude=.git' -urN a/src/ui/ui.c b/src/ui/ui.c
--- a/src/ui/ui.c	2015-06-13 23:59:51.996809000 -0400
+++ b/src/ui/ui.c	2015-10-31 10:11:44.919006873 -0400
@@ -80,6 +80,202 @@
   return gdk_screen_get_number (gdk_screen_get_default ());
 }
 
+/* For XInput2 */
+#include "display-private.h"
+
+static gboolean
+is_input_event (XEvent *event)
+{
+  MetaDisplay *display = meta_get_display ();
+
+  return (event->type == GenericEvent &&
+          event->xcookie.extension == display->xinput_opcode);
+}
+
+static gboolean
+is_interesting_input_event (XEvent *event)
+{
+  XIEvent *input_event;
+
+  if (!is_input_event (event))
+    return FALSE;
+
+  input_event = (XIEvent *) event->xcookie.data;
+  switch (input_event->evtype)
+    {
+    case XI_ButtonPress:
+    case XI_ButtonRelease:
+    case XI_Motion:
+    case XI_Enter:
+    case XI_Leave:
+    case XI_TouchBegin:
+    case XI_TouchUpdate:
+    case XI_TouchEnd:
+      return TRUE;
+    default:
+      return FALSE;
+    }
+}
+
+/* We do some of our event handling in frames.c, which expects
+ * GDK events delivered by GTK+.  However, since the transition to
+ * client side windows, we can't let GDK see button events, since the
+ * client-side tracking of implicit and explicit grabs it does will
+ * get confused by our direct use of X grabs in the core code.
+ *
+ * So we do a very minimal GDK => GTK event conversion here and send on the
+ * events we care about, and then filter them out so they don't go
+ * through the normal GDK event handling.
+ *
+ * To reduce the amount of code, the only events fields filled out
+ * below are the ones that frames.c uses. If frames.c is modified to
+ * use more fields, more fields need to be filled out below.
+ */
+
+static void
+maybe_redirect_mouse_event (XEvent *xevent)
+{
+  GdkDisplay *gdisplay;
+  GdkDeviceManager *gmanager;
+  GdkDevice *gdevice;
+  MetaUI *ui;
+  GdkEvent *gevent;
+  GdkWindow *gdk_window;
+  Window window;
+  XIEvent *xev;
+  XIDeviceEvent *xev_d = NULL;
+  XIEnterEvent *xev_e = NULL;
+
+  xev = (XIEvent *) xevent->xcookie.data;
+
+  switch (xev->evtype)
+    {
+    case XI_ButtonPress:
+    case XI_ButtonRelease:
+    case XI_Motion:
+      xev_d = (XIDeviceEvent *) xev;
+      window = xev_d->event;
+      break;
+    case XI_Enter:
+    case XI_Leave:
+      xev_e = (XIEnterEvent *) xev;
+      window = xev_e->event;
+      break;
+    default:
+      /* Not interested in this event. */
+      return;
+    }
+
+  gdisplay = gdk_x11_lookup_xdisplay (xev->display);
+  ui = g_object_get_data (G_OBJECT (gdisplay), "meta-ui");
+  if (!ui)
+    return;
+
+  gdk_window = gdk_x11_window_lookup_for_display (gdisplay, window);
+  if (gdk_window == NULL)
+    return;
+
+  gmanager = gdk_display_get_device_manager (gdisplay);
+  gdevice = gdk_x11_device_manager_lookup (gmanager, META_VIRTUAL_CORE_POINTER_ID);
+
+  switch (xev->evtype)
+    {
+    case XI_ButtonPress:
+    case XI_ButtonRelease:
+      if (xev_d->evtype == XI_ButtonPress)
+        {
+          GtkSettings *settings = gtk_settings_get_default ();
+          int double_click_time;
+          int double_click_distance;
+          int button;
+
+          g_object_get (settings,
+                        "gtk-double-click-time", &double_click_time,
+                        "gtk-double-click-distance", &double_click_distance,
+                        NULL);
+
+          button = xev_d->detail;
+
+          if (button == ui->button_click_number &&
+              xev_d->event == ui->button_click_window &&
+              xev_d->time < ui->button_click_time + double_click_time &&
+              ABS (xev_d->event_x - ui->button_click_x) <= double_click_distance &&
+              ABS (xev_d->event_y - ui->button_click_y) <= double_click_distance)
+            {
+              gevent = gdk_event_new (GDK_2BUTTON_PRESS);
+
+              ui->button_click_number = 0;
+            }
+          else
+            {
+              gevent = gdk_event_new (GDK_BUTTON_PRESS);
+              ui->button_click_number = button;
+              ui->button_click_window = xev_d->event;
+              ui->button_click_time = xev_d->time;
+              ui->button_click_x = xev_d->event_x;
+              ui->button_click_y = xev_d->event_y;
+            }
+
+          gevent->button.button = button;
+        }
+      else
+        {
+          gevent = gdk_event_new (GDK_BUTTON_RELEASE);
+          gevent->button.button = xev_d->detail;
+        }
+
+      gevent->button.window = g_object_ref (gdk_window);
+      gevent->button.time = xev_d->time;
+      gevent->button.x = xev_d->event_x;
+      gevent->button.y = xev_d->event_y;
+      gevent->button.x_root = xev_d->root_x;
+      gevent->button.y_root = xev_d->root_y;
+      break;
+    case XI_Motion:
+      gevent = gdk_event_new (GDK_MOTION_NOTIFY);
+      gevent->motion.window = g_object_ref (gdk_window);
+      gevent->motion.time = xev_d->time;
+      gevent->motion.x = xev_d->event_x;
+      gevent->motion.y = xev_d->event_y;
+      gevent->motion.x_root = xev_d->root_x;
+      gevent->motion.y_root = xev_d->root_y;
+
+      if (XIMaskIsSet (xev_d->buttons.mask, 1))
+        gevent->motion.state |= GDK_BUTTON1_MASK;
+      break;
+    case XI_Enter:
+    case XI_Leave:
+      gevent = gdk_event_new (xev_e->evtype == XI_Enter ? GDK_ENTER_NOTIFY : GDK_LEAVE_NOTIFY);
+      gevent->crossing.window = g_object_ref (gdk_window);
+      gevent->crossing.time = xev_e->time;
+      gevent->crossing.x = xev_e->event_x;
+      gevent->crossing.y = xev_e->event_y;
+      break;
+    default:
+      g_assert_not_reached ();
+      break;
+    }
+
+  /* If we've gotten here, we've created the gdk_event and should send it on */
+  gdk_event_set_device (gevent, gdevice);
+  gtk_main_do_event (gevent);
+  gdk_event_free (gevent);
+}
+
+static GdkFilterReturn
+ui_filter_func (GdkXEvent *xevent,
+                GdkEvent *event,
+                gpointer data)
+{
+  if (is_interesting_input_event (xevent))
+    {
+      maybe_redirect_mouse_event (xevent);
+      return GDK_FILTER_REMOVE;
+    }
+  else
+    return GDK_FILTER_CONTINUE;
+}
+
 MetaUI*
 meta_ui_new (Display *xdisplay,
              Screen  *screen)
@@ -103,6 +299,8 @@
    */
   gtk_widget_show (GTK_WIDGET (ui->frames));
 
+  gdk_window_add_filter (NULL, ui_filter_func, NULL);
+
   g_object_set_data (G_OBJECT (gdisplay), "meta-ui", ui);
 
   return ui;
@@ -118,9 +316,30 @@
   gdisplay = gdk_x11_lookup_xdisplay (ui->xdisplay);
   g_object_set_data (G_OBJECT (gdisplay), "meta-ui", NULL);
 
+  gdk_window_remove_filter (NULL, ui_filter_func, NULL);
+
   g_free (ui);
 }
 
+void
+meta_ui_get_frame_mask (MetaUI  *ui,
+                        Window   frame_xwindow,
+                        guint    width,
+                        guint    height,
+                        cairo_t *cr)
+{
+  meta_frames_get_mask (ui->frames, frame_xwindow, width, height, cr);
+}
+
+void
+meta_ui_get_frame_borders (MetaUI *ui,
+                           Window frame_xwindow,
+                           MetaFrameBorders *borders)
+{
+  meta_frames_get_borders (ui->frames, frame_xwindow,
+                           borders);
+}
+
 static void
 set_background_none (Display *xdisplay,
                      Window   xwindow)
@@ -132,17 +351,16 @@
                            CWBackPixmap, &attrs);
 }
 
-MetaUIFrame *
-meta_ui_create_frame (MetaUI *ui,
-                      Display *xdisplay,
-                      MetaWindow *meta_window,
-                      Visual *xvisual,
-                      gint x,
-                      gint y,
-                      gint width,
-                      gint height,
-                      gint screen_no,
-                      gulong *create_serial)
+Window
+meta_ui_create_frame_window (MetaUI *ui,
+                             Display *xdisplay,
+                             Visual *xvisual,
+			     gint x,
+			     gint y,
+			     gint width,
+			     gint height,
+			     gint screen_no,
+                             gulong *create_serial)
 {
   GdkDisplay *display = gdk_x11_lookup_xdisplay (xdisplay);
   GdkScreen *screen = gdk_display_get_screen (display, screen_no);
@@ -195,7 +413,27 @@
   gdk_window_resize (window, width, height);
   set_background_none (xdisplay, GDK_WINDOW_XID (window));
 
-  return meta_frames_manage_window (ui->frames, meta_window, GDK_WINDOW_XID (window), window);
+  meta_frames_manage_window (ui->frames, GDK_WINDOW_XID (window), window);
+
+  return GDK_WINDOW_XID (window);
+}
+
+void
+meta_ui_destroy_frame_window (MetaUI *ui,
+			      Window  xwindow)
+{
+  meta_frames_unmanage_window (ui->frames, xwindow);
+}
+
+void
+meta_ui_move_resize_frame (MetaUI *ui,
+			   Window frame,
+			   int x,
+			   int y,
+			   int width,
+			   int height)
+{
+  meta_frames_move_resize_frame (ui->frames, frame, x, y, width, height);
 }
 
 void
@@ -226,6 +464,95 @@
     gdk_window_hide (window);
 }
 
+void
+meta_ui_update_frame_style (MetaUI  *ui,
+                            Window   xwindow)
+{
+  meta_frames_update_frame_style (ui->frames, xwindow);
+}
+
+void
+meta_ui_repaint_frame (MetaUI *ui,
+                       Window xwindow)
+{
+  meta_frames_repaint_frame (ui->frames, xwindow);
+}
+
+cairo_region_t *
+meta_ui_get_frame_bounds (MetaUI  *ui,
+                          Window   xwindow,
+                          int      window_width,
+                          int      window_height)
+{
+  return meta_frames_get_frame_bounds (ui->frames, xwindow,
+                                       window_width, window_height);
+}
+
+void
+meta_ui_queue_frame_draw (MetaUI *ui,
+                          Window xwindow)
+{
+  meta_frames_queue_draw (ui->frames, xwindow);
+}
+
+void
+meta_ui_set_frame_title (MetaUI     *ui,
+                         Window      xwindow,
+                         const char *title)
+{
+  meta_frames_set_title (ui->frames, xwindow, title);
+}
+
+GdkPixbuf*
+meta_gdk_pixbuf_get_from_pixmap (Pixmap       xpixmap,
+                                 int          src_x,
+                                 int          src_y,
+                                 int          width,
+                                 int          height)
+{
+  cairo_surface_t *surface;
+  Display *display;
+  Window root_return;
+  int x_ret, y_ret;
+  unsigned int w_ret, h_ret, bw_ret, depth_ret;
+  XWindowAttributes attrs;
+  GdkPixbuf *retval;
+
+  display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+
+  if (!XGetGeometry (display, xpixmap, &root_return,
+                     &x_ret, &y_ret, &w_ret, &h_ret, &bw_ret, &depth_ret))
+    return NULL;
+
+  if (depth_ret == 1)
+    {
+      surface = cairo_xlib_surface_create_for_bitmap (display,
+                                                      xpixmap,
+                                                      GDK_SCREEN_XSCREEN (gdk_screen_get_default ()),
+                                                      w_ret,
+                                                      h_ret);
+    }
+  else
+    {
+      if (!XGetWindowAttributes (display, root_return, &attrs))
+        return NULL;
+
+      surface = cairo_xlib_surface_create (display,
+                                           xpixmap,
+                                           attrs.visual,
+                                           w_ret, h_ret);
+    }
+
+  retval = gdk_pixbuf_get_from_surface (surface,
+                                        src_x,
+                                        src_y,
+                                        width,
+                                        height);
+  cairo_surface_destroy (surface);
+
+  return retval;
+}
+
 gboolean
 meta_ui_window_should_not_cause_focus (Display *xdisplay,
                                        Window   xwindow)
diff '--exclude=.git' -urN a/src/ui/ui.h b/src/ui/ui.h
--- a/src/ui/ui.h	2015-06-13 23:59:51.996809000 -0400
+++ b/src/ui/ui.h	2015-10-31 10:11:44.918006879 -0400
@@ -24,7 +24,6 @@
 
 /* Don't include gtk.h or gdk.h here */
 #include <meta/common.h>
-#include <meta/types.h>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 #include <cairo.h>
@@ -32,7 +31,6 @@
 #include <gdk-pixbuf/gdk-pixbuf.h>
 
 typedef struct _MetaUI MetaUI;
-typedef struct _MetaUIFrame MetaUIFrame;
 
 typedef gboolean (* MetaEventFunc) (XEvent *xevent, gpointer data);
 
@@ -50,17 +48,27 @@
                                       MetaFrameType      type,
                                       MetaFrameFlags     flags,
                                       MetaFrameBorders *borders);
+void meta_ui_get_frame_borders (MetaUI *ui,
+                                Window frame_xwindow,
+                                MetaFrameBorders *borders);
+
+void meta_ui_get_frame_mask (MetaUI *ui,
+                             Window frame_xwindow,
+                             guint width,
+                             guint height,
+                             cairo_t *cr);
 
-MetaUIFrame * meta_ui_create_frame (MetaUI *ui,
+Window meta_ui_create_frame_window (MetaUI *ui,
                                     Display *xdisplay,
-                                    MetaWindow *meta_window,
                                     Visual *xvisual,
-                                    gint x,
-                                    gint y,
-                                    gint width,
-                                    gint height,
-                                    gint screen_no,
+				    gint x,
+				    gint y,
+				    gint width,
+				    gint height,
+				    gint screen_no,
                                     gulong *create_serial);
+void meta_ui_destroy_frame_window (MetaUI *ui,
+				   Window  xwindow);
 void meta_ui_move_resize_frame (MetaUI *ui,
 				Window frame,
 				int x,
@@ -74,6 +82,32 @@
 void meta_ui_unmap_frame (MetaUI *ui,
                           Window  xwindow);
 
+cairo_region_t *meta_ui_get_frame_bounds (MetaUI  *ui,
+                                          Window   xwindow,
+                                          int      window_width,
+                                          int      window_height);
+
+void meta_ui_queue_frame_draw (MetaUI *ui,
+                               Window xwindow);
+
+void meta_ui_set_frame_title (MetaUI *ui,
+                              Window xwindow,
+                              const char *title);
+
+void meta_ui_update_frame_style (MetaUI  *ui,
+                                 Window   window);
+
+void meta_ui_repaint_frame (MetaUI *ui,
+                            Window xwindow);
+
+
+/* FIXME these lack a display arg */
+GdkPixbuf* meta_gdk_pixbuf_get_from_pixmap (Pixmap       xpixmap,
+                                            int          src_x,
+                                            int          src_y,
+                                            int          width,
+                                            int          height);
+
 gboolean  meta_ui_window_should_not_cause_focus (Display *xdisplay,
                                                  Window   xwindow);
 
diff '--exclude=.git' -urN a/src/wayland/meta-wayland-pointer.c b/src/wayland/meta-wayland-pointer.c
--- a/src/wayland/meta-wayland-pointer.c	2015-10-30 16:39:40.976006653 -0400
+++ b/src/wayland/meta-wayland-pointer.c	2015-10-31 09:08:01.998561337 -0400
@@ -73,7 +73,6 @@
     {
     case META_EVENT_ROUTE_WINDOW_OP:
     case META_EVENT_ROUTE_COMPOSITOR_GRAB:
-    case META_EVENT_ROUTE_FRAME_BUTTON:
       /* The compositor has a grab, so remove our focus... */
       meta_wayland_pointer_set_focus (pointer, NULL);
       break;
diff '--exclude=.git' -urN a/src/wayland/window-wayland.c b/src/wayland/window-wayland.c
--- a/src/wayland/window-wayland.c	2015-10-30 16:39:40.977006649 -0400
+++ b/src/wayland/window-wayland.c	2015-10-31 10:07:14.335539878 -0400
@@ -31,7 +31,6 @@
 #include "boxes-private.h"
 #include "stack-tracker.h"
 #include "meta-wayland-surface.h"
-#include "compositor/meta-surface-actor-wayland.h"
 
 struct _MetaWindowWayland
 {
@@ -278,21 +277,6 @@
 }
 
 static void
-meta_window_wayland_main_monitor_changed (MetaWindow *window,
-                                          const MetaMonitorInfo *old)
-{
-  MetaWaylandSurface *surface = window->surface;
-
-  if (surface)
-    {
-      MetaSurfaceActorWayland *actor =
-        META_SURFACE_ACTOR_WAYLAND (surface->surface_actor);
-
-      meta_surface_actor_wayland_sync_state_recursive (actor);
-    }
-}
-
-static void
 appears_focused_changed (GObject    *object,
                          GParamSpec *pspec,
                          gpointer    user_data)
@@ -330,7 +314,6 @@
   window_class->grab_op_began = meta_window_wayland_grab_op_began;
   window_class->grab_op_ended = meta_window_wayland_grab_op_ended;
   window_class->move_resize_internal = meta_window_wayland_move_resize_internal;
-  window_class->main_monitor_changed = meta_window_wayland_main_monitor_changed;
 }
 
 MetaWindow *
diff '--exclude=.git' -urN a/src/x11/iconcache.c b/src/x11/iconcache.c
--- a/src/x11/iconcache.c	2015-10-30 16:39:40.977006649 -0400
+++ b/src/x11/iconcache.c	2015-10-31 10:11:44.910006924 -0400
@@ -19,18 +19,14 @@
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "config.h"
-
+#include <config.h>
 #include "iconcache.h"
-
+#include "ui.h"
 #include <meta/errors.h>
 
-#include <cairo.h>
-#include <cairo-xlib.h>
-#include <cairo-xlib-xrender.h>
-
 #include <X11/Xatom.h>
-#include <X11/extensions/Xrender.h>
+
+/* The icon-reading code is also in libwnck, please sync bugfixes */
 
 static gboolean
 find_largest_sizes (gulong *data,
@@ -160,40 +156,51 @@
     return FALSE;
 }
 
-static cairo_surface_t *
-argbdata_to_surface (gulong *argb_data, int w, int h)
+static void
+argbdata_to_pixdata (gulong *argb_data, int len, guchar **pixdata)
 {
-  cairo_surface_t *surface;
-  int y, x, stride;
-  uint32_t *data;
-
-  surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, w, h);
-  stride = cairo_image_surface_get_stride (surface) / sizeof (uint32_t);
-  data = (uint32_t *) cairo_image_surface_get_data (surface);
+  guchar *p;
+  int i;
+
+  *pixdata = g_new (guchar, len * 4);
+  p = *pixdata;
 
   /* One could speed this up a lot. */
-  for (y = 0; y < h; y++)
+  i = 0;
+  while (i < len)
     {
-      for (x = 0; x < w; x++)
-        {
-          uint32_t *p = &data[y * stride + x];
-          gulong *d = &argb_data[y * w + x];
-          *p = *d;
-        }
-    }
+      guint argb;
+      guint rgba;
+
+      argb = argb_data[i];
+      rgba = (argb << 8) | (argb >> 24);
+
+      *p = rgba >> 24;
+      ++p;
+      *p = (rgba >> 16) & 0xff;
+      ++p;
+      *p = (rgba >> 8) & 0xff;
+      ++p;
+      *p = rgba & 0xff;
+      ++p;
 
-  return surface;
+      ++i;
+    }
 }
 
 static gboolean
-read_rgb_icon (MetaDisplay      *display,
-               Window            xwindow,
-               int               ideal_width,
-               int               ideal_height,
-               int               ideal_mini_width,
-               int               ideal_mini_height,
-               cairo_surface_t **icon,
-               cairo_surface_t **mini_icon)
+read_rgb_icon (MetaDisplay   *display,
+               Window         xwindow,
+               int            ideal_width,
+               int            ideal_height,
+               int            ideal_mini_width,
+               int            ideal_mini_height,
+               int           *width,
+               int           *height,
+               guchar       **pixdata,
+               int           *mini_width,
+               int           *mini_height,
+               guchar       **mini_pixdata)
 {
   Atom type;
   int format;
@@ -246,8 +253,14 @@
       return FALSE;
     }
 
-  *icon = argbdata_to_surface (best, w, h);
-  *mini_icon = argbdata_to_surface (best_mini, mini_w, mini_h);
+  *width = w;
+  *height = h;
+
+  *mini_width = mini_w;
+  *mini_height = mini_h;
+
+  argbdata_to_pixdata (best, w * h, pixdata);
+  argbdata_to_pixdata (best_mini, mini_w * mini_h, mini_pixdata);
 
   XFree (data);
 
@@ -255,6 +268,12 @@
 }
 
 static void
+free_pixels (guchar *pixels, gpointer data)
+{
+  g_free (pixels);
+}
+
+static void
 get_pixmap_geometry (MetaDisplay *display,
                      Pixmap       pixmap,
                      int         *w,
@@ -286,52 +305,96 @@
     *d = depth;
 }
 
-static int
-standard_pict_format_for_depth (int depth)
+static void
+apply_foreground_background (GdkPixbuf *pixbuf)
 {
-  switch (depth)
+  int w, h;
+  int i, j;
+  guchar *pixels;
+  int stride;
+
+  w = gdk_pixbuf_get_width (pixbuf);
+  h = gdk_pixbuf_get_height (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  stride = gdk_pixbuf_get_rowstride (pixbuf);
+
+  i = 0;
+  while (i < h)
     {
-    case 1:
-      return PictStandardA1;
-    case 24:
-      return PictStandardRGB24;
-    case 32:
-      return PictStandardARGB32;
-    default:
-      g_assert_not_reached ();
+      j = 0;
+      while (j < w)
+        {
+          guchar *p = pixels + i * stride + j * 4;
+          if (p[3] == 0)
+            p[0] = p[1] = p[2] =  0xff; /* white background */
+          else
+            p[0] = p[1] = p[2] = 0x00; /* black foreground */
+
+          p[3] = 0xff;
+
+          ++j;
+        }
+
+      ++i;
     }
 }
 
-static XRenderPictFormat *
-pict_format_for_depth (Display *xdisplay, int depth)
+static GdkPixbuf*
+apply_mask (GdkPixbuf *pixbuf,
+            GdkPixbuf *mask)
 {
-  return XRenderFindStandardFormat (xdisplay, standard_pict_format_for_depth (depth));
-}
+  int w, h;
+  int i, j;
+  GdkPixbuf *with_alpha;
+  guchar *src;
+  guchar *dest;
+  int src_stride;
+  int dest_stride;
 
-static cairo_surface_t *
-surface_from_pixmap (Display *xdisplay, Pixmap xpixmap,
-                     int width, int height)
-{
-  Window root_return;
-  int x_ret, y_ret;
-  unsigned int w_ret, h_ret, bw_ret, depth_ret;
+  w = MIN (gdk_pixbuf_get_width (mask), gdk_pixbuf_get_width (pixbuf));
+  h = MIN (gdk_pixbuf_get_height (mask), gdk_pixbuf_get_height (pixbuf));
 
-  if (!XGetGeometry (xdisplay, xpixmap, &root_return,
-                     &x_ret, &y_ret, &w_ret, &h_ret, &bw_ret, &depth_ret))
-    return NULL;
+  with_alpha = gdk_pixbuf_add_alpha (pixbuf, FALSE, 0, 0, 0);
+
+  dest = gdk_pixbuf_get_pixels (with_alpha);
+  src = gdk_pixbuf_get_pixels (mask);
 
-  return cairo_xlib_surface_create_with_xrender_format (xdisplay, xpixmap, DefaultScreenOfDisplay (xdisplay),
-                                                        pict_format_for_depth (xdisplay, depth_ret), w_ret, h_ret);
+  dest_stride = gdk_pixbuf_get_rowstride (with_alpha);
+  src_stride = gdk_pixbuf_get_rowstride (mask);
+
+  i = 0;
+  while (i < h)
+    {
+      j = 0;
+      while (j < w)
+        {
+          guchar *s = src + i * src_stride + j * 4;
+          guchar *d = dest + i * dest_stride + j * 4;
+
+          d[3] = s[3];
+
+          ++j;
+        }
+
+      ++i;
+    }
+
+  return with_alpha;
 }
 
 static gboolean
-try_pixmap_and_mask (MetaDisplay      *display,
-                     Pixmap            src_pixmap,
-                     Pixmap            src_mask,
-                     cairo_surface_t **iconp)
+try_pixmap_and_mask (MetaDisplay *display,
+                     Pixmap       src_pixmap,
+                     Pixmap       src_mask,
+                     GdkPixbuf  **iconp,
+                     int          ideal_width,
+                     int          ideal_height,
+                     GdkPixbuf  **mini_iconp,
+                     int          ideal_mini_width,
+                     int          ideal_mini_height)
 {
-  Display *xdisplay = display->xdisplay;
-  cairo_surface_t *icon, *mask = NULL;
+  GdkPixbuf *unscaled = NULL;
+  GdkPixbuf *mask = NULL;
   int w, h, d;
 
   if (src_pixmap == None)
@@ -340,48 +403,72 @@
   meta_error_trap_push (display);
 
   get_pixmap_geometry (display, src_pixmap, &w, &h, &d);
-  icon = surface_from_pixmap (xdisplay, src_pixmap, w, h);
 
-  if (icon && src_mask != None)
+  unscaled = meta_gdk_pixbuf_get_from_pixmap (src_pixmap,
+                                              0, 0,
+                                              w, h);
+
+  /* A depth 1 pixmap has 0 background, and 1 foreground, but
+   * cairo and meta_gdk_pixbuf_get_from_pixmap consider it
+   * to be 0 transparent, 1 opaque */
+  if (d == 1)
+    apply_foreground_background (unscaled);
+
+  if (unscaled && src_mask != None)
     {
       get_pixmap_geometry (display, src_mask, &w, &h, &d);
-
       if (d == 1)
-        mask = surface_from_pixmap (xdisplay, src_mask, w, h);
+        mask = meta_gdk_pixbuf_get_from_pixmap (src_mask,
+                                                0, 0,
+                                                w, h);
     }
 
   meta_error_trap_pop (display);
 
-  if (icon && mask)
+  if (mask)
     {
-      cairo_surface_t *masked;
-      cairo_t *cr;
-
-      masked = cairo_surface_create_similar_image (icon,
-                                                   CAIRO_FORMAT_ARGB32,
-                                                   cairo_xlib_surface_get_width (icon),
-                                                   cairo_xlib_surface_get_height (icon));
-      cr = cairo_create (masked);
-
-      cairo_set_source_surface (cr, icon, 0, 0);
-      cairo_mask_surface (cr, mask, 0, 0);
+      GdkPixbuf *masked;
 
-      cairo_destroy (cr);
-      cairo_surface_destroy (icon);
-      cairo_surface_destroy (mask);
+      masked = apply_mask (unscaled, mask);
+      g_object_unref (G_OBJECT (unscaled));
+      unscaled = masked;
+
+      g_object_unref (G_OBJECT (mask));
+      mask = NULL;
+    }
+
+  if (unscaled)
+    {
+      *iconp =
+        gdk_pixbuf_scale_simple (unscaled,
+                                 ideal_width > 0 ? ideal_width :
+                                 gdk_pixbuf_get_width (unscaled),
+                                 ideal_height > 0 ? ideal_height :
+                                 gdk_pixbuf_get_height (unscaled),
+                                 GDK_INTERP_BILINEAR);
+      *mini_iconp =
+        gdk_pixbuf_scale_simple (unscaled,
+                                 ideal_mini_width > 0 ? ideal_mini_width :
+                                 gdk_pixbuf_get_width (unscaled),
+                                 ideal_mini_height > 0 ? ideal_mini_height :
+                                 gdk_pixbuf_get_height (unscaled),
+                                 GDK_INTERP_BILINEAR);
 
-      icon = masked;
-    }
+      g_object_unref (G_OBJECT (unscaled));
 
-  if (icon)
-    {
-      *iconp = icon;
-      return TRUE;
+      if (*iconp && *mini_iconp)
+        return TRUE;
+      else
+        {
+          if (*iconp)
+            g_object_unref (G_OBJECT (*iconp));
+          if (*mini_iconp)
+            g_object_unref (G_OBJECT (*mini_iconp));
+          return FALSE;
+        }
     }
   else
-    {
-      return FALSE;
-    }
+    return FALSE;
 }
 
 static void
@@ -475,18 +562,74 @@
     return FALSE;
 }
 
+static GdkPixbuf*
+scaled_from_pixdata (guchar *pixdata,
+                     int     w,
+                     int     h,
+                     int     new_w,
+                     int     new_h)
+{
+  GdkPixbuf *src;
+  GdkPixbuf *dest;
+
+  src = gdk_pixbuf_new_from_data (pixdata,
+                                  GDK_COLORSPACE_RGB,
+                                  TRUE,
+                                  8,
+                                  w, h, w * 4,
+                                  free_pixels,
+                                  NULL);
+
+  if (src == NULL)
+    return NULL;
+
+  if (w != h)
+    {
+      GdkPixbuf *tmp;
+      int size;
+
+      size = MAX (w, h);
+
+      tmp = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, size, size);
+
+      if (tmp)
+	{
+	  gdk_pixbuf_fill (tmp, 0);
+	  gdk_pixbuf_copy_area (src, 0, 0, w, h,
+				tmp,
+				(size - w) / 2, (size - h) / 2);
+
+	  g_object_unref (src);
+	  src = tmp;
+	}
+    }
+
+  if (w != new_w || h != new_h)
+    {
+      dest = gdk_pixbuf_scale_simple (src, new_w, new_h, GDK_INTERP_BILINEAR);
+
+      g_object_unref (G_OBJECT (src));
+    }
+  else
+    {
+      dest = src;
+    }
+
+  return dest;
+}
+
 gboolean
-meta_read_icons (MetaScreen       *screen,
-                 Window            xwindow,
-                 MetaIconCache    *icon_cache,
-                 Pixmap            wm_hints_pixmap,
-                 Pixmap            wm_hints_mask,
-                 cairo_surface_t **iconp,
-                 int               ideal_width,
-                 int               ideal_height,
-                 cairo_surface_t **mini_iconp,
-                 int               ideal_mini_width,
-                 int               ideal_mini_height)
+meta_read_icons (MetaScreen     *screen,
+                 Window          xwindow,
+                 MetaIconCache  *icon_cache,
+                 Pixmap          wm_hints_pixmap,
+                 Pixmap          wm_hints_mask,
+                 GdkPixbuf     **iconp,
+                 int             ideal_width,
+                 int             ideal_height,
+                 GdkPixbuf     **mini_iconp,
+                 int             ideal_mini_width,
+                 int             ideal_mini_height)
 {
   /* Return value is whether the icon changed */
 
@@ -510,15 +653,37 @@
   if (icon_cache->origin <= USING_NET_WM_ICON &&
       icon_cache->net_wm_icon_dirty)
     {
+      guchar *pixdata;
+      int w, h;
+      guchar *mini_pixdata;
+      int mini_w, mini_h;
+
       icon_cache->net_wm_icon_dirty = FALSE;
 
       if (read_rgb_icon (screen->display, xwindow,
                          ideal_width, ideal_height,
                          ideal_mini_width, ideal_mini_height,
-                         iconp, mini_iconp))
+                         &w, &h, &pixdata,
+                         &mini_w, &mini_h, &mini_pixdata))
         {
-          icon_cache->origin = USING_NET_WM_ICON;
-          return TRUE;
+          *iconp = scaled_from_pixdata (pixdata, w, h,
+                                        ideal_width, ideal_height);
+
+          *mini_iconp = scaled_from_pixdata (mini_pixdata, mini_w, mini_h,
+                                             ideal_mini_width, ideal_mini_height);
+
+          if (*iconp && *mini_iconp)
+            {
+              icon_cache->origin = USING_NET_WM_ICON;
+              return TRUE;
+            }
+          else
+            {
+              if (*iconp)
+                g_object_unref (G_OBJECT (*iconp));
+              if (*mini_iconp)
+                g_object_unref (G_OBJECT (*mini_iconp));
+            }
         }
     }
 
@@ -541,9 +706,11 @@
            mask != icon_cache->prev_mask) &&
           pixmap != None)
         {
-          if (try_pixmap_and_mask (screen->display, pixmap, mask, iconp))
+          if (try_pixmap_and_mask (screen->display,
+                                   pixmap, mask,
+                                   iconp, ideal_width, ideal_height,
+                                   mini_iconp, ideal_mini_width, ideal_mini_height))
             {
-              *mini_iconp = cairo_surface_reference (*iconp);
               icon_cache->prev_pixmap = pixmap;
               icon_cache->prev_mask = mask;
               icon_cache->origin = USING_WM_HINTS;
@@ -566,9 +733,10 @@
            mask != icon_cache->prev_mask) &&
           pixmap != None)
         {
-          if (try_pixmap_and_mask (screen->display, pixmap, mask, iconp))
+          if (try_pixmap_and_mask (screen->display, pixmap, mask,
+                                   iconp, ideal_width, ideal_height,
+                                   mini_iconp, ideal_mini_width, ideal_mini_height))
             {
-              *mini_iconp = cairo_surface_reference (*iconp);
               icon_cache->prev_pixmap = pixmap;
               icon_cache->prev_mask = mask;
               icon_cache->origin = USING_KWM_WIN_ICON;
diff '--exclude=.git' -urN a/src/x11/iconcache.h b/src/x11/iconcache.h
--- a/src/x11/iconcache.h	2015-06-13 23:59:51.999809000 -0400
+++ b/src/x11/iconcache.h	2015-10-31 10:11:44.910006924 -0400
@@ -56,17 +56,17 @@
                                                      Atom           atom);
 gboolean       meta_icon_cache_get_icon_invalidated (MetaIconCache *icon_cache);
 
-gboolean meta_read_icons         (MetaScreen       *screen,
-                                  Window            xwindow,
-                                  MetaIconCache    *icon_cache,
-                                  Pixmap            wm_hints_pixmap,
-                                  Pixmap            wm_hints_mask,
-                                  cairo_surface_t **iconp,
-                                  int               ideal_width,
-                                  int               ideal_height,
-                                  cairo_surface_t **mini_iconp,
-                                  int               ideal_mini_width,
-                                  int               ideal_mini_height);
+gboolean meta_read_icons         (MetaScreen     *screen,
+                                  Window          xwindow,
+                                  MetaIconCache  *icon_cache,
+                                  Pixmap          wm_hints_pixmap,
+                                  Pixmap          wm_hints_mask,
+                                  GdkPixbuf     **iconp,
+                                  int             ideal_width,
+                                  int             ideal_height,
+                                  GdkPixbuf     **mini_iconp,
+                                  int             ideal_mini_width,
+                                  int             ideal_mini_height);
 
 #endif
 
diff '--exclude=.git' -urN a/src/x11/window-x11-private.h b/src/x11/window-x11-private.h
--- a/src/x11/window-x11-private.h	2015-06-13 23:59:52.000809000 -0400
+++ b/src/x11/window-x11-private.h	2015-10-31 08:10:52.054906336 -0400
@@ -25,6 +25,7 @@
 
 #include "window-private.h"
 #include "x11/iconcache.h"
+#include "ui/resizepopup.h"
 
 G_BEGIN_DECLS
 
@@ -55,7 +56,7 @@
   /* Requested geometry */
   int border_width;
 
-  gboolean showing_resize_popup;
+  MetaResizePopup *grab_resize_popup;
 
   /* These are in server coordinates. If we have a frame, it's
    * relative to the frame. */
diff '--exclude=.git' -urN a/src/x11/window-x11.c b/src/x11/window-x11.c
--- a/src/x11/window-x11.c	2015-10-30 16:39:40.978006645 -0400
+++ b/src/x11/window-x11.c	2015-10-31 10:11:44.918006879 -0400
@@ -44,6 +44,7 @@
 #include "window-private.h"
 #include "window-props.h"
 #include "xprops.h"
+#include "resizepopup.h"
 #include "session.h"
 #include "workspace-private.h"
 
@@ -827,28 +828,18 @@
 {
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
   MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
+  MetaRectangle rect;
 
-  if (priv->showing_resize_popup)
-    {
-      MetaRectangle rect;
-      int display_w, display_h;
-
-      meta_window_get_client_root_coords (window, &rect);
+  meta_window_get_client_root_coords (window, &rect);
 
-      display_w = (rect.width - window->size_hints.base_width);
-      if (window->size_hints.width_inc > 0)
-        display_w /= window->size_hints.width_inc;
+  meta_ui_resize_popup_set (priv->grab_resize_popup,
+                            rect,
+                            window->size_hints.base_width,
+                            window->size_hints.base_height,
+                            window->size_hints.width_inc,
+                            window->size_hints.height_inc);
 
-      display_h = (rect.height - window->size_hints.base_height);
-      if (window->size_hints.height_inc > 0)
-        display_h /= window->size_hints.height_inc;
-
-      meta_display_show_resize_popup (window->display, TRUE, &rect, display_w, display_h);
-    }
-  else
-    {
-      meta_display_show_resize_popup (window->display, FALSE, NULL, 0, 0);
-    }
+  meta_ui_resize_popup_set_showing (priv->grab_resize_popup, TRUE);
 }
 
 static void
@@ -865,7 +856,8 @@
 
       if (window->size_hints.width_inc > 1 || window->size_hints.height_inc > 1)
         {
-          priv->showing_resize_popup = TRUE;
+          priv->grab_resize_popup = meta_ui_resize_popup_new (window->display->xdisplay,
+                                                              window->screen->number);
           meta_window_refresh_resize_popup (window);
         }
     }
@@ -880,10 +872,10 @@
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
   MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
 
-  if (priv->showing_resize_popup)
+  if (priv->grab_resize_popup)
     {
-      priv->showing_resize_popup = FALSE;
-      meta_window_refresh_resize_popup (window);
+      meta_ui_resize_popup_free (priv->grab_resize_popup);
+      priv->grab_resize_popup = NULL;
     }
 
   META_WINDOW_CLASS (meta_window_x11_parent_class)->grab_op_ended (window, op);
@@ -1266,7 +1258,7 @@
   if (need_configure_notify)
     send_configure_notify (window);
 
-  if (priv->showing_resize_popup)
+  if (priv->grab_resize_popup)
     meta_window_refresh_resize_popup (window);
 
   if (frame_shape_changed)
@@ -1453,9 +1445,9 @@
 }
 
 static gboolean
-meta_window_x11_update_icon (MetaWindow       *window,
-                             cairo_surface_t **icon,
-                             cairo_surface_t **mini_icon)
+meta_window_x11_update_icon (MetaWindow  *window,
+                             GdkPixbuf  **icon,
+                             GdkPixbuf  **mini_icon)
 {
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
   MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
@@ -1472,12 +1464,6 @@
 }
 
 static void
-meta_window_x11_main_monitor_changed (MetaWindow *window,
-                                      const MetaMonitorInfo *old)
-{
-}
-
-static void
 meta_window_x11_class_init (MetaWindowX11Class *klass)
 {
   MetaWindowClass *window_class = META_WINDOW_CLASS (klass);
@@ -1495,7 +1481,6 @@
   window_class->update_struts = meta_window_x11_update_struts;
   window_class->get_default_skip_hints = meta_window_x11_get_default_skip_hints;
   window_class->update_icon = meta_window_x11_update_icon;
-  window_class->main_monitor_changed = meta_window_x11_main_monitor_changed;
 }
 
 void
